#pragma once

#if USE_GML

#define GLM_SWIZZLE
#define GLM_ADL_FRIENDLY
#define GLM_FORCE_CXX11

#include <glm/glm.hpp>
#include <type_traits>

#ifndef MATHX_MINIMAL
	#include <glm/ext.hpp>
	#include <iosfwd>
#else
	#include <glm/gtx/component_wise.hpp>
#endif

#ifndef MATHX_API
	#define MATHX_API
#endif

namespace sml = glm;
namespace glm
{


#else

#include <climits>
#include <cfloat>
#include <cmath>
#include <type_traits>
#include "vector_math.h"

#ifndef MATHX_API
	#define MATHX_API SML_API
#endif

namespace glm = sml;
namespace sml
{
#endif
	// POD AABB (no default initialization)
	template <class Vec>
	struct aabb { Vec min, max; };

	// POD ray (no default initialization)
	template <class Vec>
	struct ray { Vec o, d; };

	// Utilities
	template <class Vec>
	MATHX_API inline bool in_aabb(Vec const& p, Vec const& min, Vec const& max)
	{
		return all(lessThanEqual(min, p)) && all(lessThanEqual(p, max));
	}
	template <class Vec>
	MATHX_API inline bool in_aabb(Vec const& p, aabb<Vec> const& box)
	{
		return in_aabb(p, box.min, box.max);
	}
	
	MATHX_API inline float triangle_sign(glm::vec3 const& v0, glm::vec3 const& v1, glm::vec3 const& v2, glm::vec3 const& origin)
	{
		// > 0 if counter clock-wise seen from origin
		return dot(cross(v1 - v0, v1 - origin), v2 - origin);
	}

	MATHX_API inline vec4 transformdiv(mat4 const& matrix, vec4 const& vector)
	{
		auto r = matrix * vector;
		r /= r.w;
		return r;
	}

	MATHX_API inline vec2 viewportCoords(ivec2 screenPos, ivec2 screenDim)
	{
		return (vec2(screenPos) + 0.5f) / vec2(screenDim) * 2.0f - 1.0f;
	}
	MATHX_API inline ray<vec3> rayFromVPI(vec2 viewportCoords, mat4 const& viewProjInverse)
	{
		ray<vec3> ray;
		auto rayBase = vec3( transformdiv( viewProjInverse, vec4(viewportCoords, -1.25f, 1.0f) ) );
		ray.o = vec3( transformdiv( viewProjInverse, vec4(viewportCoords, -1.0f, 1.0f) ) );
		ray.d = normalize(ray.o - rayBase);
		return ray;
	}
	MATHX_API inline ray<vec3> rayFromVPInrmZ(vec2 viewportCoords, mat4 const& viewProjInverse, vec3 const& viewDir)
	{
		auto ray = rayFromVPI(viewportCoords, viewProjInverse);
		ray.d /= dot(ray.d, viewDir);
		return ray;
	}

	MATHX_API inline vec3 fromHSV(float hue, float saturation, float value, bool toLinearSpace = false)
	{
		float hue6 = hue * 6.0f;
		float minValue = 1.0f - saturation;

		vec3 color;
		color.r = mix(minValue, 1.0f, clamp(2.0f - abs(hue6 < 3.0f ? hue6 : hue6 - 6.0f), 0.0f, 1.0f));
		color.g = mix(minValue, 1.0f, clamp(2.0f - abs(hue6 - 2.0f), 0.0f, 1.0f));
		color.b = mix(minValue, 1.0f, clamp(2.0f - abs(hue6 - 4.0f), 0.0f, 1.0f));

		// HSV RGB looks nice w/ gamma 2.2
		// Make color appear approximately the same when applied in linear space
		if (toLinearSpace)
			color *= color;

		color *= value;

		return color;
	}

	MATHX_API inline vec3 linFromHSV(float hue, float saturation, float value)
	{
		return fromHSV(hue, saturation, value, true);
	}
	
	MATHX_API inline vec3 toHSV(vec3 const& rgb, bool fromLinearSpace = false)
	{
		vec3 hsv(0.0f);
		hsv.z = compMax(rgb);
		if (hsv.z > 0.0f)
		{
			vec3 nrgb = rgb / hsv.z;
			if (fromLinearSpace)
				nrgb = sqrt(nrgb);

			hsv.y = 1.0f - compMin(nrgb);

			float hueBase;
			float hueOffset;
			if (nrgb.x >= nrgb.y && nrgb.x >= nrgb.z) {
				hueOffset = nrgb.y - nrgb.z;
				hueBase = (hueOffset < 0.0f) ? 6.0f : 0.0f;
			} else if (nrgb.y >= nrgb.x && nrgb.y > nrgb.z) {
				hueOffset = nrgb.z - nrgb.x;
				hueBase = 2.0f;
			} else { // if (nrgb.z >= nrgb.x && nrgb.z > nrgb.y)
				hueOffset = nrgb.x - nrgb.y;
				hueBase = 4.0f;
			}
			// Prevent div by zero when sat == 0!
			if (hueOffset != 0.0f) hueOffset /= hsv.y;
			hsv.x = (hueBase + hueOffset) / 6.0f;
		}

		return hsv;
	}

	template <class Uniform, size_t N>
	struct rand_box
	{
		typedef vec<typename Uniform::result_type, N> result_type;
		Uniform c[N];
		MATHX_API rand_box() { }
		MATHX_API rand_box(Uniform u)
		{	for (size_t i = 0; i < N; ++i) c[i] = u; }
		template <class E>
		MATHX_API result_type operator ()(E& e) const
		{
			result_type v;
			for (size_t i = 0; i < N; ++i)
				v.c[i] = c[i](e);
			return v;
		}
	};

	template <class T> MATHX_API inline T mipCount(T res) { T count(1); for (auto m = res; m > T(1); m /= T(2)) ++count; return count; }

	template <class T> MATHX_API inline typename std::enable_if<std::is_fundamental<T>::value, T>::type signNZ(T v) { return (v < T(0)) ? T(-1) : T(1); }
	template <class T> MATHX_API inline glm::vec<T, 2> signNZ(glm::pod_vec<T, 2> v) { return glm::vec<T, 2>(signNZ(v.x), signNZ(v.y)); }
	template <class T> MATHX_API inline glm::vec<T, 3> signNZ(glm::pod_vec<T, 3> v) { return glm::vec<T, 3>(signNZ(v.x), signNZ(v.y), signNZ(v.z)); }
	template <class T> MATHX_API inline glm::vec<T, 4> signNZ(glm::pod_vec<T, 4> v) { return glm::vec<T, 4>(signNZ(v.x), signNZ(v.y), signNZ(v.z), signNZ(v.w)); }

	template <class T> MATHX_API inline typename std::enable_if<std::is_fundamental<T>::value, T>::type nextPO2(T res) { T po2(1); while (po2 < res) po2 *= T(2); return po2; }
	template <class T> MATHX_API inline glm::vec<T, 2> nextPO2(glm::pod_vec<T, 2> res) { return glm::vec<T, 2>(nextPO2(res.x), nextPO2(res.y)); }
	template <class T> MATHX_API inline glm::vec<T, 3> nextPO2(glm::pod_vec<T, 3> res) { return glm::vec<T, 3>(nextPO2(res.x), nextPO2(res.y), nextPO2(res.z)); }
	template <class T> MATHX_API inline glm::vec<T, 4> nextPO2(glm::pod_vec<T, 4> res) { return glm::vec<T, 4>(nextPO2(res.x), nextPO2(res.y), nextPO2(res.z), nextPO2(res.w)); }
	
	template <class T>
	MATHX_API inline T ceil_div(T x, T d)
	{
		return (x + d - T(1)) / d;
	}
	template <class T>
	MATHX_API inline T ceil_mul(T x, T d)
	{
		auto r = x % d;
		return (r == 0) ? x : x + d - r;
	}
	
#ifndef MATHX_MINIMAL
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::vec<Comp, 1> &v)
	{
		stream >> v.x;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::vec<Comp, 2> &v)
	{
		stream >> v.x;
		stream >> v.y;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::vec<Comp, 3> &v)
	{
		stream >> v.x;
		stream >> v.y;
		stream >> v.z;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::vec<Comp, 4> &v)
	{
		stream >> v.x;
		stream >> v.y;
		stream >> v.z;
		stream >> v.w;
		return stream;
	}

	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::vec<Comp, 1> &v)
	{
		stream << v.x;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::vec<Comp, 2> &v)
	{
		stream << v.x << ' ';
		stream << v.y;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::vec<Comp, 3> &v)
	{
		stream << v.x << ' ';
		stream << v.y << ' ';
		stream << v.z;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::vec<Comp, 4> &v)
	{
		stream << v.x << ' ';
		stream << v.y << ' ';
		stream << v.z << ' ';
		stream << v.w;
		return stream;
	}
#endif

	/// Puts a zero bit in-between each of the lower 16 bits of the given value.
	MATHX_API inline unsigned bitsep1(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0xffff;                     // x = ---- ---- ---- ---- fedc ba98 7654 3210
		x = (x ^ (x << 8)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
		x = (x ^ (x << 4)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
		x = (x ^ (x << 2)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
		x = (x ^ (x << 1)) & 0x55555555; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
		return x;
	}

	/// Puts two zero bits in-between each of the lower 10 bits of the given value.
	MATHX_API inline unsigned bitsep2(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x000003ff;                  // x = ---- ---- ---- ---- ---- --98 7654 3210
		x = (x ^ (x << 16)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
		x = (x ^ (x <<  8)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
		x = (x ^ (x <<  4)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
		x = (x ^ (x <<  2)) & 0x09249249; // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
		return x;
	}

	/// Inverse of bitsep1.
	MATHX_API inline unsigned bitcomp1(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x55555555;                  // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
		x = (x ^ (x >> 1)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
		x = (x ^ (x >> 2)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
		x = (x ^ (x >> 4)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
		x = (x ^ (x >> 8)) & 0x0000ffff; // x = ---- ---- ---- ---- fedc ba98 7654 3210
		return x;
	}

	/// Inverse of bitsep2.
	MATHX_API inline unsigned bitcomp2(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x09249249;                  // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
		x = (x ^ (x >>  2)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
		x = (x ^ (x >>  4)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
		x = (x ^ (x >>  8)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
		x = (x ^ (x >> 16)) & 0x000003ff; // x = ---- ---- ---- ---- ---- --98 7654 3210
		return x;
	}

	/// Morton code for 2 dimensions.
	MATHX_API inline unsigned bitzip(const glm::uvec2 &v)
	{
		return (bitsep1(v[1]) << 1) + bitsep1(v[0]);
	}

	/// Morton code for 3 dimensions.
	MATHX_API inline unsigned bitzip(const glm::uvec3 &v)
	{
		return (bitsep2(v[2]) << 2) + (bitsep2(v[1]) << 1) + bitsep2(v[0]);
	}

	/// 2 dimensions from morton code.
	MATHX_API inline glm::uvec2 bitunzip2(unsigned c)
	{
		return glm::uvec2( bitcomp1(c), bitcomp1(c >> 1) );
	}

	/// 3 dimensions from morton code.
	MATHX_API inline glm::uvec3 bitunzip3(unsigned c)
	{
		return glm::uvec3( bitcomp2(c), bitcomp2(c >> 1), bitcomp2(c >> 2) );
	}

} // namespace

namespace math = sml;
