#pragma once

#define GLM_SWIZZLE
#define GLM_ADL_FRIENDLY
#define GLM_FORCE_CXX11

#include <glm/glm.hpp>

#ifndef MATHX_MINIMAL
	#include <glm/ext.hpp>
	#include <iosfwd>
#endif

namespace glm
{
	template <class T, size_t N>
	struct pod_vec { T c[N]; };

	template <class Uniform, size_t N>
	struct rand_box
	{
		typedef pod_vec<typename Uniform::result_type, N> result_type;
		Uniform c[N];
		rand_box() { }
		rand_box(Uniform u) {
			for (size_t i = 0; i < N; ++i) c[i] = u; }
		template <class E>
		result_type operator ()(E& e) const
		{
			result_type v;
			for (size_t i = 0; i < N; ++i)
				v.c[i] = c[i](e);
			return v;
		}
	};

	template <class T> inline pod_vec<T, 2> to_pod(glm::detail::tvec2<T> const& v) { return (pod_vec<T, 2> const&) v; }
	template <class T> inline pod_vec<T, 3> to_pod(glm::detail::tvec3<T> const& v) { return (pod_vec<T, 3> const&) v; }
	template <class T> inline pod_vec<T, 4> to_pod(glm::detail::tvec4<T> const& v) { return (pod_vec<T, 4> const&) v; }

	template <class T> inline glm::detail::tvec2<T> to_vec(pod_vec<T, 2> const& v) { return (glm::detail::tvec2<T> const&) v; }
	template <class T> inline glm::detail::tvec3<T> to_vec(pod_vec<T, 3> const& v) { return (glm::detail::tvec3<T> const&) v; }
	template <class T> inline glm::detail::tvec4<T> to_vec(pod_vec<T, 4> const& v) { return (glm::detail::tvec4<T> const&) v; }

	template <class T> inline T mipCount(T res) { T count(1); for (auto m = res; m > T(1); m /= T(2)) ++count; return count; }
	
	template <class T>
	inline T ceil_div(T x, T d)
	{
		return (x + d - T(1)) / d;
	}
	template <class T>
	inline T ceil_mul(T x, T d)
	{
		auto r = x % d;
		return (r == 0) ? x : x + d - r;
	}

#ifndef MATHX_MINIMAL
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::detail::tvec1<Comp> &v)
	{
		stream >> v.x;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::detail::tvec2<Comp> &v)
	{
		stream >> v.x;
		stream >> v.y;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::detail::tvec3<Comp> &v)
	{
		stream >> v.x;
		stream >> v.y;
		stream >> v.z;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::detail::tvec4<Comp> &v)
	{
		stream >> v.x;
		stream >> v.y;
		stream >> v.z;
		stream >> v.w;
		return stream;
	}

	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::detail::tvec1<Comp> &v)
	{
		stream << v.x;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::detail::tvec2<Comp> &v)
	{
		stream << v.x << ' ';
		stream << v.y;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::detail::tvec3<Comp> &v)
	{
		stream << v.x << ' ';
		stream << v.y << ' ';
		stream << v.z;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::detail::tvec4<Comp> &v)
	{
		stream << v.x << ' ';
		stream << v.y << ' ';
		stream << v.z << ' ';
		stream << v.w;
		return stream;
	}
#endif
	
	/// Puts a zero bit in-between each of the lower 16 bits of the given value.
	inline unsigned bitsep1(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0xffff;                     // x = ---- ---- ---- ---- fedc ba98 7654 3210
		x = (x ^ (x << 8)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
		x = (x ^ (x << 4)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
		x = (x ^ (x << 2)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
		x = (x ^ (x << 1)) & 0x55555555; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
		return x;
	}

	/// Puts two zero bits in-between each of the lower 10 bits of the given value.
	inline unsigned bitsep2(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x000003ff;                  // x = ---- ---- ---- ---- ---- --98 7654 3210
		x = (x ^ (x << 16)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
		x = (x ^ (x <<  8)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
		x = (x ^ (x <<  4)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
		x = (x ^ (x <<  2)) & 0x09249249; // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
		return x;
	}

	/// Inverse of bitsep1.
	inline unsigned bitcomp1(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x55555555;                  // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
		x = (x ^ (x >> 1)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
		x = (x ^ (x >> 2)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
		x = (x ^ (x >> 4)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
		x = (x ^ (x >> 8)) & 0x0000ffff; // x = ---- ---- ---- ---- fedc ba98 7654 3210
		return x;
	}

	/// Inverse of bitsep2.
	inline unsigned bitcomp2(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x09249249;                  // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
		x = (x ^ (x >>  2)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
		x = (x ^ (x >>  4)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
		x = (x ^ (x >>  8)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
		x = (x ^ (x >> 16)) & 0x000003ff; // x = ---- ---- ---- ---- ---- --98 7654 3210
		return x;
	}

	/// Morton code for 2 dimensions.
	inline unsigned bitzip(const glm::uvec2 &v)
	{
		return (bitsep1(v[1]) << 1) + bitsep1(v[0]);
	}

	/// Morton code for 3 dimensions.
	inline unsigned bitzip(const glm::uvec3 &v)
	{
		return (bitsep2(v[2]) << 2) + (bitsep2(v[1]) << 1) + bitsep2(v[0]);
	}

	/// 2 dimensions from morton code.
	inline glm::uvec2 bitunzip2(unsigned c)
	{
		return glm::uvec2( bitcomp1(c), bitcomp1(c >> 1) );
	}

	/// 3 dimensions from morton code.
	inline glm::uvec3 bitunzip3(unsigned c)
	{
		return glm::uvec3( bitcomp2(c), bitcomp2(c >> 1), bitcomp2(c >> 2) );
	}

} // namespace