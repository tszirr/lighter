#pragma once

#define GLM_SWIZZLE
#define GLM_ADL_FRIENDLY
#define GLM_FORCE_CXX11

#include <glm/glm.hpp>

#ifndef MATHX_MINIMAL
	#include <glm/ext.hpp>
	#include <iosfwd>
#endif

#ifndef MATHX_API
	#define MATHX_API
#endif

namespace glm
{
	// Vector type analysis
	template <class Vec> struct vec_type;
	template <class Component> struct vec_type< glm::detail::tvec1<Component> > { static size_t const dimension = 1; typedef Component component; };
	template <class Component> struct vec_type< glm::detail::tvec2<Component> > { static size_t const dimension = 2; typedef Component component; };
	template <class Component> struct vec_type< glm::detail::tvec3<Component> > { static size_t const dimension = 3; typedef Component component; };
	template <class Component> struct vec_type< glm::detail::tvec4<Component> > { static size_t const dimension = 4; typedef Component component; };

	// Vector type synthesis
	template <class T, size_t N> struct vec_t;
	template <class T> struct vec_t<T, 1> { typedef glm::detail::tvec1<T> type; };
	template <class T> struct vec_t<T, 2> { typedef glm::detail::tvec2<T> type; };
	template <class T> struct vec_t<T, 3> { typedef glm::detail::tvec3<T> type; };
	template <class T> struct vec_t<T, 4> { typedef glm::detail::tvec4<T> type; };

	template <class T, size_t N> struct vec;
	// POD vector (no default initialization -> aggregate / value initialization)
	template <class T, size_t N>
	struct pod_vec
	{
		T c[N];

		MATHX_API typename vec_t<T, N>::type get() const { return reinterpret_cast<typename vec_t<T, N>::type const&>(*this); }
		MATHX_API operator typename vec_t<T, N>::type() const { return reinterpret_cast<typename vec_t<T, N>::type const&>(*this); }

		MATHX_API operator vec<T, N>&();
		MATHX_API operator vec<T, N> const&() const;
	};
	template <class T, size_t N> struct vec_type< pod_vec<T, N> > { static size_t const dimension = N; typedef T component; };

	// vector (no-op default initialization)
	template <class T, size_t N>
	struct vec : pod_vec<T, N>
	{
		MATHX_API vec() { }
		MATHX_API vec(pod_vec<T, N> const& v) : pod_vec<T, N>(v) { }
		template <class Vec> 
		MATHX_API vec(Vec const& v,
			typename std::enable_if<std::is_same<typename vec_type<Vec>::component, T>::value && vec_type<Vec>::dimension == N>::type* = nullptr)
			 : pod_vec<T, N>( reinterpret_cast<pod_vec<T, N> const&>(v) ) { }

		MATHX_API vec& operator =(pod_vec<T, N> const& v)
		{
			pod_vec<T, N>::operator =(v);
			return *this;
		}
	};
	template <class T, size_t N> struct vec_type< vec<T, N> > { static size_t const dimension = N; typedef T component; };
	
	template <class T, size_t N>
	inline MATHX_API pod_vec<T, N>::operator vec<T, N>&() { return static_cast<vec<T, N>&>(*this); }
	template <class T, size_t N>
	inline MATHX_API pod_vec<T, N>::operator vec<T, N> const&() const { return static_cast<vec<T, N> const&>(*this); }

	template <class Vec> MATHX_API inline vec<typename vec_type<Vec>::component, vec_type<Vec>::dimension> to_pod(Vec const& v)
	{
		return reinterpret_cast<vec<typename vec_type<Vec>::component, vec_type<Vec>::dimension> const&>(v);
	}
	template <class T, size_t N>
	inline MATHX_API typename vec_t<T, N>::type to_vec(pod_vec<T, N> const& v)
	{
		return reinterpret_cast<typename vec_t<T, N>::type const&>(v);
	}

	// POD AABB (no default initialization)
	template <class Vec>
	struct aabb { Vec min, max; };

	// POD ray (no default initialization)
	template <class Vec>
	struct ray { Vec o, d; };

	// Utilities
	template <class Vec>
	MATHX_API inline bool in_aabb(Vec const& p, Vec const& min, Vec const& max)
	{
		return all(lessThanEqual(min, p)) && all(lessThanEqual(p, max));
	}
	template <class Vec>
	MATHX_API inline bool in_aabb(Vec const& p, aabb<Vec> const& box)
	{
		return in_aabb(p, box.min, box.max);
	}
	
	MATHX_API inline float triangle_sign(glm::vec3 const& v0, glm::vec3 const& v1, glm::vec3 const& v2, glm::vec3 const& origin)
	{
		// > 0 if counter clock-wise seen from origin
		return dot(cross(v1 - v0, v1 - origin), v2 - origin);
	}

	MATHX_API inline vec4 transformdiv(mat4 const& matrix, vec4 const& vector)
	{
		auto r = matrix * vector;
		r /= r.w;
		return r;
	}

	MATHX_API inline vec2 viewportCoords(ivec2 screenPos, ivec2 screenDim)
	{
		return (vec2(screenPos) + 0.5f) / vec2(screenDim) * 2.0f - 1.0f;
	}
	MATHX_API inline ray<vec3> rayFromVPI(vec2 viewportCoords, mat4 const& viewProjInverse)
	{
		ray<vec3> ray;
		auto rayBase = vec3( transformdiv( viewProjInverse, vec4(viewportCoords, -1.25f, 1.0f) ) );
		ray.o = vec3( transformdiv( viewProjInverse, vec4(viewportCoords, -1.0f, 1.0f) ) );
		ray.d = normalize(ray.o - rayBase);
		return ray;
	}
	MATHX_API inline ray<vec3> rayFromVPInrmZ(vec2 viewportCoords, mat4 const& viewProjInverse, vec3 const& viewDir)
	{
		auto ray = rayFromVPI(viewportCoords, viewProjInverse);
		ray.d /= dot(ray.d, viewDir);
		return ray;
	}

	template <class Uniform, size_t N>
	struct rand_box
	{
		typedef vec<typename Uniform::result_type, N> result_type;
		Uniform c[N];
		MATHX_API rand_box() { }
		MATHX_API rand_box(Uniform u) {
			for (size_t i = 0; i < N; ++i) c[i] = u; }
		template <class E>
		MATHX_API result_type operator ()(E& e) const
		{
			result_type v;
			for (size_t i = 0; i < N; ++i)
				v.c[i] = c[i](e);
			return v;
		}
	};

	template <class T> MATHX_API inline T mipCount(T res) { T count(1); for (auto m = res; m > T(1); m /= T(2)) ++count; return count; }

	template <class T> MATHX_API inline T signNZ(T v) { return (v < T(0)) ? T(-1) : T(1); }
	template <class T> MATHX_API inline glm::tvec2<T> signNZ(glm::tvec2<T> v) { return glm::tvec2<T>(signNZ(v.x), signNZ(v.y)); }
	template <class T> MATHX_API inline glm::tvec3<T> signNZ(glm::tvec3<T> v) { return glm::tvec3<T>(signNZ(v.x), signNZ(v.y), signNZ(v.z)); }
	template <class T> MATHX_API inline glm::tvec4<T> signNZ(glm::tvec4<T> v) { return glm::tvec4<T>(signNZ(v.x), signNZ(v.y), signNZ(v.z), signNZ(v.w)); }

	template <class T> MATHX_API inline T nextPO2(T res) { T po2(1); while (po2 < res) po2 *= T(2); return po2; }
	template <class T> MATHX_API inline glm::tvec2<T> nextPO2(glm::tvec2<T> res) { return glm::tvec2<T>(nextPO2(res.x), nextPO2(res.y)); }
	template <class T> MATHX_API inline glm::tvec3<T> nextPO2(glm::tvec3<T> res) { return glm::tvec3<T>(nextPO2(res.x), nextPO2(res.y), nextPO2(res.z)); }
	template <class T> MATHX_API inline glm::tvec4<T> nextPO2(glm::tvec4<T> res) { return glm::tvec4<T>(nextPO2(res.x), nextPO2(res.y), nextPO2(res.z), nextPO2(res.w)); }
	
	template <class T>
	MATHX_API inline T ceil_div(T x, T d)
	{
		return (x + d - T(1)) / d;
	}
	template <class T>
	MATHX_API inline T ceil_mul(T x, T d)
	{
		auto r = x % d;
		return (r == 0) ? x : x + d - r;
	}

#ifndef MATHX_MINIMAL
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::detail::tvec1<Comp> &v)
	{
		stream >> v.x;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::detail::tvec2<Comp> &v)
	{
		stream >> v.x;
		stream >> v.y;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::detail::tvec3<Comp> &v)
	{
		stream >> v.x;
		stream >> v.y;
		stream >> v.z;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_istream<Char, Traits>& operator >>(std::basic_istream<Char, Traits> &stream, glm::detail::tvec4<Comp> &v)
	{
		stream >> v.x;
		stream >> v.y;
		stream >> v.z;
		stream >> v.w;
		return stream;
	}

	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::detail::tvec1<Comp> &v)
	{
		stream << v.x;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::detail::tvec2<Comp> &v)
	{
		stream << v.x << ' ';
		stream << v.y;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::detail::tvec3<Comp> &v)
	{
		stream << v.x << ' ';
		stream << v.y << ' ';
		stream << v.z;
		return stream;
	}
	template <class Char, class Traits, class Comp>
	std::basic_ostream<Char, Traits>& operator <<(std::basic_ostream<Char, Traits> &stream, glm::detail::tvec4<Comp> &v)
	{
		stream << v.x << ' ';
		stream << v.y << ' ';
		stream << v.z << ' ';
		stream << v.w;
		return stream;
	}
#endif
	
	/// Puts a zero bit in-between each of the lower 16 bits of the given value.
	MATHX_API inline unsigned bitsep1(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0xffff;                     // x = ---- ---- ---- ---- fedc ba98 7654 3210
		x = (x ^ (x << 8)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
		x = (x ^ (x << 4)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
		x = (x ^ (x << 2)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
		x = (x ^ (x << 1)) & 0x55555555; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
		return x;
	}

	/// Puts two zero bits in-between each of the lower 10 bits of the given value.
	MATHX_API inline unsigned bitsep2(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x000003ff;                  // x = ---- ---- ---- ---- ---- --98 7654 3210
		x = (x ^ (x << 16)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
		x = (x ^ (x <<  8)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
		x = (x ^ (x <<  4)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
		x = (x ^ (x <<  2)) & 0x09249249; // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
		return x;
	}

	/// Inverse of bitsep1.
	MATHX_API inline unsigned bitcomp1(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x55555555;                  // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
		x = (x ^ (x >> 1)) & 0x33333333; // x = --fe --dc --ba --98 --76 --54 --32 --10
		x = (x ^ (x >> 2)) & 0x0f0f0f0f; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
		x = (x ^ (x >> 4)) & 0x00ff00ff; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
		x = (x ^ (x >> 8)) & 0x0000ffff; // x = ---- ---- ---- ---- fedc ba98 7654 3210
		return x;
	}

	/// Inverse of bitsep2.
	MATHX_API inline unsigned bitcomp2(unsigned x)
	{
		// http://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
		x &= 0x09249249;                  // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0
		x = (x ^ (x >>  2)) & 0x030c30c3; // x = ---- --98 ---- 76-- --54 ---- 32-- --10
		x = (x ^ (x >>  4)) & 0x0300f00f; // x = ---- --98 ---- ---- 7654 ---- ---- 3210
		x = (x ^ (x >>  8)) & 0xff0000ff; // x = ---- --98 ---- ---- ---- ---- 7654 3210
		x = (x ^ (x >> 16)) & 0x000003ff; // x = ---- ---- ---- ---- ---- --98 7654 3210
		return x;
	}

	/// Morton code for 2 dimensions.
	MATHX_API inline unsigned bitzip(const glm::uvec2 &v)
	{
		return (bitsep1(v[1]) << 1) + bitsep1(v[0]);
	}

	/// Morton code for 3 dimensions.
	MATHX_API inline unsigned bitzip(const glm::uvec3 &v)
	{
		return (bitsep2(v[2]) << 2) + (bitsep2(v[1]) << 1) + bitsep2(v[0]);
	}

	/// 2 dimensions from morton code.
	MATHX_API inline glm::uvec2 bitunzip2(unsigned c)
	{
		return glm::uvec2( bitcomp1(c), bitcomp1(c >> 1) );
	}

	/// 3 dimensions from morton code.
	MATHX_API inline glm::uvec3 bitunzip3(unsigned c)
	{
		return glm::uvec3( bitcomp2(c), bitcomp2(c >> 1), bitcomp2(c >> 2) );
	}

} // namespace

namespace math = glm;
