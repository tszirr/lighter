#pragma once

#include <cuda.h>
#ifdef __CUDA_ARCH__ 
	#include <cuda_runtime.h>
#else
	#include <host_defines.h>
	#include <builtin_types.h>
#endif

#include "mathx"

namespace cudax
{

template <class T>
inline __host__ __device__ T* asRuntimePtr(CUdeviceptr ptr)
{
	return reinterpret_cast<T*>( static_cast<uintptr_t>(ptr) );
}

template <class T>
inline __host__ __device__ CUdeviceptr asDriverPtr(T* ptr)
{
	return static_cast<CUdeviceptr>( reinterpret_cast<uintptr_t>(ptr) );
}

typedef glm::tvec2<unsigned short> hbvec2;
typedef glm::tvec3<unsigned short> hbvec3;
typedef glm::tvec4<unsigned short> hbvec4;

template <class T> struct CudaToGlm;
template <> struct CudaToGlm<float1> { typedef glm::mediump_float Type; };
template <> struct CudaToGlm<float2> { typedef glm::vec2 Type; };
template <> struct CudaToGlm<float3> { typedef glm::vec3 Type; };
template <> struct CudaToGlm<float4> { typedef glm::vec4 Type; };

template <> struct CudaToGlm<int1> { typedef glm::mediump_int Type; };
template <> struct CudaToGlm<int2> { typedef glm::ivec2 Type; };
template <> struct CudaToGlm<int3> { typedef glm::ivec3 Type; };
template <> struct CudaToGlm<int4> { typedef glm::ivec4 Type; };

template <> struct CudaToGlm<ushort1> { typedef unsigned short Type; };
template <> struct CudaToGlm<ushort2> { typedef hbvec2 Type; };
template <> struct CudaToGlm<ushort3> { typedef hbvec3 Type; };
template <> struct CudaToGlm<ushort4> { typedef hbvec4 Type; };

template <> struct CudaToGlm<uint1> { typedef glm::mediump_uint Type; };
template <> struct CudaToGlm<uint2> { typedef glm::uvec2 Type; };
template <> struct CudaToGlm<uint3> { typedef glm::uvec3 Type; };
template <> struct CudaToGlm<uint4> { typedef glm::uvec4 Type; };

template <class T>
inline __host__ __device__ typename CudaToGlm<T>::Type toGlm(T const& cuda)
{
	return reinterpret_cast<typename CudaToGlm<T>::Type const&>(cuda);
}

template <class T> struct GlmToCuda;
template <> struct GlmToCuda<glm::mediump_float> { typedef float1 Type; };
template <> struct GlmToCuda<glm::vec2> { typedef float2 Type; };
template <> struct GlmToCuda<glm::vec3> { typedef float3 Type; };
template <> struct GlmToCuda<glm::vec4> { typedef float4 Type; };

template <> struct GlmToCuda<glm::mediump_int> { typedef int1 Type; };
template <> struct GlmToCuda<glm::ivec2> { typedef int2 Type; };
template <> struct GlmToCuda<glm::ivec3> { typedef int3 Type; };
template <> struct GlmToCuda<glm::ivec4> { typedef int4 Type; };

template <> struct GlmToCuda<unsigned short> { typedef ushort1 Type; };
template <> struct GlmToCuda<glm::tvec2<unsigned short>> { typedef ushort2 Type; };
template <> struct GlmToCuda<glm::tvec3<unsigned short>> { typedef ushort3 Type; };
template <> struct GlmToCuda<glm::tvec4<unsigned short>> { typedef ushort4 Type; };

template <> struct GlmToCuda<glm::mediump_uint> { typedef uint1 Type; };
template <> struct GlmToCuda<glm::uvec2> { typedef uint2 Type; };
template <> struct GlmToCuda<glm::uvec3> { typedef uint3 Type; };
template <> struct GlmToCuda<glm::uvec4> { typedef uint4 Type; };

template <class T>
inline __host__ __device__ typename GlmToCuda<T>::Type toCuda(T const& glm)
{
	return reinterpret_cast<typename GlmToCuda<T>::Type const&>(glm);
}

#ifdef __CUDA_ARCH__ 

template <class Type, class SurfaceType>
__device__ inline Type surf2Dread(SurfaceType surf, int2 coord)
{
	Type x;
	surf2Dread(&x, surf, coord.x * sizeof(Type), coord.y);
	return x;
}
template <class Type, class SurfaceType>
__device__ inline Type surf2Dread(SurfaceType surf, glm::ivec2 coord)
{
	return toGlm( surf2Dread<typename GlmToCuda<Type>::Type>(surf, toCuda(coord)) );
}

template <class Type, class SurfaceType>
__device__ inline void surf2Dwrite(Type const& x, SurfaceType surf, int2 coord)
{
	surf2Dwrite(x, surf, coord.x * sizeof(Type), coord.y);
}
template <class Type, class SurfaceType>
__device__ inline void surf2Dwrite(Type const& x, SurfaceType surf, glm::ivec2 coord)
{
	surf2Dwrite(toCuda(x), surf, toCuda(coord));
}

template <class Type, class SurfaceType>
__device__ inline Type surf3Dread(SurfaceType surf, int3 coord)
{
	Type x;
	surf3Dread(&x, surf, coord.x * sizeof(Type), coord.y, coord.z);
	return x;
}
template <class Type, class SurfaceType>
__device__ inline Type surf3Dread(SurfaceType surf, glm::ivec3 coord)
{
	return toGlm( surf3Dread<typename GlmToCuda<Type>::Type>(surf, toCuda(coord)) );
}

template <class Type, class SurfaceType>
__device__ inline void surf3Dwrite(Type const& x, SurfaceType surf, int3 coord)
{
	surf3Dwrite(x, surf, coord.x * sizeof(Type), coord.y, coord.z);
}
template <class Type, class SurfaceType>
__device__ inline void surf3Dwrite(Type const& x, SurfaceType surf, glm::ivec3 coord)
{
	surf3Dwrite(toCuda(x), surf, toCuda(coord));
}

__device__ inline hbvec3 toHalf(glm::vec3 const& v)
{
	return hbvec3( __float2half_rn(v.x), __float2half_rn(v.y), __float2half_rn(v.z) );
}

__device__ inline hbvec4 toHalf(glm::vec4 const& v)
{
	return hbvec4( __float2half_rn(v.x), __float2half_rn(v.y), __float2half_rn(v.z), __float2half_rn(v.w) );
}

__device__ inline glm::vec3 fromHalf(hbvec3 const& v)
{
	return glm::vec3( __half2float(v.x), __half2float(v.y), __half2float(v.z) );
}

__device__ inline glm::vec4 fromHalf(hbvec4 const& v)
{
	return glm::vec4( __half2float(v.x), __half2float(v.y), __half2float(v.z), __half2float(v.w) );
}

#endif

} // namespace