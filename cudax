#pragma once

#include <cuda.h>
#ifdef __CUDACC__ 
	#include <cuda_runtime.h>
#else
	#include <host_defines.h>
	#include <builtin_types.h>
#endif

#include "mathx"

namespace cudax
{

template <class T>
inline __host__ __device__ T* asRuntimePtr(CUdeviceptr ptr)
{
	return reinterpret_cast<T*>( static_cast<uintptr_t>(ptr) );
}

template <class T>
inline __host__ __device__ CUdeviceptr asDriverPtr(T* ptr)
{
	return static_cast<CUdeviceptr>( reinterpret_cast<uintptr_t>(ptr) );
}

template <class T, class X>
inline __host__ __device__ T const& as_(X const& x)
{
	static_assert(sizeof(T) == sizeof(X), "size mismatch");
	union U { X x; T t; char c[sizeof(T)]; };
	return reinterpret_cast<U const&>(x).t;
}

template <class T, size_t S>
inline __device__ __host__ char (&arraylen_helper(T const volatile (&a)[S]))[S];
#ifndef arraylen
	#define arraylen(x) sizeof(::cudax::arraylen_helper(x))
#endif

typedef glm::tvec2<unsigned short> hbvec2;
typedef glm::tvec3<unsigned short> hbvec3;
typedef glm::tvec4<unsigned short> hbvec4;

template <class T> struct CudaToGlm;
template <> struct CudaToGlm<float> { typedef glm::mediump_float Type; };
template <> struct CudaToGlm<float1> { typedef glm::mediump_float Type; };
template <> struct CudaToGlm<float2> { typedef glm::vec2 Type; };
template <> struct CudaToGlm<float3> { typedef glm::vec3 Type; };
template <> struct CudaToGlm<float4> { typedef glm::vec4 Type; };

template <> struct CudaToGlm<int> { typedef glm::mediump_int Type; };
template <> struct CudaToGlm<int1> { typedef glm::mediump_int Type; };
template <> struct CudaToGlm<int2> { typedef glm::ivec2 Type; };
template <> struct CudaToGlm<int3> { typedef glm::ivec3 Type; };
template <> struct CudaToGlm<int4> { typedef glm::ivec4 Type; };

template <> struct CudaToGlm<unsigned short> { typedef unsigned short Type; };
template <> struct CudaToGlm<ushort1> { typedef unsigned short Type; };
template <> struct CudaToGlm<ushort2> { typedef hbvec2 Type; };
template <> struct CudaToGlm<ushort3> { typedef hbvec3 Type; };
template <> struct CudaToGlm<ushort4> { typedef hbvec4 Type; };

template <> struct CudaToGlm<unsigned int> { typedef glm::mediump_uint Type; };
template <> struct CudaToGlm<uint1> { typedef glm::mediump_uint Type; };
template <> struct CudaToGlm<uint2> { typedef glm::uvec2 Type; };
template <> struct CudaToGlm<uint3> { typedef glm::uvec3 Type; };
template <> struct CudaToGlm<uint4> { typedef glm::uvec4 Type; };

template <class T>
inline __host__ __device__ typename CudaToGlm<T>::Type toGlm(T const& cuda)
{
	return reinterpret_cast<typename CudaToGlm<T>::Type const&>(cuda);
}

template <class T> struct GlmToCuda;
template <> struct GlmToCuda<glm::mediump_float> { typedef float Type; };
template <> struct GlmToCuda<glm::tvec1<glm::mediump_float>> { typedef float Type; };
template <> struct GlmToCuda<glm::vec2> { typedef float2 Type; };
template <> struct GlmToCuda<glm::vec3> { typedef float3 Type; };
template <> struct GlmToCuda<glm::vec4> { typedef float4 Type; };

template <> struct GlmToCuda<glm::mediump_int> { typedef int Type; };
template <> struct GlmToCuda<glm::tvec1<glm::mediump_int>> { typedef int Type; };
template <> struct GlmToCuda<glm::ivec2> { typedef int2 Type; };
template <> struct GlmToCuda<glm::ivec3> { typedef int3 Type; };
template <> struct GlmToCuda<glm::ivec4> { typedef int4 Type; };

template <> struct GlmToCuda<unsigned short> { typedef unsigned short Type; };
template <> struct GlmToCuda<glm::tvec1<unsigned short>> { typedef unsigned short Type; };
template <> struct GlmToCuda<glm::tvec2<unsigned short>> { typedef ushort2 Type; };
template <> struct GlmToCuda<glm::tvec3<unsigned short>> { typedef ushort3 Type; };
template <> struct GlmToCuda<glm::tvec4<unsigned short>> { typedef ushort4 Type; };

template <> struct GlmToCuda<glm::mediump_uint> { typedef unsigned int Type; };
template <> struct GlmToCuda<glm::tvec1<unsigned int>> { typedef unsigned int Type; };
template <> struct GlmToCuda<glm::uvec2> { typedef uint2 Type; };
template <> struct GlmToCuda<glm::uvec3> { typedef uint3 Type; };
template <> struct GlmToCuda<glm::uvec4> { typedef uint4 Type; };

template <class T>
inline __host__ __device__ typename GlmToCuda<T>::Type toCuda(T const& glm)
{
	return reinterpret_cast<typename GlmToCuda<T>::Type const&>(glm);
}

template <class T, class U>
inline __host__ __device__ T toGlmExplicit(U const& cuda
										 , typename std::enable_if<std::is_same<typename CudaToGlm<U>::Type, typename CudaToGlm<typename GlmToCuda<T>::Type>::Type>::value>::type* enable_if_connected = nullptr)
{
	return reinterpret_cast<T const&>(cuda);
}

#ifdef __CUDACC__ 

template <class Type, class SurfaceType>
__device__ inline Type surf2Dread(SurfaceType surf, int2 coord, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	Type x;
	::surf2Dread(&x, surf, coord.x * (int) sizeof(Type), coord.y, boundaryMode);
	return x;
}
template <class Type, class SurfaceType>
__device__ inline Type surf2Dread(SurfaceType surf, glm::ivec2 coord, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	return toGlmExplicit<Type>( surf2Dread<typename GlmToCuda<Type>::Type>(surf, toCuda(coord), boundaryMode) );
}

template <class Type, class SurfaceType>
__device__ inline void surf2Dwrite(Type const& x, SurfaceType surf, int2 coord, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	::surf2Dwrite(x, surf, coord.x * (int) sizeof(Type), coord.y, boundaryMode);
}
template <class Type, class SurfaceType>
__device__ inline void surf2Dwrite(Type const& x, SurfaceType surf, glm::ivec2 coord, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	surf2Dwrite(toCuda(x), surf, toCuda(coord), boundaryMode);
}

template <class Type, class SurfaceType>
__device__ inline Type surf3Dread(SurfaceType surf, int3 coord, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	Type x;
	::surf3Dread(&x, surf, coord.x * (int) sizeof(Type), coord.y, coord.z, boundaryMode);
	return x;
}
template <class Type, class SurfaceType>
__device__ inline Type surf3Dread(SurfaceType surf, glm::ivec3 coord, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	return toGlmExplicit<Type>( surf3Dread<typename GlmToCuda<Type>::Type>(surf, toCuda(coord), boundaryMode) );
}

template <class Type, class SurfaceType>
__device__ inline void surf3Dwrite(Type const& x, SurfaceType surf, int3 coord, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	::surf3Dwrite(x, surf, coord.x * (int) sizeof(Type), coord.y, coord.z, boundaryMode);
}
template <class Type, class SurfaceType>
__device__ inline void surf3Dwrite(Type const& x, SurfaceType surf, glm::ivec3 coord, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap)
{
	surf3Dwrite(toCuda(x), surf, toCuda(coord), boundaryMode);
}

template <class Type, class Vec>
__device__ inline Type tex2D(cudaTextureObject_t surf, Vec coord, typename CudaToGlm<Vec>::Type* enable_if_cuda_vec = nullptr)
{
	return ::tex2D<Type>(surf, (float) coord.x, (float) coord.y);
}
template <class Type, class SurfaceType, class Vec>
__device__ inline Type tex2D(SurfaceType surf, Vec coord, typename CudaToGlm<Vec>::Type* enable_if_cuda_vec = nullptr)
{
	return ::tex2D(surf, (float) coord.x, (float) coord.y);
}
template <class Type, class SurfaceType, class Vec>
__device__ inline Type tex2D(SurfaceType surf, Vec coord, typename GlmToCuda<Vec>::Type* enable_if_glm_vec = nullptr)
{
	return toGlmExplicit<Type>( tex2D<typename GlmToCuda<Type>::Type>(surf, toCuda(coord)) );
}

template <class Type, class Vec>
__device__ inline Type tex3D(cudaTextureObject_t surf, Vec coord, typename CudaToGlm<Vec>::Type* enable_if_cuda_vec = nullptr)
{
	return ::tex3D<Type>(surf, (float) coord.x, (float) coord.y, (float) coord.z);
}
template <class Type, class SurfaceType, class Vec>
__device__ inline Type tex3D(SurfaceType surf, Vec coord, typename CudaToGlm<Vec>::Type* enable_if_cuda_vec = nullptr)
{
	return ::tex3D(surf, (float) coord.x, (float) coord.y, (float) coord.z);
}
template <class Type, class SurfaceType, class Vec>
__device__ inline Type tex3D(SurfaceType surf, Vec coord, typename GlmToCuda<Vec>::Type* enable_if_glm_vec = nullptr)
{
	return toGlmExplicit<Type>( tex3D<typename GlmToCuda<Type>::Type>(surf, toCuda(coord)) );
}

__device__ inline hbvec3 toHalf(glm::vec3 const& v)
{
	return hbvec3( __float2half_rn(v.x), __float2half_rn(v.y), __float2half_rn(v.z) );
}

__device__ inline hbvec4 toHalf(glm::vec4 const& v)
{
	return hbvec4( __float2half_rn(v.x), __float2half_rn(v.y), __float2half_rn(v.z), __float2half_rn(v.w) );
}

__device__ inline glm::vec3 fromHalf(hbvec3 const& v)
{
	return glm::vec3( __half2float(v.x), __half2float(v.y), __half2float(v.z) );
}

__device__ inline glm::vec4 fromHalf(hbvec4 const& v)
{
	return glm::vec4( __half2float(v.x), __half2float(v.y), __half2float(v.z), __half2float(v.w) );
}

__device__ inline float fast_sqrt(float x)
{
	float r;
	asm("sqrt.approx.f32 %0, %1;" : "=f"(r) : "f"(x));
	return r;
}

__device__ inline float fast_rsqrt(float x)
{
	float r;
	asm("rsqrt.approx.f32 %0, %1;" : "=f"(r) : "f"(x));
	return r;
}

__device__ inline float fast_rcp(float x)
{
	float r;
	asm("rcp.approx.f32 %0, %1;" : "=f"(r) : "f"(x));
	return r;
}

#endif

} // namespace
