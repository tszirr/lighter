#pragma once

#include "uii"
#include "file"
#include <vector>
#include <iostream>
#include <algorithm>

namespace ui
{

struct IniStream : ui::KeyValueStream
{
	std::ostream* out;
	std::string indent;

	IniStream(std::ostream& out)
		: out(&out)
	{ }

	void enterSection(char const* key, char const* value) override
	{
		*out << indent << '[' << key;
		if (value)
			*out << '=' << value;
		*out << std::endl;
		indent.push_back(' ');
	}
	void leaveSection(char const* key) override
	{
		indent.pop_back();
		*out << indent << "]\n";
	}
	void addItem(char const* key, char const* value) override
	{
		*out << indent << key << '=' << value << std::endl;
	}
};

template <class KeyValueNode>
struct SortedKeyValueStore : ui::KeyValueStore
{
	std::vector<KeyValueNode const*> sectionNodes;

	SortedKeyValueStore(KeyValueNode const* in)
		: sectionNodes(1, in)
	{ }

	size_t estimateItems(char const* key = nullptr) override
	{
		auto parent = sectionNodes.back();
		if (parent)
		{
			return (key)
				? parent->find_sorted_range(stdx::str_range(key)).size()
				: parent->children.size();
		}
		else
			return 0;
	}

	KeyValueNode const* findItem(char const* key, size_t offset = 0, bool* found = nullptr)
	{
		if (auto parent = sectionNodes.back())
		{
			auto matches = parent->find_sorted_range(stdx::str_range(key));
			if (offset < matches.size())
			{
				if (found) *found = true;
				return matches.first + offset;
			}
		}
		if (found) *found = false;
		return nullptr;
	}

	stdx::range<char const*> enterSection(char const* key, size_t offset = 0, bool* found = nullptr) override
	{
		auto section = findItem(key, offset, found);
		sectionNodes.push_back(section);
		return (section) ? section->value : stdx::range<char const*>();
	}
	void leaveSection() override
	{
		sectionNodes.pop_back();
	}
	stdx::range<char const*> getValue(char const* key, size_t offset = 0, bool* found = nullptr) override
	{
		auto it = findItem(key, offset, found);
		return (it) ? it->value : stdx::range<char const*>();
	}
};

template <class KeyValueNode>
SortedKeyValueStore<KeyValueNode> make_SortedKeyValueStore(KeyValueNode* kvn)
{	return SortedKeyValueStore<KeyValueNode>(kvn); }

} // namespace
