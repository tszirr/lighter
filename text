#pragma once

#include "ogl"

#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_BITMAP_H

#include "stdx"
#include "mathx"

#include <algorithm>
#include <string>
#include <vector>

#include <unordered_map>

namespace text
{

struct freetype_tag;
typedef stdx::error<freetype_tag> ft_error;

#define THROW_FREETYPE_ERROR(error, ctx) do { auto _uniqueerrorval = error; if (_uniqueerrorval != 0) throwx( ::text::ft_error(ctx) ); } while (false)

template <class Pointer, FT_Error (*Deleter)(Pointer)>
struct ft_delete
{
	typedef Pointer pointer;
	void operator ()(pointer ptr) const
	{
		if (ptr)
			(*Deleter)(ptr);
	}

	typedef std::unique_ptr< typename std::remove_pointer<Pointer>::type, ft_delete<Pointer, Deleter> > pointer_type;
	typedef stdx::unique_handle< typename std::remove_pointer<Pointer>::type, ft_delete<Pointer, Deleter> > handle_type;
};

struct FreeType : ft_delete<FT_Library, FT_Done_FreeType>::handle_type
{
	MOVE_BASE(FreeType, unique_handle)

	FreeType()
	{
		THROW_FREETYPE_ERROR(FT_Init_FreeType(rebind()), "FT_Init_FreeType");
	}
};

struct Bitmap : stdx::noncopyable, FT_Bitmap
{
	MOVE_GENERATE(Bitmap, MOVE_2, BASE, FT_Bitmap, MEMBER, lib)
	FT_Library lib;

	Bitmap(nullptr_t) { }
	Bitmap(FT_Library lib)
		: lib(lib)
	{
		FT_Bitmap_New(this);
	}
	~Bitmap()
	{
		FT_Bitmap_Done(lib, this);
	}
};

struct Face : ft_delete<FT_Face, FT_Done_Face>::handle_type
{
	MOVE_BASE(Face, unique_handle)

	Face(nullptr_t) { }
	Face(FT_Library library, char const* name, FT_UInt heightPX = 16, FT_Long faceIdx = 0)
	{
		THROW_FREETYPE_ERROR(FT_New_Face(library, name, faceIdx, rebind()), "FT_New_Face");
		if (heightPX != 0)
			size(heightPX);
	}

	void size(FT_UInt height, FT_UInt width = 0)
	{
		THROW_FREETYPE_ERROR(FT_Set_Pixel_Sizes(*this, height, width), "FT_Set_Pixel_Sizes");
	}

	FT_UInt glyph_idx(FT_ULong character) const
	{
		return FT_Get_Char_Index(*this, character);
	}

	FT_Vector kerning_delte(FT_UInt prevGlyph, FT_UInt nextGlyph) const
	{
		FT_Vector delta;
		FT_Get_Kerning(*this, prevGlyph, nextGlyph, FT_KERNING_DEFAULT, &delta);
		return delta;
	}

	FT_GlyphSlot& render_glyph(FT_UInt glyphIdx)
	{
		THROW_FREETYPE_ERROR(FT_Load_Glyph(*this, glyphIdx, FT_LOAD_DEFAULT), "FT_Load_Glyph");
		auto& glyth = get()->glyph;
		if (glyth->format != FT_GLYPH_FORMAT_BITMAP)
			THROW_FREETYPE_ERROR(FT_Render_Glyph(glyth, FT_RENDER_MODE_NORMAL), "FT_Render_Glyph");
		return glyth;
	}
};

struct BitmapCache
{
	MOVE_GENERATE(BitmapCache, MOVE_4, MEMBER, size, MEMBER, rowHeight, MEMBER, numRows, MEMBER, pixelsInRow)

	glm::uvec2 size;
	unsigned rowHeight, numRows;
	std::unique_ptr<unsigned[]> pixelsInRow;

	BitmapCache(glm::uvec2 size, unsigned rowHeight, bool adaptRowHeight = true)
		: size(size)
		, rowHeight( (adaptRowHeight) ? size.y / (size.y / rowHeight) : rowHeight )
		, numRows(size.y / rowHeight)
		, pixelsInRow(new unsigned[numRows])
	{
		clear();
	}

	glm::uvec2 add(glm::uvec2 tileSize)
	{
		glm::uvec2 tileOffset(~0);

		auto numTileRows = (tileSize.y + rowHeight - 1) / rowHeight;
		if (numTileRows <= numRows)
		{
			auto pixelsInRow = this->pixelsInRow.get();
			auto numEligibleRows = numRows - numTileRows + 1;

			unsigned optRowIdx = 0;
			unsigned optRowOffset = ~0;

			for (unsigned r = 0; r < numEligibleRows; ++r)
			{
				unsigned rowOffset = 0;
				for (unsigned rp = r; rp < r + numTileRows; ++rp)
					rowOffset = std::max(rowOffset, pixelsInRow[rp]);

				if (rowOffset < optRowOffset)
				{
					optRowOffset = rowOffset;
					optRowIdx = r;
				}
			}

			if (tileSize.x <= size.x - optRowOffset)
			{
				auto newOptRowOffset = optRowOffset + tileSize.x;
				for (unsigned rp = optRowIdx; rp < optRowIdx + numTileRows; ++rp)
					pixelsInRow[rp] = newOptRowOffset;
				tileOffset.x = optRowOffset;
				tileOffset.y = optRowIdx * rowHeight;
			}
		}

		return tileOffset;
	}

	void clear()
	{
		for (unsigned r = 0; r < numRows; ++r)
			pixelsInRow[r] = 0;
	}
};

struct TextureBitmapCache
{
	MOVE_GENERATE(TextureBitmapCache, MOVE_4, MEMBER, cache, MEMBER, pixels, MEMBER, texture, MEMBER, pixelsChanged)

	BitmapCache cache;
	std::unique_ptr<unsigned char[]> pixels;
	ogl::Texture texture;
	bool pixelsChanged;

	TextureBitmapCache(glm::uvec2 size, unsigned rowHeight)
		: cache(size, rowHeight)
		, pixels(new unsigned char[size.x * size.y * 4])
		, texture(ogl::Texture::create2D(GL_TEXTURE_2D, GL_RGBA8, size.x, size.y))
		, pixelsChanged(false)
	{
	}

	glm::uvec2 add(glm::uvec2 tileSize, unsigned char const* srcBytes, unsigned srcPitch, bool srcBGRA)
	{
		glm::uvec2 tileOffset = cache.add(tileSize);

		if (tileOffset.x != ~0)
		{
			auto destPitch = 4 * cache.size.x;
			auto destPtr = pixels.get() + 4 * tileOffset.x + tileOffset.y * destPitch;

			auto srcChannelStride = (srcBGRA) ? 1 : 0;
			auto srcAddPixelStride = (srcBGRA) ? 0 : 1;

			for (auto y = 0U; y < tileSize.y; ++y)
			{
				auto destRow = destPtr + y * destPitch;
				auto srcRow = srcBytes + y * srcPitch;

				for (auto x = 0U; x < tileSize.x; ++x)
				{
					for (auto c = 0U; c < 4U; ++c) {
						*destRow++ = *srcRow;
						srcRow += srcChannelStride;
					}
					srcRow += srcAddPixelStride;
				}
			}

			pixelsChanged = true;
		}

		return tileOffset;
	}

	void flushToTexture()
	{
		if (pixelsChanged)
		{
			texture.write(GL_TEXTURE_2D, 0, pixels.get(), GL_UNSIGNED_BYTE, GL_BGRA, cache.size.x, cache.size.y); 
			pixelsChanged = false;
		}
	}

	void clear()
	{
		cache.clear();
	}
};

struct GlyphCache
{
	struct CachedGlyph
	{
		FT_UInt glyphIdx;
		glm::uvec2 cacheOffset;
		glm::uvec2 cacheSize;
		glm::ivec2 offset;
		glm::ivec2 advance;
	};

	Bitmap auxBmp;
	TextureBitmapCache bmpCache;

	typedef std::unordered_map<FT_ULong, CachedGlyph> char_map;
	char_map cache;

	GlyphCache(FT_Library lib, TextureBitmapCache bmpCache)
		: auxBmp(lib)
		, bmpCache(std::move(bmpCache)) { }

	CachedGlyph const& get(FT_Library lib, Face& face, FT_ULong chr, bool &overflow)
	{
		overflow = false;
		auto it = cache.find(chr);
		return (it != cache.end())
			? it->second
			: add(lib, face, chr, overflow);
	}

	// todo: multiple cache bitmaps OR array?
	// todo: discard on overflow

	CachedGlyph const& add(FT_Library lib, Face& face, FT_ULong chr, bool &overflow)
	{
		overflow = false;

		auto glyphIdx = face.glyph_idx(chr);
		auto& glyph = face.render_glyph(glyphIdx);
		
		// Retrieve glyph bitmap in 8 or 32 bpp
		auto glyphBmp = &glyph->bitmap;
		if (glyph->bitmap.pixel_mode != FT_PIXEL_MODE_BGRA && glyph->bitmap.pixel_mode != FT_PIXEL_MODE_GRAY)
		{
			glyphBmp = &auxBmp;
			FT_Bitmap_Convert(lib, &glyph->bitmap, glyphBmp, 1);
		}

		// Copy glyph to bitmap cache
		glm::uvec2 glyphSize(glyph->bitmap.width, glyph->bitmap.rows);
		glm::uvec2 glyphOffset;
		while (true) {
			glyphOffset = bmpCache.add(glyphSize, glyphBmp->buffer, glyphBmp->pitch, glyph->bitmap.pixel_mode == FT_PIXEL_MODE_BGRA);
			if (glyphOffset.x != ~0) break;
			// Flush & clear on overflow
			overflow = true;
			bmpCache.flushToTexture();
			bmpCache.clear();
		}

		// Store cached glyph
		CachedGlyph cached = { glyphIdx, glyphOffset, glyphSize
			, glm::ivec2(glyph->bitmap_left, glyph->bitmap_top)
			, glm::ivec2(glyph->advance.x, glyph->advance.y) >> 6};
		return (cache[chr] = cached);
	}
};

struct TextRenderer
{
	struct QueuedChar
	{
		unsigned xy;
		unsigned atlasXY;
		unsigned wh;

		template <class T>
		static unsigned build_tuple(T x, T y)
		{
			return (unsigned) stdx::to_unsigned(x)
				| ((unsigned) stdx::to_unsigned(y) << unsigned(8 * sizeof(T)));
		}
	};

	ogl::Program* charProgram;
	ogl::VertexArrays charArrays;
	unsigned charBatchCnt, charBatchSize;
	std::unique_ptr<QueuedChar[]> charMem;
	ogl::Buffer charBuffer;
	GlyphCache glyphCache;

	TextRenderer(FT_Library lib, ogl::Program* program, unsigned charBatchSize, unsigned charHeight = 16, unsigned cacheRes = 1024)
		: charProgram(move(program))
		, charArrays()
		, charBatchCnt(0)
		, charBatchSize(charBatchSize)
		, charMem(new QueuedChar[charBatchSize])
		, charBuffer(ogl::Buffer::create(GL_ARRAY_BUFFER, charBatchSize * sizeof(QueuedChar), nullptr, GL_STATIC_DRAW))
		, glyphCache(lib, TextureBitmapCache(glm::uvec2(cacheRes), charHeight))
	{
		charArrays.bind();
		charBuffer.bind(GL_ARRAY_BUFFER);
		glVertexAttribIPointer(0, 3, GL_UNSIGNED_INT, 0, nullptr);
		glEnableVertexAttribArray(0);
		charBuffer.unbind(GL_ARRAY_BUFFER);
		charArrays.unbind();
	}

	template <class Char>
	void drawText(FT_Library lib, Face& face, glm::ivec2 textPos, Char const* chars)
	{
		glm::ivec2 charPos = textPos;
		for (auto chr = chars; *chr; ++chr)
		{
			if (*chr == '\n')
			{
				charPos.y += face->size->metrics.height >> 6;
				charPos.x = textPos.x;
				continue;
			}

			auto const& glyph = drawChar(lib, face, charPos, stdx::to_unsigned(*chr));
			charPos += glyph.advance;
			// todo: kerning
		}
	}

	GlyphCache::CachedGlyph const& drawChar(FT_Library lib, Face& face, glm::ivec2 pos, FT_ULong chr)
	{
		bool cacheOverflow;
		auto& glyph = glyphCache.get(lib, face, chr, cacheOverflow);
		
		if (cacheOverflow || charBatchCnt >= charBatchSize)
			flushText(cacheOverflow);

		QueuedChar qc = { QueuedChar::build_tuple( (short) (pos.x + glyph.offset.x), (short) (pos.y - glyph.offset.y) )
			, QueuedChar::build_tuple( (unsigned short) glyph.cacheOffset.x, (unsigned short) glyph.cacheOffset.y )
			, QueuedChar::build_tuple( (unsigned short) glyph.cacheSize.x, (unsigned short) glyph.cacheSize.y ) };
		charMem[charBatchCnt] = qc;
		++charBatchCnt;

		return glyph;
	}

	void flushText(bool renderOldGlyphCache = false)
	{
		if (charBatchCnt > 0)
		{
			charBuffer.write(GL_ARRAY_BUFFER, stdx::make_range_n(charMem.get(), charBatchCnt));
			if (!renderOldGlyphCache)
				glyphCache.bmpCache.flushToTexture();

			glyphCache.bmpCache.texture.bind(GL_TEXTURE_2D, 0);
			charArrays.bind();
			charProgram->bind();
			glDrawArrays(GL_POINTS, 0, charBatchCnt);
			
			charBatchCnt = 0;
		}
	}
};

} // namespace
