#pragma once

#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_BITMAP_H

#include "stdx"
#include "mathx"

namespace text
{

struct freetype_tag;
typedef stdx::error<freetype_tag> ft_error;

#define THROW_FREETYPE_ERROR(error, ctx) do { auto _uniqueerrorval = error; if (_uniqueerrorval != 0) throwx( ::text::ft_error(ctx) ); } while (false)

template <class Pointer, FT_Error (*Deleter)(Pointer)>
struct ft_delete
{
	typedef Pointer pointer;
	void operator ()(pointer ptr) const
	{
		if (ptr)
			(*Deleter)(ptr);
	}

	typedef std::unique_ptr< typename std::remove_pointer<Pointer>::type, ft_delete<Pointer, Deleter> > pointer_type;
	typedef stdx::unique_handle< typename std::remove_pointer<Pointer>::type, ft_delete<Pointer, Deleter> > handle_type;
};

struct FreeType : ft_delete<FT_Library, FT_Done_FreeType>::handle_type
{
	MOVE_BASE(FreeType, unique_handle)

	FreeType()
	{
		THROW_FREETYPE_ERROR(FT_Init_FreeType(rebind()), "FT_Init_FreeType");
	}
};

struct Bitmap : stdx::noncopyable, FT_Bitmap
{
	MOVE_GENERATE(Bitmap, MOVE_2, BASE, FT_Bitmap, MEMBER, lib)
	FT_Library lib;

	Bitmap(std::nullptr_t) { }
	Bitmap(FT_Library lib)
		: lib(lib)
	{
		FT_Bitmap_New(this);
	}
	~Bitmap()
	{
		FT_Bitmap_Done(lib, this);
	}
};

struct PtSize
{
	FT_UInt width, height;
	FT_UInt dpiH, dpiV;

	explicit PtSize(FT_UInt height, FT_UInt width = 0, FT_UInt dpiH = 96, FT_UInt dpiV = 0)
		: width(width), height(height), dpiH(dpiH), dpiV(dpiV) { }
};
struct PxSize
{
	FT_UInt width, height;

	explicit PxSize(FT_UInt height, FT_UInt width = 0)
		: width(width), height(height) { }
};

struct Face : ft_delete<FT_Face, FT_Done_Face>::handle_type
{
	MOVE_BASE(Face, unique_handle)

	Face(std::nullptr_t) { }
	Face(FT_Library library, char const* name, FT_Long faceIdx = 0)
	{
		THROW_FREETYPE_ERROR(FT_New_Face(library, name, faceIdx, rebind()), "FT_New_Face");
	}
	Face(FT_Library library, char const* name, PtSize size, FT_Long faceIdx = 0)
	{
		*this = Face(library, name, faceIdx);
		this->size(size);
	}
	Face(FT_Library library, char const* name, PxSize size, FT_Long faceIdx = 0)
	{
		*this = Face(library, name, faceIdx);
		this->size(size);
	}

	void size(PxSize size)
	{
		THROW_FREETYPE_ERROR(FT_Set_Pixel_Sizes(*this, size.width, size.height), "FT_Set_Pixel_Sizes");
	}

	void size(PtSize size)
	{
		THROW_FREETYPE_ERROR(FT_Set_Char_Size(*this, size.width * 64, size.height * 64, size.dpiH, size.dpiV), "FT_Set_Char_Size");
	}

	FT_UInt glyph_idx(FT_ULong character) const
	{
		return FT_Get_Char_Index(*this, character);
	}

	FT_Vector kerning_delte(FT_UInt prevGlyph, FT_UInt nextGlyph) const
	{
		FT_Vector delta;
		FT_Get_Kerning(*this, prevGlyph, nextGlyph, FT_KERNING_DEFAULT, &delta);
		return delta;
	}

	FT_GlyphSlot& render_glyph(FT_UInt glyphIdx, FT_Render_Mode renderMode = FT_RENDER_MODE_NORMAL)
	{
		auto loadFlags = FT_LOAD_COLOR | (renderMode == FT_RENDER_MODE_LCD ? FT_LOAD_TARGET_LCD : 0);
		THROW_FREETYPE_ERROR(FT_Load_Glyph(*this, glyphIdx, loadFlags), "FT_Load_Glyph");
		auto& glyth = get()->glyph;
		if (glyth->format != FT_GLYPH_FORMAT_BITMAP)
			THROW_FREETYPE_ERROR(FT_Render_Glyph(glyth, renderMode), "FT_Render_Glyph");
		return glyth;
	}
};

} // namespace
