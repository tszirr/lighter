#pragma once

#include <stdexcept>
#include <cassert>
#include <utility>
#include <type_traits>
#include <memory>
#include <cstring>

#ifdef _MSC_VER
	#pragma warning(push)
	// Decorated name length exceeded all the time by various STL containers
	#pragma warning(disable : 4503)
	// Can't do anything about methods not being inlined
	#pragma warning(disable : 4714)
	// Formal parameters named for documentation purposes
	#pragma warning(disable : 4100)
	// Constant conditional expressions occur quite often in template code
	#pragma warning(disable : 4127)
	// Sometimes, using 'this' in initializier lists is unavoidable
	#pragma warning(disable : 4355)
	// We actually want arrays & PODs to be default-initialized
	#pragma warning(disable : 4351)
	#pragma warning(disable : 4345)
	// Assignment operators suppressed intentionally
	#pragma warning(disable : 4512)
	// Extern template now standard
	#pragma warning(disable : 4231)
	// 'override' specifier is now standard
	#pragma warning(disable : 4481)
	// nameless struct/union
	#pragma warning(disable : 4201)
	// requiring user-defined ctors: wrong for pointers, generally useless
	#pragma warning(disable : 4510)
	#pragma warning(disable : 4610)
#endif

namespace std { struct random_access_iterator_tag; }

namespace stdx
{
	namespace detail
	{
		template <class T, size_t Size>
		char (&arraylen_helper(T (&)[Size]))[Size];
	}
	
	template <class T, class X>
	inline T const& as_(X const& x)
	{
		static_assert(sizeof(T) == sizeof(X), "size mismatch");
		union U { X x; T t; char c[sizeof(T)]; };
		return reinterpret_cast<U const&>(x).t;
	}

	template <class T, size_t Size>
	inline T* arrayend(T (&a)[Size]) { return &a[0] + Size; }

	template <class T, size_t Size>
	inline T* strend(T (&a)[Size]) { assert(!a[Size - 1]); return &a[Size - 1]; }

	template <class T> struct identity { typedef T type; };

	// MSVC' extra invitation in decltype
	template <class T>
	inline typename std::make_unsigned<T>::type to_unsigned(T sgn) { return sgn; }
	template <class T>
	inline typename std::make_signed<T>::type to_signed(T usgn) { return usgn; }

	// SFINAE
	template <class I>
	inline auto maybe_deref_iterator(I it, typename I::iterator_category* = nullptr) -> decltype(*it) { return *it; }
	template <class I>
	inline auto maybe_deref_iterator(I* it) -> decltype(*it) { return *it; }
	#ifdef _MSC_VER
	inline void maybe_deref_iterator(...) { }
	#else
	template <class... Args> inline void maybe_deref_iterator(Args&&...) { }
	#endif

	/// Range type.
	template <class Iterator>
	struct range
	{
		typedef Iterator iterator;
		typedef Iterator const_iterator;
		typedef Iterator pointer;
		typedef Iterator const_pointer;

		iterator first, last;

		range() : first(), last() { }
		range(iterator f, iterator l) : first((iterator&&) f), last((iterator&&) l) { }
		template <class Range>
		explicit range(Range& r) : first(r.begin()), last(const_cast<iterator>(r.end())) { } // const_cast forbids implicit casting (don't lose strides!)
		template <class Range>
		explicit range(Range const& r) : first(r.begin()), last(const_cast<iterator>(r.end())) { } // const_cast forbids implicit casting (don't lose strides!)
		template <class T>
		range(range<T> const& r) : first(r.first), last(const_cast<iterator>(r.last)) { } // const_cast forbids implicit casting (don't lose strides!)
		
		void assign(iterator begin, iterator end) { first = begin; last = end; }
		template <class Range>
		void assign(Range &range) { first = range.begin(); last = const_cast<iterator>(range.end()); }

		// const& to catch pre-POD usage
		iterator const& begin() const { return first; }
		iterator const& end() const { return last; }
		bool empty() const { return (first == last); }
		auto delta() const -> decltype(last - first) { return last - first; }
		auto size() const -> decltype(to_unsigned(last - first)) { return last - first; }
		template <class Index>
		auto operator [](Index i) const -> decltype(*(first + i)) { return *(first + i); }

		/// Gets a reference to the first element.
		auto operator *() const -> decltype(maybe_deref_iterator(first)) { return *first; }
		/// Gets an iterator to the first element.
		iterator operator ->() const { return first; }
		/// Gets whether this range is non-empty.
		operator bool() const { return (first != last); }

		/// Same as begin.
		pointer data() const { return first; }
		/// Same as begin.
		const_pointer cdata() const { return first; }
	};

	template <class SrcIt, class DestIt>
	struct enable_if_iterator_compatible : std::enable_if<std::is_convertible<SrcIt, DestIt>::value> { };

	/// Range type w/ implicit conversion constructors, FOR USE IN PARAMETER LISTS.
	template <class Value, class Iterator = Value*>
	struct data_range_param : range<Iterator>
	{
		data_range_param() { }
		data_range_param(Iterator f, Iterator l) : range<Iterator>(f, l) { }
		template <class Range>
		data_range_param(Range& r
			, typename enable_if_iterator_compatible<typename Range::pointer, Iterator>::type *enable_if_typematch = nullptr
			) : range<Iterator>(r.data(), const_cast<Iterator>(r.data()) + r.size()) { } // const_cast forbids implicit casting (don't lose strides!)
		template <class Range>
		data_range_param(Range const& r
			, typename enable_if_iterator_compatible<typename Range::const_pointer, Iterator>::type *enable_if_typematch = nullptr)
			: range<Iterator>(r.data(), const_cast<Iterator>(r.data()) + r.size()) { } // const_cast forbids implicit casting (don't lose strides!)
	};

	template <class Type> struct strided_ptr;

	/// Strided range type w/ implicit conversion constructors, FOR USE IN PARAMETER LISTS.
	template <class Value, class Iterator = strided_ptr<Value>>
	struct relaxed_data_range_param : range<Iterator>
	{
		relaxed_data_range_param() { }
		relaxed_data_range_param(Iterator f, Iterator l) : range<Iterator>(f, l) { }
		template <class Range>
		relaxed_data_range_param(Range& r
			, typename enable_if_iterator_compatible<typename Range::pointer, Iterator>::type *enable_if_typematch = nullptr)
			: range<Iterator>(Iterator(r.data()), Iterator(r.data() + r.size())) { }
		template <class Range>
		relaxed_data_range_param(Range const& r
			, typename enable_if_iterator_compatible<typename Range::const_pointer, Iterator>::type *enable_if_typematch = nullptr)
			: range<Iterator>(Iterator(r.data()), Iterator(r.data() + r.size())) { }

		template <class Value2>
		range<typename Iterator::template reinterpret_t<Value2>::t> reinterpret() const {
			return range<typename Iterator::template reinterpret_t<Value2>::t>(this->first.reinterpret<Value2>(), this->last.reinterpret<Value2>()); }
	};

	template <class Iterator>
	inline range<Iterator> make_range(Iterator begin, Iterator end) {
		return range<Iterator>(begin, end); }
	template <class Iterator, class Size>
	inline range<Iterator> make_range_n(Iterator begin, Size len) {
		return range<Iterator>(begin, begin + len); }
	template <class Range>
	inline range<typename Range::iterator> make_range(Range &r) {
		return range<typename Range::iterator>(r.begin(), r.end()); }
	template <class Range>
	inline range<typename Range::const_iterator> make_range(Range const &r) {
		return range<typename Range::const_iterator>(r.begin(), r.end()); }

	template <class Iterator>
	inline range<Iterator> str_range(Iterator cstr) {
		Iterator end = cstr; [&end](){ while (*end) ++end; }();
		return range<Iterator>(cstr, end); }
	template <class Char, size_t Size>
	inline range<Char*> strlit_range(Char (&cstr)[Size]) {
		return range<Char*>(cstr, strend(cstr)); }

	template <class Range>
	inline range<typename Range::pointer> data_range(Range &r
		, typename enable_if_iterator_compatible<decltype(static_cast<Range*>(nullptr)->data()), typename Range::pointer>::type *enable_if_typematch = nullptr) {
		return range<typename Range::pointer>(r.data(), r.data() + r.size()); }
	template <class Range>
	inline range<typename Range::const_pointer> data_range(Range const &r) {
		return range<typename Range::const_pointer>(r.data(), r.data() + r.size()); }

	template <class Range>
	inline range<typename Range::pointer> data_range(Range &r, size_t len, size_t offset = 0
		, typename enable_if_iterator_compatible<decltype(static_cast<Range*>(nullptr)->data()), typename Range::pointer>::type *enable_if_typematch = nullptr) {
		return range<typename Range::pointer>(r.data() + offset, r.data() + offset + len); }
	template <class Range>
	inline range<typename Range::const_pointer> data_range(Range const &r, size_t len, size_t offset = 0) {
		return range<typename Range::const_pointer>(r.data() + offset, r.data() + offset + len); }

	template <class Type>
	struct strided_ptr
	{
		typedef Type value_type;
		typedef value_type* pointer;
		typedef value_type& reference;
		typedef ptrdiff_t difference_type;
		typedef std::random_access_iterator_tag iterator_category;

		pointer ptr;
		difference_type stride;

		strided_ptr()
			: ptr( nullptr )
			, stride( sizeof(value_type) ) { }
		strided_ptr(pointer object, difference_type stride)
			: ptr( object )
			, stride( stride ) { }
		template <class Type2>
		strided_ptr(Type2 *object, difference_type stride = sizeof(Type2)
			, typename std::enable_if<std::is_convertible<Type2*, pointer>::value>::type *enable_if_typematch = nullptr)
			: ptr( object )
			, stride( stride ) { }
		template <class Type2>
		strided_ptr(strided_ptr<Type2> const& right
			, typename std::enable_if<std::is_convertible<Type2*, pointer>::value>::type *enable_if_typematch = nullptr)
			: ptr( right.ptr ),
			, stride( right.stride ) { }

		template <class Type2>
		strided_ptr& operator =(strided_ptr<Type2> const& right) {
			ptr = right.ptr;
			stride = right.stride;
			return *this; }

		template <class Type2>
		struct reinterpret_t { typedef strided_ptr<Type2> t; };
		template <class Type2>
		strided_ptr<Type2> reinterpret() const {
			return strided_ptr<Type2>( reinterpret_cast<Type2*>(ptr), stride ); }

		/// Increments the pointer.
		strided_ptr& operator ++() {
			ptr = (pointer) &(char&)((*this)[1]);
			return *this; }
		/// Decrements the pointer.
		strided_ptr& operator --() {
			ptr = (pointer) &(char&)((*this)[-1]);
			return *this; }

		/// Increments the pointer.
		strided_ptr operator ++(int) {
			strided_ptr old(*this);
			++(*this);
			return old; }
		/// Decrements the pointer.
		strided_ptr operator --(int) {
			strided_ptr old(*this);
			--(*this);
			return old; }

		/// Gets the pointer stored by this strided pointer. Don't call unless you know what you are doing!
		pointer get() const { return ptr; }
		/// Gets the stride stored by this strided pointer. Don't call unless you know what you are doing!
		difference_type get_stride() const { return stride; }

		/// Gets the first object referenced by this strided pointer.
		reference operator *() const { return *ptr; }
		/// Gets the first object referenced by this strided pointer.
		pointer operator ->() const { return ptr; }

		/// Gets the n-th object referenced by this strided pointer.
		reference operator [](difference_type n) const {
			return *pointer((char*) ptr + stride * n); }
	
		friend inline strided_ptr operator +(const strided_ptr &p, ptrdiff_t diff) {
			return strided_ptr( (pointer) &(char&)(p[diff]), p.get_stride() ); }
		friend inline strided_ptr operator -(const strided_ptr &p, ptrdiff_t diff) {
			return strided_ptr( (pointer) &(char&)(p[-diff]), p.get_stride() ); }

		friend inline bool operator ==(const strided_ptr &l, const strided_ptr &r) { return l.get() == r.get(); }
		friend inline bool operator !=(const strided_ptr &l, const strided_ptr &r) { return l.get() != r.get(); }
		friend inline bool operator <=(const strided_ptr &l, const strided_ptr &r) { return l.get() <= r.get(); }
		friend inline bool operator >=(const strided_ptr &l, const strided_ptr &r) { return l.get() >= r.get(); }
		friend inline bool operator <(const strided_ptr &l, const strided_ptr &r) { return l.get() < r.get(); }
		friend inline bool operator >(const strided_ptr &l, const strided_ptr &r) { return l.get() > r.get(); }

		friend inline ptrdiff_t operator -(const strided_ptr &p, const strided_ptr &q) {
			assert(p.get_stride() == q.get_stride());
			return ( (char*) p.get() - (char*) q.get() ) / p.get_stride(); }
	};

	class noncopyable
	{
		noncopyable(noncopyable const&);
		noncopyable& operator =(noncopyable const&);

	public:
		noncopyable() { } 
	};

	extern bool const is_debugger_present;

	struct noop
	{
		#ifdef _MSC_VER
		void operator ()(...) const { }
		#else
		template <class... Args> void operator ()(Args&&...) const { }
		#endif
	};

	template <class Exception>
	class error : public std::runtime_error
	{
	public:
		error(char const* msg)
			: runtime_error(msg) { }
		error(std::string const& msg)
			: runtime_error(msg) { }

		static bool break_on_error;
	};
	template <class Exception>
	bool error<Exception>::break_on_error = true;

	template <class Exception>
	inline bool break_on_error(error<Exception> const&) { return error<Exception>::break_on_error; }
	#ifdef _MSC_VER
	inline bool break_on_error(...) { return false; }
	#else
	template <class... Args> inline bool break_on_error(Args&&...) { return false; }
	#endif
	
	template <class Pointer>
	struct no_delete
	{
		typedef Pointer pointer;
		void operator ()(pointer ptr) const { }
	};

	template < class Handle, class Deleter = no_delete<Handle> >
	class unique_handle : public std::unique_ptr<Handle, Deleter>
	{
	public:
		// Need fully qualified template, otherwise compiler crashes
		typedef typename std::unique_ptr<Handle, Deleter>::pointer pointer;
		typedef pointer transparent_type;

		// Inherit constructors
		unique_handle() { }
		unique_handle(std::nullptr_t) { }
		explicit unique_handle(pointer value)
			: unique_handle::unique_ptr(std::move(value)) { }
			
		unique_handle(unique_handle &&right)
			: unique_handle::unique_ptr(std::move(right)) { }
		unique_handle& operator =(unique_handle &&right)
		{
			this->unique_ptr::swap(right);
			return *this;
		}
		
		pointer* rebind()
		{
			this->reset();
			static_assert(sizeof(*this) == sizeof(pointer), "unique_handle not binary compatible!");
			return &reinterpret_cast<pointer&>(*this);
		}
		
		transparent_type const& get() const
		{
			static_assert(sizeof(*this) == sizeof(pointer), "unique_handle not binary compatible!");
			return reinterpret_cast<pointer const&>(*this);
		}
		operator transparent_type() const { return get(); }
		bool valid() const { return get() != pointer(); }

	private:
		// strictly noncopyable
		template <class T>
		unique_handle(unique_handle<T> const &right);
	};

	template <class T>
	struct has_transparent_type
	{
		typedef char yes[1];
		typedef char no[2];

		template <class Z>
		static yes& sfinae(Z*, typename Z::transparent_type* = nullptr);
		static no& sfinae(...);

		static bool const value = sizeof(yes) == sizeof(sfinae(static_cast<T*>(nullptr)));
	};

	template <class T, bool = has_transparent_type<T>::value>
	struct transparent_type
	{
		typedef typename transparent_type<typename T::transparent_type>::type type;

		template <class V>
		static auto get(V &&v) -> decltype(std::forward<V>(v).get()) { return std::forward<V>(v).get(); }
	};
	template <class T>
	struct transparent_type<T, false>
	{
		typedef T type;

		template <class V>
		static auto get(V &&v) -> decltype(std::forward<V>(v)) { return std::forward<V>(v); }
	};

	template <class T>
	inline auto get_transparent(T &&v)
		-> decltype(transparent_type<typename std::remove_reference<T>::type>::get(std::forward<T>(v)))
	{
		return transparent_type<typename std::remove_reference<T>::type>::get(std::forward<T>(v));
	}

	inline bool streq(char const* a, char const* b) { return strcmp(a, b) == 0; }
	inline bool strieq(char const* a, char const* b)
#ifdef WIN32
	{ return _stricmp(a, b) == 0; }
#else
	{ return strcasecmp(a, b) == 0; }
#endif

	inline bool check_flag(char const* arg, char const* flag) {
		return (arg[0] == '/' || arg[0] == '-') && strieq(arg + 1, flag); }

} // namespace

#define arraylen(x) sizeof(::stdx::detail::arraylen_helper(x))

#ifdef _MSC_VER
#define debugbreak() __debugbreak()
#else
#define debugbreak() __builtin_trap()
#endif

#if defined(NDEBUG) && !defined(DEBUG_EXCEPTIONS)
	#define throwx(x) throw x
#else
	#define throwx(x) do { using ::stdx::break_on_error;  auto&& exc = x; if (break_on_error(exc) && ::stdx::is_debugger_present) debugbreak(); throw exc; } while (false)
#endif

#define TOKEN_TO_STRING(x) #x
#define VALUE_TO_STRING(x) TOKEN_TO_STRING(x)

#define FILE_LINE __FILE__ "(" VALUE_TO_STRING(__LINE__) ")"
#define FILE_LINE_PREFIX FILE_LINE ": "

// MSVC 2013 shame
#define MSVC_EXPAND(x) x

#define MOVE_GENERATE(clazz, generator, ...) \
	clazz(clazz &&right) : MSVC_EXPAND(generator##_CONSTRUCT(right, __VA_ARGS__)) { } \
	clazz& operator =(clazz &&right) { MSVC_EXPAND(generator##_ASSIGN(right, __VA_ARGS__)) return *this; }

#define MOVE_BASE_CONSTRUCT(right, base) base(std::move(right))
#define MOVE_BASE_ASSIGN(right, base) base::operator =(std::move(right))
#define MOVE_MEMBER_CONSTRUCT(right, member) member(std::move(right.member))
#define MOVE_MEMBER_ASSIGN(right, member) std::swap(member, right.member)

#define MOVE_1_CONSTRUCT(right, what, that) MOVE_##what##_CONSTRUCT(right, that)
#define MOVE_1_ASSIGN(right, what, that) MOVE_##what##_ASSIGN(right, that);
#define MOVE_2_CONSTRUCT(right, what, that, ...) MOVE_##what##_CONSTRUCT(right, that), MSVC_EXPAND(MOVE_1_CONSTRUCT(right, __VA_ARGS__))
#define MOVE_2_ASSIGN(right, what, that, ...) MOVE_##what##_ASSIGN(right, that); MSVC_EXPAND(MOVE_1_ASSIGN(right, __VA_ARGS__))
#define MOVE_3_CONSTRUCT(right, what, that, ...) MOVE_##what##_CONSTRUCT(right, that), MSVC_EXPAND(MOVE_2_CONSTRUCT(right, __VA_ARGS__))
#define MOVE_3_ASSIGN(right, what, that, ...) MOVE_##what##_ASSIGN(right, that); MSVC_EXPAND(MOVE_2_ASSIGN(right, __VA_ARGS__))
#define MOVE_4_CONSTRUCT(right, what, that, ...) MOVE_##what##_CONSTRUCT(right, that), MSVC_EXPAND(MOVE_3_CONSTRUCT(right, __VA_ARGS__))
#define MOVE_4_ASSIGN(right, what, that, ...) MOVE_##what##_ASSIGN(right, that); MSVC_EXPAND(MOVE_3_ASSIGN(right, __VA_ARGS__))
#define MOVE_5_CONSTRUCT(right, what, that, ...) MOVE_##what##_CONSTRUCT(right, that), MSVC_EXPAND(MOVE_4_CONSTRUCT(right, __VA_ARGS__))
#define MOVE_5_ASSIGN(right, what, that, ...) MOVE_##what##_ASSIGN(right, that); MSVC_EXPAND(MOVE_4_ASSIGN(right, __VA_ARGS__))
#define MOVE_6_CONSTRUCT(right, what, that, ...) MOVE_##what##_CONSTRUCT(right, that), MSVC_EXPAND(MOVE_5_CONSTRUCT(right, __VA_ARGS__))
#define MOVE_6_ASSIGN(right, what, that, ...) MOVE_##what##_ASSIGN(right, that); MSVC_EXPAND(MOVE_5_ASSIGN(right, __VA_ARGS__))
#define MOVE_7_CONSTRUCT(right, what, that, ...) MOVE_##what##_CONSTRUCT(right, that), MSVC_EXPAND(MOVE_6_CONSTRUCT(right, __VA_ARGS__))
#define MOVE_7_ASSIGN(right, what, that, ...) MOVE_##what##_ASSIGN(right, that); MSVC_EXPAND(MOVE_6_ASSIGN(right, __VA_ARGS__))
#define MOVE_8_CONSTRUCT(right, what, that, ...) MOVE_##what##_CONSTRUCT(right, that), MSVC_EXPAND(MOVE_7_CONSTRUCT(right, __VA_ARGS__))
#define MOVE_8_ASSIGN(right, what, that, ...) MOVE_##what##_ASSIGN(right, that); MSVC_EXPAND(MOVE_7_ASSIGN(right, __VA_ARGS__))

#define MOVE_BASE(clazz, base) MOVE_GENERATE(clazz, MOVE_1, BASE, base)
#define MOVE_MEMBER(clazz, member) MOVE_GENERATE(clazz, MOVE_1, MEMBER, member)
#define MOVE_BASE_MEMBER(clazz, base, member) MOVE_GENERATE(clazz, MOVE_2, BASE, base, MEMBER, member)

// Recursive transparent conversion functionality
#define TRANSPARENT_MEMBER(clazz, member) \
	typedef decltype(clazz::member) transparent_type; \
	stdx::transparent_type<decltype(clazz::member)>::type const& get() const { return stdx::get_transparent(member); } \
	operator stdx::transparent_type<decltype(clazz::member)>::type() const { return member; }

#define INPLACE_OSTREAM(t, x) static_cast<t&>(t() << x)
#define INPLACE_SSTREAM(x) INPLACE_OSTREAM(std::stringstream, x)
#define INPLACE_STR(x) INPLACE_SSTREAM(x).str()