#pragma once

#include <stdexcept>
#include <cassert>
#include <utility>
#include <memory>

namespace stdx
{
	namespace detail
	{
		template <class T, size_t Size>
		char (&arraylen_helper(T (&)[Size]))[Size];
	}

	template <class T, size_t Size>
	inline T* arrayend(T (&a)[Size]) { return &a[0] + Size; }

	template <class T, size_t Size>
	inline T* strend(T (&a)[Size]) { assert(!a[Size - 1]); return &a[Size - 1]; }

	template <class Iterator>
	struct range
	{
		typedef Iterator iterator;
		typedef Iterator const_iterator;

		iterator first, last;

		range() : first(), last() { }
		range(iterator f, iterator l) : first((iterator&&) f), last((iterator&&) l) { }

		iterator begin() const { return first; }
		iterator end() const { return last; }
		auto size() const -> decltype(last - first) { return last - first; }
		auto operator [](ptrdiff_t i) const -> decltype(*(first + i)) { return *(first + i); }

		operator bool() const { return first != last; }
	};
	template <class T>
	struct data_range : range<T*>
	{
		data_range() { }
		data_range(T* f, T* l) : typename data_range::range(f, l) { }

		T* data() const { return this->f; }
		T* data_end() const { return this->l; }
	};

	class noncopyable
	{
		noncopyable(noncopyable const&);
		noncopyable& operator =(noncopyable const&);

	public:
		noncopyable() { } 
	};

	extern bool const is_debugger_present;

	template <class Exception>
	class error : public std::runtime_error
	{
	public:
		error(char const* msg)
			: runtime_error(msg) { }
		error(std::string const& msg)
			: runtime_error(msg) { }

		static bool break_on_error;
	};
	template <class Exception>
	bool error<Exception>::break_on_error = true;

	template <class Exception>
	inline bool break_on_error(error<Exception> const&) { return error<Exception>::break_on_error; }
	inline bool break_on_error(...) { return false; }
	
	template <class Pointer>
	struct no_delete
	{
		typedef Pointer pointer;
		void operator ()(pointer ptr) const { }
	};

	template < class Handle, class Deleter = no_delete<Handle> >
	class unique_handle : public std::unique_ptr<Handle, Deleter>
	{
	public:
		// Need fully qualified template, otherwise compiler crashes
		typedef typename std::unique_ptr<Handle, Deleter>::pointer pointer;
		typedef pointer transparent_type;

		// Inherit constructors
		unique_handle() { }
		unique_handle(nullptr_t) { }
		explicit unique_handle(pointer value)
			: typename unique_handle::unique_ptr(std::move(value)) { }
			
		unique_handle(unique_handle &&right)
			: typename unique_handle::unique_ptr(std::move(right)) { }
		unique_handle& operator =(unique_handle &&right)
		{
			this->unique_ptr::swap(right);
			return *this;
		}
		
		pointer* rebind()
		{
			this->reset();
			static_assert(sizeof(*this) == sizeof(pointer), "unique_handle not binary compatible!");
			return &reinterpret_cast<pointer&>(*this);
		}
		
		transparent_type const& get() const
		{
			static_assert(sizeof(*this) == sizeof(pointer), "unique_handle not binary compatible!");
			return reinterpret_cast<pointer const&>(*this);
		}
		operator transparent_type() const { return get(); }
		operator bool() const { return get() != pointer(); }
	};

	template <class T>
	struct has_transparent_type
	{
		typedef char yes[1];
		typedef char no[2];

		template <class Z>
		static yes& sfinae(Z*, typename Z::transparent_type* = nullptr);
		static no& sfinae(...);

		static bool const value = sizeof(yes) == sizeof(sfinae(static_cast<T*>(nullptr)));
	};

	template <class T, bool = has_transparent_type<T>::value>
	struct transparent_type
	{
		typedef typename transparent_type<typename T::transparent_type>::type type;

		template <class V>
		static auto get(V &&v) -> decltype(std::forward<V>(v).get()) { return std::forward<V>(v).get(); }
	};
	template <class T>
	struct transparent_type<T, false>
	{
		typedef T type;

		template <class V>
		static auto get(V &&v) -> decltype(std::forward<V>(v)) { return std::forward<V>(v); }
	};

	template <class T>
	auto get_transparent(T &&v)
		-> decltype(transparent_type<typename std::remove_reference<T>::type>::get(std::forward<T>(v)))
	{
		return transparent_type<typename std::remove_reference<T>::type>::get(std::forward<T>(v));
	}

} // namespace

#define arraylen(x) sizeof(::stdx::detail::arraylen_helper(x))
#ifdef NDEBUG
	#define throwx(x) throw x
#else
	#define throwx(x) do { using ::stdx::break_on_error;  auto&& exc = x; if (break_on_error(exc) && ::stdx::is_debugger_present) __debugbreak(); throw exc; } while (false)
#endif

// MSVC 2013 shame
#define MOVE_BASE(clazz, base) \
	clazz(clazz &&right) : base(std::move(right)) { } \
	clazz& operator =(clazz &&right) { typedef base base_move_type; base_move_type::operator =(std::move(right)); return *this; }
#define MOVE_MEMBER(clazz, member) \
	clazz(clazz &&right) : member(std::move(right.member)) { } \
	clazz& operator =(clazz &&right) { std::swap(member, right.member); return *this; }
#define MOVE_2_MEMBERS(clazz, member1, member2) \
	clazz(clazz &&right) : member1(std::move(right.member1)), member2(std::move(right.member2)) { } \
	clazz& operator =(clazz &&right) { std::swap(member1, right.member1); std::swap(member2, right.member2); return *this; }
#define MOVE_3_MEMBERS(clazz, member1, member2, member3) \
	clazz(clazz &&right) : member1(std::move(right.member1)), member2(std::move(right.member2)), member3(std::move(right.member3)) { } \
	clazz& operator =(clazz &&right) { std::swap(member1, right.member1); std::swap(member2, right.member2); std::swap(member3, right.member3); return *this; }
#define MOVE_4_MEMBERS(clazz, member1, member2, member3, member4) \
	clazz(clazz &&right) : member1(std::move(right.member1)), member2(std::move(right.member2)), member3(std::move(right.member3)), member4(std::move(right.member4)) { } \
	clazz& operator =(clazz &&right) { std::swap(member1, right.member1); std::swap(member2, right.member2); std::swap(member3, right.member3); std::swap(member4, right.member4); return *this; }

// Recursive transparent conversion functionality
#define TRANSPARENT_MEMBER(clazz, member) \
	typedef decltype(clazz::member) transparent_type; \
	stdx::transparent_type<decltype(clazz::member)>::type const& get() const { return stdx::get_transparent(member); } \
	operator stdx::transparent_type<decltype(clazz::member)>::type() const { return member; }
