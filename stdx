#pragma once

#include <stdexcept>
#include <cassert>
#include <utility>
#include <memory>

namespace stdx
{
	namespace detail
	{
		template <class T, size_t Size>
		char (&arraylen_helper(T (&)[Size]))[Size];
	}

	template <class T, size_t Size>
	inline T* arrayend(T (&a)[Size]) { return &a[0] + Size; }

	template <class T, size_t Size>
	inline T* strend(T (&a)[Size]) { assert(!a[Size - 1]); return &a[Size - 1]; }

	class noncopyable
	{
		noncopyable(noncopyable const&);
		noncopyable& operator =(noncopyable const&);

	public:
		noncopyable() { } 
	};

	extern bool const is_debugger_present;

	template <class Exception>
	class error : public std::runtime_error
	{
	public:
		error(char const* msg)
			: runtime_error(msg) { }
		error(std::string const& msg)
			: runtime_error(msg) { }

		static bool break_on_error;
	};
	template <class Exception>
	bool error<Exception>::break_on_error = true;

	template <class Exception>
	inline bool break_on_error(error<Exception> const&) { return error<Exception>::break_on_error; }
	inline bool break_on_error(...) { return false; }
	
	template <class Pointer>
	struct no_delete
	{
		typedef Pointer pointer;
		void operator ()(pointer ptr) const { }
	};

	template < class Handle, class Deleter = no_delete<Handle> >
	class unique_handle : public std::unique_ptr<Handle, Deleter>
	{
	public:
		// Need fully qualified template, otherwise compiler crashes
		typedef typename std::unique_ptr<Handle, Deleter>::pointer pointer;
		typedef pointer transparent_type;

		// Inherit constructors
		unique_handle() { }
		unique_handle(nullptr_t) { }
		explicit unique_handle(pointer value)
			: typename unique_handle::unique_ptr(std::move(value)) { }
			
		unique_handle(unique_handle &&right)
			: typename unique_handle::unique_ptr(std::move(right)) { }
		unique_handle& operator =(unique_handle &&right)
		{
			this->unique_ptr::swap(right);
			return *this;
		}
		
		pointer* rebind()
		{
			this->reset();
			static_assert(sizeof(*this) == sizeof(pointer), "unique_handle not binary compatible!");
			return &reinterpret_cast<pointer&>(*this);
		}
		
		transparent_type const& get() const
		{
			static_assert(sizeof(*this) == sizeof(pointer), "unique_handle not binary compatible!");
			return reinterpret_cast<pointer const&>(*this);
		}
		operator transparent_type() const { return get(); }
		operator bool() const { return get() != pointer(); }
	};

	template <class T>
	struct has_transparent_type
	{
		typedef char yes[1];
		typedef char no[2];

		template <class Z>
		static yes& sfinae(Z*, typename Z::transparent_type* = nullptr);
		static no& sfinae(...);

		static bool const value = sizeof(yes) == sizeof(sfinae(static_cast<T*>(nullptr)));
	};

	template <class T, bool = has_transparent_type<T>::value>
	struct transparent_type
	{
		typedef typename transparent_type<typename T::transparent_type>::type type;

		template <class V>
		static auto get(V &&v) -> decltype(std::forward<V>(v).get()) { return std::forward<V>(v).get(); }
	};
	template <class T>
	struct transparent_type<T, false>
	{
		typedef T type;

		template <class V>
		static auto get(V &&v) -> decltype(std::forward<V>(v)) { return std::forward<V>(v); }
	};

	template <class T>
	auto get_transparent(T &&v)
		-> decltype(transparent_type<typename std::remove_reference<T>::type>::get(std::forward<T>(v)))
	{
		return transparent_type<typename std::remove_reference<T>::type>::get(std::forward<T>(v));
	}

} // namespace

#define arraylen(x) sizeof(::stdx::detail::arraylen_helper(x))
#ifdef NDEBUG
	#define throwx(x) throw x
#else
	#define throwx(x) do { using ::stdx::break_on_error;  auto&& exc = x; if (break_on_error(exc) && ::stdx::is_debugger_present) __debugbreak(); throw exc; } while (false)
#endif