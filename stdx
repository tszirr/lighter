#pragma once

#include <stdexcept>
#include <cassert>
#include <utility>
#include <type_traits>
#include <memory>

#ifdef _MSC_VER
	#pragma warning(push)
	// Decorated name length exceeded all the time by various STL containers
	#pragma warning(disable : 4503)
	// Can't do anything about methods not being inlined
	#pragma warning(disable : 4714)
	// Formal parameters named for documentation purposes
	#pragma warning(disable : 4100)
	// Constant conditional expressions occur quite often in template code
	#pragma warning(disable : 4127)
	// Sometimes, using 'this' in initializier lists is unavoidable
	#pragma warning(disable : 4355)
	// We actually want arrays & PODs to be default-initialized
	#pragma warning(disable : 4351)
	#pragma warning(disable : 4345)
	// Assignment operators suppressed intentionally
	#pragma warning(disable : 4512)
	// Extern template now standard
	#pragma warning(disable : 4231)
	// 'override' specifier is now standard
	#pragma warning(disable : 4481)
	// nameless struct/union
	#pragma warning(disable : 4201)
#endif

namespace stdx
{
	namespace detail
	{
		template <class T, size_t Size>
		char (&arraylen_helper(T (&)[Size]))[Size];
	}

	template <class T, size_t Size>
	inline T* arrayend(T (&a)[Size]) { return &a[0] + Size; }

	template <class T, size_t Size>
	inline T* strend(T (&a)[Size]) { assert(!a[Size - 1]); return &a[Size - 1]; }

	// MSVC' extra invitation in decltype
	template <class T>
	inline typename std::make_unsigned<T>::type to_unsigned(T sgn) { return sgn; }
	template <class T>
	inline typename std::make_signed<T>::type to_signed(T usgn) { return usgn; }

	// SFINAE
	template <class I>
	inline auto maybe_deref_iterator(I it, typename I::iterator_category* = nullptr) -> decltype(*it) { return *it; }
	template <class I>
	inline auto maybe_deref_iterator(I* it) -> decltype(*it) { return *it; }
	inline void maybe_deref_iterator(...) { }

	/// Range type.
	template <class Iterator>
	struct range
	{
		typedef Iterator iterator;
		typedef Iterator const_iterator;

		iterator first, last;

		range() : first(), last() { }
		range(iterator f, iterator l) : first((iterator&&) f), last((iterator&&) l) { }
		template <class Range>
		explicit range(Range& r) : first(r.begin()), last(r.end()) { }
		template <class Range>
		explicit range(Range const& r) : first(r.begin()), last(r.end()) { }
	
		void assign(iterator begin, iterator end) { first = begin; last = end; }
		template <class Range>
		void assign(Range &range) { first = range.begin(); last = range.end(); }

		// const& to catch pre-POD usage
		iterator const& begin() const { return first; }
		iterator const& end() const { return last; }
		bool empty() const { return (first == last); }
		auto delta() const -> decltype(last - first) { return last - first; }
		auto size() const -> decltype(to_unsigned(last - first)) { return last - first; }
		template <class Index>
		auto operator [](Index i) const -> decltype(*(first + i)) { return *(first + i); }

		/// Gets a reference to the first element.
		auto operator *() const -> decltype(maybe_deref_iterator(first)) { return *first; }
		/// Gets an iterator to the first element.
		iterator operator ->() const { return first; }
		/// Gets whether this range is non-empty.
		operator bool() const { return (first != last); }

		/// Same as begin.
		iterator data() const { return first; }
		/// Same as begin.
		const_iterator cdata() const { return first; }
	};

	/// Range type w/ implicit conversion constructors, FOR USE IN PARAMETER LISTS.
	template <class Value>
	struct data_range_param : range<Value*>
	{
		data_range_param() : first(), last() { }
		data_range_param(Value* f, Value* l) : range<Value*>(f, l) { }
		template <class Range>
		data_range_param(Range& r) : range<Value*>(r.data(), const_cast<Value*>(r.data()) + r.size()) { }
		template <class Range>
		data_range_param(Range const& r) : range<Value*>(r.data(), const_cast<Value*>(r.data()) + r.size()) { }
	};

	template <class Iterator>
	inline range<Iterator> make_range(Iterator begin, Iterator end) {
		return range<Iterator>(begin, end); }
	template <class Iterator, class Size>
	inline range<Iterator> make_range_n(Iterator begin, Size len) {
		return range<Iterator>(begin, begin + len); }
	template <class Range>
	inline range<typename Range::iterator> make_range(Range &r) {
		return range<typename Range::iterator>(r.begin(), r.end()); }
	template <class Range>
	inline range<typename Range::const_iterator> make_range(Range const &r) {
		return range<typename Range::const_iterator>(r.begin(), r.end()); }

	template <class Range>
	inline range<typename Range::pointer> data_range(Range &r) {
		return range<typename Range::pointer>(r.data(), r.data() + r.size()); }
	template <class Range>
	inline range<typename Range::const_pointer> data_range(Range const &r) {
		return range<typename Range::const_pointer>(r.data(), r.data() + r.size()); }

	class noncopyable
	{
		noncopyable(noncopyable const&);
		noncopyable& operator =(noncopyable const&);

	public:
		noncopyable() { } 
	};

	extern bool const is_debugger_present;

	template <class Exception>
	class error : public std::runtime_error
	{
	public:
		error(char const* msg)
			: runtime_error(msg) { }
		error(std::string const& msg)
			: runtime_error(msg) { }

		static bool break_on_error;
	};
	template <class Exception>
	bool error<Exception>::break_on_error = true;

	template <class Exception>
	inline bool break_on_error(error<Exception> const&) { return error<Exception>::break_on_error; }
	inline bool break_on_error(...) { return false; }
	
	template <class Pointer>
	struct no_delete
	{
		typedef Pointer pointer;
		void operator ()(pointer ptr) const { }
	};

	template < class Handle, class Deleter = no_delete<Handle> >
	class unique_handle : public std::unique_ptr<Handle, Deleter>
	{
	public:
		// Need fully qualified template, otherwise compiler crashes
		typedef typename std::unique_ptr<Handle, Deleter>::pointer pointer;
		typedef pointer transparent_type;

		// Inherit constructors
		unique_handle() { }
		unique_handle(nullptr_t) { }
		explicit unique_handle(pointer value)
			: typename unique_handle::unique_ptr(std::move(value)) { }
			
		unique_handle(unique_handle &&right)
			: typename unique_handle::unique_ptr(std::move(right)) { }
		unique_handle& operator =(unique_handle &&right)
		{
			this->unique_ptr::swap(right);
			return *this;
		}
		
		pointer* rebind()
		{
			this->reset();
			static_assert(sizeof(*this) == sizeof(pointer), "unique_handle not binary compatible!");
			return &reinterpret_cast<pointer&>(*this);
		}
		
		transparent_type const& get() const
		{
			static_assert(sizeof(*this) == sizeof(pointer), "unique_handle not binary compatible!");
			return reinterpret_cast<pointer const&>(*this);
		}
		operator transparent_type() const { return get(); }
		operator bool() const { return get() != pointer(); }

	private:
		// strictly noncopyable
		template <class T>
		unique_handle(unique_handle<T> const &right);
	};

	template <class T>
	struct has_transparent_type
	{
		typedef char yes[1];
		typedef char no[2];

		template <class Z>
		static yes& sfinae(Z*, typename Z::transparent_type* = nullptr);
		static no& sfinae(...);

		static bool const value = sizeof(yes) == sizeof(sfinae(static_cast<T*>(nullptr)));
	};

	template <class T, bool = has_transparent_type<T>::value>
	struct transparent_type
	{
		typedef typename transparent_type<typename T::transparent_type>::type type;

		template <class V>
		static auto get(V &&v) -> decltype(std::forward<V>(v).get()) { return std::forward<V>(v).get(); }
	};
	template <class T>
	struct transparent_type<T, false>
	{
		typedef T type;

		template <class V>
		static auto get(V &&v) -> decltype(std::forward<V>(v)) { return std::forward<V>(v); }
	};

	template <class T>
	inline auto get_transparent(T &&v)
		-> decltype(transparent_type<typename std::remove_reference<T>::type>::get(std::forward<T>(v)))
	{
		return transparent_type<typename std::remove_reference<T>::type>::get(std::forward<T>(v));
	}

} // namespace

#define arraylen(x) sizeof(::stdx::detail::arraylen_helper(x))
#ifdef NDEBUG
	#define throwx(x) throw x
#else
	#define throwx(x) do { using ::stdx::break_on_error;  auto&& exc = x; if (break_on_error(exc) && ::stdx::is_debugger_present) __debugbreak(); throw exc; } while (false)
#endif

#define TOKEN_TO_STRING(x) #x
#define VALUE_TO_STRING(x) TOKEN_TO_STRING(x)

// MSVC 2013 shame
#define MOVE_BASE(clazz, base) \
	clazz(clazz &&right) : base(std::move(right)) { } \
	clazz& operator =(clazz &&right) { typedef base base_move_type; base_move_type::operator =(std::move(right)); return *this; }
#define MOVE_MEMBER(clazz, member) \
	clazz(clazz &&right) : member(std::move(right.member)) { } \
	clazz& operator =(clazz &&right) { std::swap(member, right.member); return *this; }
#define MOVE_2_MEMBERS(clazz, member1, member2) \
	clazz(clazz &&right) : member1(std::move(right.member1)), member2(std::move(right.member2)) { } \
	clazz& operator =(clazz &&right) { std::swap(member1, right.member1); std::swap(member2, right.member2); return *this; }
#define MOVE_3_MEMBERS(clazz, member1, member2, member3) \
	clazz(clazz &&right) : member1(std::move(right.member1)), member2(std::move(right.member2)), member3(std::move(right.member3)) { } \
	clazz& operator =(clazz &&right) { std::swap(member1, right.member1); std::swap(member2, right.member2); std::swap(member3, right.member3); return *this; }
#define MOVE_4_MEMBERS(clazz, member1, member2, member3, member4) \
	clazz(clazz &&right) : member1(std::move(right.member1)), member2(std::move(right.member2)), member3(std::move(right.member3)), member4(std::move(right.member4)) { } \
	clazz& operator =(clazz &&right) { std::swap(member1, right.member1); std::swap(member2, right.member2); std::swap(member3, right.member3); std::swap(member4, right.member4); return *this; }

// Recursive transparent conversion functionality
#define TRANSPARENT_MEMBER(clazz, member) \
	typedef decltype(clazz::member) transparent_type; \
	stdx::transparent_type<decltype(clazz::member)>::type const& get() const { return stdx::get_transparent(member); } \
	operator stdx::transparent_type<decltype(clazz::member)>::type() const { return member; }

#define INPLACE_OSTREAM(t, x) static_cast<t&>(t() << x)
#define INPLACE_SSTREAM(x) INPLACE_OSTREAM(std::stringstream, x)
#define INPLACE_STR(x) INPLACE_SSTREAM(x).str()