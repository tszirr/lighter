#pragma once

#include "stdx"
#include <vector>
#include <typeinfo>

namespace appx
{

struct pooled_interface
{
	virtual void acquire() const = 0;
	virtual void release() const = 0;
};

template <class RefObj, class PoolPtr>
struct pooled_ref : RefObj
{
	PoolPtr pooled;

	void destroy() const
	{
		if (this->ref)
			pooled->release();
	}

	// "inherit" constructors
	pooled_ref()
		: RefObj()
		, pooled() { }
	pooled_ref(std::nullptr_t)
		: RefObj(nullptr)
		, pooled() { }
	pooled_ref(RefObj&& value, PoolPtr pooled)
		: RefObj(MOVE_T(value))
		, pooled(pooled) { }
	pooled_ref(RefObj const& value, PoolPtr pooled)
		: RefObj(value)
		, pooled(pooled) { }
};

// template <class RefObj>
// using own_pooled = stdx::own< pooled_ref<RefObj, pooled_interface*> >;

template <class RefObj>
class own_pooled : public stdx::own< pooled_ref<RefObj, pooled_interface*> >
{
public:
	// "inherit" constructors
	own_pooled() : typename own_pooled::own() { }
	own_pooled(std::nullptr_t) : typename own_pooled::own(nullptr) { }
	explicit own_pooled(typename own_pooled::pointer&& value)
		: typename own_pooled::own(MOVE_T(value)) { }
	explicit own_pooled(typename own_pooled::pointer const& value)
		: typename own_pooled::own(value) { }

	// movement
	own_pooled(own_pooled&& right)
		: typename own_pooled::own(MOVE_T(right)) { }
	using own::operator =;
	
	own_pooled acquire() const
	{
		if (this->ref)
			this->pooled->acquire();
		return own_pooled(*this);
	}
};

namespace detail
{
	namespace resource_pool
	{
		enum no_context_t { no_context };
		
		template <class Desc, class Context>
		static auto create(Desc const& desc, Context&& ctx) -> decltype(desc.create(std::forward<Context>(ctx))) {
			return desc.create( FORWARD(Context, ctx) ); }
		template <class Desc>
		static auto create(Desc const& desc, no_context_t) -> decltype(desc.create()) {
			return desc.create(); }

		template <class Resource>
		struct no_desc_t { };

		template <class Resource, class Context>
		static auto create(no_desc_t<Resource> const&, Context&& ctx) -> decltype(Resource::create(std::forward<Context>(ctx))) {
			return Resource::create( FORWARD(Context, ctx) ); }
		template <class Resource>
		static auto create(no_desc_t<Resource> const&, no_context_t) -> decltype(Resource::create()) {
			return Resource::create(); }

		struct pool_item : pooled_interface
		{
			mutable int ref_count;

			pool_item()
				: ref_count(0)
			{ }

			void acquire() const override { ++ref_count; }
			void release() const override { --ref_count; }
		};

		pool_item* find(std::unique_ptr<pool_item> const* begin, std::unique_ptr<pool_item> const* end, void const* desc
			, bool (*lessThanDesc)(std::unique_ptr<pool_item> const&, void const*)
			, bool (*greaterThanDesc)(void const*, std::unique_ptr<pool_item> const&));
		pool_item* insert(std::vector< std::unique_ptr<pool_item> >& items
			, pool_item* newItemPtr, void const* desc
			, bool (*lessThanDesc)(std::unique_ptr<pool_item> const&, void const*));

		// warning: needs own namespace, otherwise composite template types such as iterators accidentally redirect here via composite ADL
		namespace generic_comparison
		{
			template <class T>
			inline bool operator <(T const& a, T const& b)
			{
				return memcmp(&a, &b, sizeof(a)) < 0;
			}

		} // namespace

	} // namespace

} // namespace

template <class Resource, class ResourceRef = typename Resource::pointer>
struct resource_pool
{
	typedef Resource resource;
	typedef ResourceRef resource_ref;
	typedef own_pooled<resource_ref> owned;
	
	template <class Desc, class Context>
	owned acquire(Desc const& desc, Context&& context)
	{
		auto it = findFree(desc);
		if (!it)
			it = insertNew(desc, FORWARD(Context, context));
		++it->ref_count;
		return owned( owned::pointer(it->resource, it) );
	}
	template <class Desc>
	owned acquire(Desc const& desc) { return acquire(desc, detail::resource_pool::no_context); }

	template <class Desc>
	struct item : pool_item
	{
		Desc description;
		resource resource;

		template <class Res>
		item(Desc const& desc, Res&& res)
			: description(desc)
			, resource(FORWARD(Res, res))
		{ }
	};
	
	typedef detail::resource_pool::pool_item pool_item;
	typedef std::vector< std::unique_ptr<pool_item> > items_t;
	items_t items;

	template <class Desc>
	item<Desc>* findFree(Desc const& desc)
	{
		return static_cast<item<Desc>*>(
			  detail::resource_pool::find(
				  items.data(), items.data() + items.size(), &desc
				, &lessThanDesc<Desc>, &greaterThanDesc<Desc>
				)
			);
	}
	template <class Desc, class Resource>
	item<Desc>* insert(Desc const& desc, Resource&& resource)
	{
		return static_cast<item<Desc>*>(
			  detail::resource_pool::insert(items
				, new item<Desc>(desc, FORWARD(Resource, resource)), &desc
				, &lessThanDesc<Desc>
				)
			);
	}
	template <class Desc, class Context>
	item<Desc>* insertNew(Desc const& desc, Context&& context)
	{
		using detail::resource_pool::create;
		return insert(desc, create(desc, FORWARD(Context, context)));
	}
	template <class Identity, class Context>
	item<Identity*>* insertNew(Identity* identity, Context&& context)
	{
		using detail::resource_pool::create;
		return insert(identity, create(detail::resource_pool::no_desc_t<resource>(), FORWARD(Context, context)));
	}
	
	template <class Desc>
	static bool greaterThanDesc(void const* b, std::unique_ptr<pool_item> const& a)
	{
		using detail::resource_pool::generic_comparison::operator <;
		auto &aType = typeid(*a), &bType = typeid(item<Desc>);
		return aType == bType && *static_cast<Desc const*>(b) < static_cast<item<Desc> const&>(*a).description
			|| &bType < &aType;
	}
	template <class Desc>
	static bool lessThanDesc(std::unique_ptr<pool_item> const& a, void const* b)
	{
		using detail::resource_pool::generic_comparison::operator <;
		auto &aType = typeid(*a), &bType = typeid(item<Desc>);
		return aType == bType && static_cast<item<Desc> const&>(*a).description < *static_cast<Desc const*>(b)
			|| &aType < &bType;
	}
};

} // namespace