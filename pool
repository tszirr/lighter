#pragma once

#include "stdx"
#include <map>

namespace appx
{

struct pooled_interface
{
	virtual void acquire() const = 0;
	virtual void release() const = 0;
};

template <class RefObj, class PoolPtr>
struct pooled_ref : RefObj
{
	PoolPtr pooled;

	void destroy() const
	{
		if (this->ref)
			pooled->release();
	}

	// "inherit" constructors
	pooled_ref()
		: RefObj()
		, pooled() { }
	pooled_ref(std::nullptr_t)
		: RefObj(nullptr)
		, pooled() { }
	pooled_ref(RefObj&& value, PoolPtr pooled)
		: RefObj(MOVE_T(value))
		, pooled(pooled) { }
	pooled_ref(RefObj const& value, PoolPtr pooled)
		: RefObj(value)
		, pooled(pooled) { }
};

// template <class RefObj>
// using own_pooled = stdx::own< pooled_ref<RefObj, pooled_interface*> >;

template <class RefObj>
class own_pooled : public stdx::own< pooled_ref<RefObj, pooled_interface*> >
{
public:
	// "inherit" constructors
	own_pooled() : typename own_pooled::own() { }
	own_pooled(std::nullptr_t) : typename own_pooled::own(nullptr) { }
	explicit own_pooled(typename own_pooled::pointer&& value)
		: typename own_pooled::own(MOVE_T(value)) { }
	explicit own_pooled(typename own_pooled::pointer const& value)
		: typename own_pooled::own(value) { }

	// movement
	own_pooled(own_pooled&& right)
		: typename own_pooled::own(MOVE_T(right)) { }
	using own::operator =;
	
	own_pooled acquire() const
	{
		if (this->ref)
			this->pooled->acquire();
		return own_pooled(*this);
	}
};

namespace detail
{
	namespace resource_pool
	{
		template <class T>
		inline bool operator <(T const& a, T const& b)
		{
			return memcmp(&a, &b, sizeof(a)) < 0;
		}

		enum no_context_t { no_context };

		template <class Desc, class Context>
		static auto create(Desc const& desc, Context&& ctx) -> decltype(desc.create(std::forward<Context>(ctx))) { return desc.create( FORWARD(Context, ctx) ); }
		template <class Desc>
		static auto create(Desc const& desc, no_context_t) -> decltype(desc.create()) { return desc.create(); }

		template <class ResourceRef>
		struct resource_ref_as_pointer { typedef ResourceRef pointer; };
	}
}

template <class Resource, class ID = void const volatile*, class ResourceFactory = Resource>
struct id_resource_desc
{
	typedef Resource resource;

	ID value;

	id_resource_desc(ID value) : value(value) { }

	bool operator ==(id_resource_desc const& r) const { return value == r.value; }
	bool operator <(id_resource_desc const& r) const { return value < r.value; }

	template <class Context>
	static auto create(Context&& ctx) -> decltype(ResourceFactory::create(std::forward<Context>(ctx))) {
		return ResourceFactory::create( FORWARD(Context, ctx) ); }
	static auto create() -> decltype(ResourceFactory::create()) {
		return ResourceFactory::create(); }
};

// template <class ResourceRef, class ID = void const volatile*>
// using id_resource_ref_desc = id_resource_desc<detail::resource_pool::resource_ref_as_pointer<ResourceRef>, ID, ResourceRef>;

template <class ResourceRef, class ID = void const volatile*>
struct id_resource_ref_desc : id_resource_desc<detail::resource_pool::resource_ref_as_pointer<ResourceRef>, ID, ResourceRef>
{
	id_resource_ref_desc(ID value) : typename id_resource_ref_desc::id_resource_desc(value) { }
};

template <class Desc, class ResourceRef = typename Desc::resource::pointer>
struct resource_pool
{
	typedef Desc description;
	typedef ResourceRef resource_ref;
	typedef own_pooled<resource_ref> owned;

	struct item : pooled_interface
	{
		MOVE_GENERATE(item, MOVE_2, MEMBER, resource, MEMBER, ref_count)

		stdx::own<resource_ref> resource;
		mutable int ref_count;

		template <class Res>
		item(Res&& res)
			: resource(FORWARD(Res, res))
			, ref_count(0)
		{ }

		void acquire() const { ++ref_count; }
		void release() const { --ref_count; }
	};
	
	struct desc_less
	{
		bool operator ()(description const& a, description const& b) const
		{
			using detail::resource_pool::operator <;
			return a < b;
		}
	};

	typedef std::multimap<description, item, desc_less> items_t;
	items_t items;

	template <class Context>
	owned acquire(description const& desc, Context&& context)
	{
		auto range = items.equal_range(desc);
		auto it = range.first;
		for (; it != range.second; ++it)
			if (it->second.ref_count == 0)
				break;
		if (it == range.second)
		{
			using detail::resource_pool::create;
			it = items.emplace( desc, create(desc, FORWARD(Context, context)) );
		}
		++it->second.ref_count;
		return owned( owned::pointer(it->second.resource, &it->second) );
	}
	owned acquire(description const& desc) { return acquire(desc, detail::resource_pool::no_context); }
};

} // namespace