#pragma once

#include "stdx"
#include <string>
#include <vector>

namespace stdx
{
	struct file_tag;
	typedef stdx::error<file_tag> file_error;

	long long file_time(char const* name);
	bool file_touch(char const* name);

	std::string dirname(char const* path);
	std::string basename(char const* path);
	std::string realpath(char const* path);

	std::string concat_path(char const* tail, char const* head);
	std::string relative_path(char const* from, char const* to);

	std::string load_file(char const* name);
	
	std::vector<char> load_binary_file(char const* name, bool nullterminated = false);
	
	struct file_flags
	{
		enum open_mode
		{
			nonexisting,
			new_overwrite,
			open_or_new,
			existing
		};
		enum access_flags
		{
			dont_share = 0x0,
			read = 0x1,
			write = 0x2,
			readwrite = read | write
		};
		enum access_hints
		{
			nohints = 0x0,
			sequential = 0x1,
			random = 0x2
		};
	};

	struct mapped_file : file_flags
	{
		char* data;
		size_t size;

		mapped_file(char const* name, size_t size, unsigned access = file_flags::read, file_flags::open_mode mode = file_flags::new_overwrite,
			unsigned share = file_flags::read, unsigned hints = file_flags::nohints);
		~mapped_file();

		void prefetchAll();

		mapped_file(mapped_file &&right)
			: data(right.data)
			, size(right.size)
		{
			right.data = nullptr;
		}
		mapped_file& operator =(mapped_file right)
		{
			std::swap(data, right.data);
			std::swap(size, right.size);
			return *this;
		}

		// MSVC compatibility
	private:
		mapped_file(mapped_file const&);
	};

	void init_shell_on_startup();

	struct dialog
	{
		enum t
		{
			open,
			save,
			folder
		};
	};
	std::vector<std::string> prompt_file(char const* current = nullptr, char const* extensions = nullptr
		, dialog::t mode = dialog::open, bool multi = false);
	std::vector<std::string> prompt_file_compat(char const* current = nullptr, char const* extensions = nullptr
		, dialog::t mode = dialog::open, bool multi = false);

	struct choice
	{
		enum t
		{
			ok,
			yesno,
			yesnocancel
		};
	};
	int prompt(char const* message, char const* title = nullptr, choice::t choice = stdx::choice::ok);

	struct include_resolver
	{
		virtual std::string resolve(char const* filename, bool localInclude) const = 0; 
	};

	std::string process_includes_(stdx::data_range_param<char const> src, char const* filename
		, include_resolver const& resolve_include, stdx::data_range_param<char const> preamble = stdx::data_range_param<char const>()
		, bool int_file_id = false);

	template <class Resolve>
	inline std::string process_includes(stdx::data_range_param<char const> src, char const* filename
		, Resolve&& resolve_include, stdx::data_range_param<char const> preamble = stdx::data_range_param<char const>()
		, bool int_file_id = false)
	{
		struct resolver_wrapper : include_resolver
		{
			Resolve& resolver;
			resolver_wrapper(Resolve& resolver) : resolver(resolver) { }
			std::string resolve(char const* filename, bool localInclude) const override { return resolver(filename, localInclude); } 
		} resolver_wrapper(resolve_include);
		return process_includes_(src, filename, resolver_wrapper, preamble, int_file_id);
	}

} // namespace
