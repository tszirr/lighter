#pragma once

#include "stdx"
#include <string>
#include <vector>

namespace stdx
{
	struct file_tag;
	typedef stdx::error<file_tag> file_error;

	long long file_time(char const* name);

	std::string load_file(char const* name);
	
	std::vector<char> load_binary_file(char const* name, bool nullterminated = false);
	
	struct file_flags
	{
		/// Access modes.
		enum access_modes
		{
			read = 0x1,                  ///< Read mode.
			write = 0x2,                 ///< Write mode.
			readwrite = read | write     ///< Read-write mode.
		};
		/// Additional sharing modes (enhancing access modes which may also be used as sharing modes).
		enum share_modes
		{
			dont_share = 0x0,               ///< Exclusive access mode.
			share_default = 0x4,            ///< Default sharing mode (read-write on read-only access, read otherwise).
		};
		/// Open modes.
		enum open_mode
		{
			create,                 ///< Create file, if not existent (write access only).
			append,                 ///< Open file, if existent (enforced on read-only access).
			open,                   ///< Open file, if existent, otherwise create new file (write access only).
			overwrite               ///< Overwrite file, if existent, otherwise create new file (write access only).
		};
		/// Optimization hints.
		enum hints
		{
			none = 0x0,                     ///< Make no assumptions on future file access.
			sequential = 0x1,       ///< The file is about to be read strictly front-to-back.
			random = 0x2            ///< The file is about to be accessed randomly.
		};
	};

	struct mapped_file : file_flags
	{
		char* data;
		size_t size;

		mapped_file(char const* name, size_t size, unsigned access = file_flags::read, open_mode mode = file_flags::open,
			unsigned hints = file_flags::none, unsigned share = file_flags::share_default);
		~mapped_file();

		void prefetchAll();

		mapped_file(mapped_file &&right)
			: data(right.data)
			, size(right.size)
		{
			right.data = nullptr;
		}
		mapped_file& operator =(mapped_file right)
		{
			std::swap(data, right.data);
			std::swap(size, right.size);
			return *this;
		}

		// MSVC compatibility
	private:
		mapped_file(mapped_file const&);
	};

	struct include_resolver
	{
		virtual std::string resolve(char const* filename, bool localInclude) const = 0; 
	};

	std::string process_includes_(stdx::data_range_param<char const> src, char const* filename
		, include_resolver const& resolve_include, stdx::data_range_param<char const> preamble = stdx::data_range_param<char const>()
		, bool int_file_id = false);

	template <class Resolve>
	inline std::string process_includes(stdx::data_range_param<char const> src, char const* filename
		, Resolve&& resolve_include, stdx::data_range_param<char const> preamble = stdx::data_range_param<char const>()
		, bool int_file_id = false)
	{
		struct resolver_wrapper : include_resolver
		{
			Resolve& resolver;
			resolver_wrapper(Resolve& resolver) : resolver(resolver) { }
			std::string resolve(char const* filename, bool localInclude) const override { return resolver(filename, localInclude); } 
		} resolver_wrapper(resolve_include);
		return process_includes_(src, filename, resolver_wrapper, preamble, int_file_id);
	}

} // namespace
