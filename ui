#pragma once

#include "uii"
#include "mathx"

namespace ui
{

struct TextRenderer
{
	enum CharType
	{
		UTF8,
		UTF16,
		UTF32
	};
	template <class Char, size_t Size = sizeof(Char)> struct CharTypeFromChar;
	template <class Char> struct CharTypeFromChar<Char, 1> { static CharType const value = UTF8; };
	template <class Char> struct CharTypeFromChar<Char, 2> { static CharType const value = UTF16; };
	template <class Char> struct CharTypeFromChar<Char, 4> { static CharType const value = UTF32; };

	virtual glm::aabb<glm::ivec2> selectChar(glm::ivec2 cursorPos, size_t& charIdx, glm::ivec2 insertPos, char const* text, size_t maxChars, CharType type) = 0;
	template <class Char>
	inline glm::aabb<glm::ivec2> selectChar(glm::ivec2 cursorPos, size_t& charIdx, glm::ivec2 insertPos, Char const* text, size_t maxChars = ~0, CharType type = CharTypeFromChar<Char>::value) {
		return selectChar(cursorPos, charIdx, insertPos, reinterpret_cast<char const*>(text), maxChars, type); }
	virtual glm::aabb<glm::ivec2> boundText(char const* text, size_t maxChars, glm::ivec2 insertPos, CharType type) = 0;
	template <class Char>
	inline glm::aabb<glm::ivec2> boundText(Char const* text, size_t maxChars = ~0, glm::ivec2 insertPos = glm::ivec2(0), CharType type = CharTypeFromChar<Char>::value) {
		return boundText(reinterpret_cast<char const*>(text), maxChars, insertPos, type); }
	virtual glm::aabb<glm::ivec2> drawText(glm::ivec2 insertPos, char const* text, size_t maxChars, CharType type) = 0;
	template <class Char>
	inline glm::aabb<glm::ivec2> drawText(glm::ivec2 insertPos, Char const* text, size_t maxChars = ~0, CharType type = CharTypeFromChar<Char>::value) {
		return drawText(insertPos, reinterpret_cast<char const*>(text), maxChars, type); }
};

struct Mouse
{
	bool primary, primaryChanged;
	bool secondary, secondaryChanged;
	glm::ivec2 pos;
};

struct CaptureState
{
	enum T
	{
		Available,
		Owned,
		Unavailable
	};
};

struct Cursor
{
	int row;
	int column;
	glm::ivec2 pos;
};

struct InputKeys
{
  static unsigned const KeyStart		 = 0x80000000;

  static unsigned const ManipKeyMask = 0x81000000;
  static unsigned const DeleteLast	 = ManipKeyMask + 0;
  static unsigned const DeleteNext	 = ManipKeyMask + 1;

  static unsigned const NavKeyMask	 = 0x82000000;
  static unsigned const MoveUp       = NavKeyMask;
  static unsigned const MoveDown		 = NavKeyMask + 1;
  static unsigned const MoveLeft		 = NavKeyMask + 2;
  static unsigned const MoveRight		 = NavKeyMask + 3;
};

struct UniversalInterface::Slider
{
	UniqueElementIdentifier id;
	glm::aabb<glm::ivec2> rect;
	float value;
	float range;
	float valueBase;
};

struct UserInterface
{
	struct Options
	{
		unsigned indent, lineHeight;
		int labelDelta, controlBaseline;

		explicit Options(unsigned lineHeight = 24, unsigned indent = 3, int labelDelta = 24, int controlBaseline = -3) 
			: indent(indent)
			, lineHeight(lineHeight)
			, labelDelta(labelDelta)
			, controlBaseline(controlBaseline) { }
	};

	struct Setup
	{
		Options options;

		glm::aabb<glm::ivec2> rect;

	} setup;

	struct State
	{
		std::vector<UniqueElementIdentifier> entryPath;
		std::vector<UniqueElementIdentifier> focusPath;
		std::vector<UniqueElementIdentifier> capturePath;
		
		Cursor cursor;
		bool cursorVisible;

		Mouse mouse;
		std::vector<unsigned> input;

	} state;

	struct Context
	{
		std::vector<UniqueElementIdentifier> parentPath;
		
		std::vector<unsigned> pendingInput;
		
		glm::ivec2 insertPos;

	} context;

	virtual ~UserInterface() { }

	// prepare internal state for next cycle
	virtual UniversalInterface* reset() = 0;
	virtual UniversalInterface* reset(Mouse const& mouse, stdx::data_range_param<unsigned const> input) = 0;

	// override input capture
	virtual void capture(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id) = 0;
	
	virtual CaptureState::T captureState(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id) const = 0;
	
	bool capturedOrAcquired(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id, bool acquire)
	{
		auto state = captureState(path, id);
		if (acquire && state == CaptureState::Available)
		{
			capture(path, id);
			return true;
		}
		else
			return (state == CaptureState::Owned);
	}
};

} // namespace
