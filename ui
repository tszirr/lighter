#pragma once

#include "ogl"

#include "stdx"
#include "mathx"

#include <algorithm>
#include <string>
#include <vector>

namespace ui
{

struct TextRenderer
{
	enum CharType
	{
		UTF8,
		UTF16,
		UTF32
	};
	template <class Char, size_t Size = sizeof(Char)> struct CharTypeFromChar;
	template <class Char> struct CharTypeFromChar<Char, 1> { static CharType const value = UTF8; };
	template <class Char> struct CharTypeFromChar<Char, 2> { static CharType const value = UTF16; };
	template <class Char> struct CharTypeFromChar<Char, 4> { static CharType const value = UTF32; };

	virtual glm::aabb<glm::ivec2> selectChar(glm::ivec2 cursorPos, size_t& charIdx, glm::ivec2 insertPos, char const* text, size_t maxChars, CharType type) = 0;
	template <class Char>
	inline glm::aabb<glm::ivec2> selectChar(glm::ivec2 cursorPos, size_t& charIdx, glm::ivec2 insertPos, Char const* text, size_t maxChars = ~0, CharType type = CharTypeFromChar<Char>::value) {
		return selectChar(cursorPos, charIdx, insertPos, reinterpret_cast<char const*>(text), maxChars, type); }
	virtual glm::aabb<glm::ivec2> boundText(char const* text, size_t maxChars, glm::ivec2 insertPos, CharType type) = 0;
	template <class Char>
	inline glm::aabb<glm::ivec2> boundText(Char const* text, size_t maxChars = ~0, glm::ivec2 insertPos = glm::ivec2(0), CharType type = CharTypeFromChar<Char>::value) {
		return boundText(reinterpret_cast<char const*>(text), maxChars, insertPos, type); }
	virtual glm::aabb<glm::ivec2> drawText(glm::ivec2 insertPos, char const* text, size_t maxChars, CharType type) = 0;
	template <class Char>
	inline glm::aabb<glm::ivec2> drawText(glm::ivec2 insertPos, Char const* text, size_t maxChars = ~0, CharType type = CharTypeFromChar<Char>::value) {
		return drawText(insertPos, reinterpret_cast<char const*>(text), maxChars, type); }
};

struct UiElement
{
	enum T
	{
		Frame,
		Bar
	};
};

struct UiRenderer
{
	struct QueuedWidget
	{
		unsigned xy;
		unsigned sizeXY;
		unsigned clazz;

		template <class T>
		static unsigned build_tuple(T x, T y)
		{
			return (unsigned) stdx::to_unsigned(x)
				| ((unsigned) stdx::to_unsigned(y) << unsigned(8 * sizeof(T)));
		}
	};

	ogl::Program* widgetProgram;
	ogl::VertexArrays widgetArrays;
	unsigned widgetBatchCnt, widgetBatchSize;
	std::unique_ptr<QueuedWidget[]> widgetMem;
	ogl::Buffer widgetBuffer;

	UiRenderer(ogl::Program* program, unsigned widgetBatchSize)
		: widgetProgram(move(program))
		, widgetArrays()
		, widgetBatchCnt(0)
		, widgetBatchSize(widgetBatchSize)
		, widgetMem(new QueuedWidget[widgetBatchSize])
		, widgetBuffer(ogl::Buffer::create(GL_ARRAY_BUFFER, widgetBatchSize * sizeof(QueuedWidget), nullptr, GL_STATIC_DRAW))
	{
		widgetArrays.bind();
		widgetBuffer.bind(GL_ARRAY_BUFFER);
		glVertexAttribIPointer(0, 3, GL_UNSIGNED_INT, 0, nullptr);
		glEnableVertexAttribArray(0);
		widgetBuffer.unbind(GL_ARRAY_BUFFER);
		widgetArrays.unbind();
	}

	void drawWidget(glm::ivec2 pos, glm::uvec2 size, UiElement::T clazz)
	{
		if (widgetBatchCnt >= widgetBatchSize)
			flushWidgets();

		QueuedWidget qc = { QueuedWidget::build_tuple( (short) pos.x, (short) pos.y )
			, QueuedWidget::build_tuple( (unsigned short) size.x, (unsigned short) size.y )
			, clazz };
		widgetMem[widgetBatchCnt] = qc;
		++widgetBatchCnt;
	}

	void flushWidgets()
	{
		if (widgetBatchCnt > 0)
		{
			widgetBuffer.write(GL_ARRAY_BUFFER, stdx::make_range_n(widgetMem.get(), widgetBatchCnt));
			
			widgetArrays.bind();
			widgetProgram->bind();
			glDrawArrays(GL_POINTS, 0, widgetBatchCnt);
			
			widgetBatchCnt = 0;
		}
	}
};

// online UI: max delayed group? -> forced delay ownership!
struct UiLayout
{
	void add(glm::ivec2 pos, glm::uvec2 size)
	{
	}
};

struct Ui
{
	void addButton()
	{
	}

	void addSlider(char const* data, float value)
	{
	}
};

template <class T, T V> struct GlobalObjectTag { union U { T p; char c; }; static U const tag; };
template <class T, T V> typename GlobalObjectTag<T, V>::U const GlobalObjectTag<T, V>::tag = { V };

template <class T>
struct GlobalObjectTagFromPtr {
	template <T P> static inline GlobalObjectTag<T, P> make() { return GlobalObjectTag<T, P>(); }
};
template <class T> GlobalObjectTagFromPtr<T*> inline GlobalObjectTagFromVal(T*) { return GlobalObjectTagFromPtr<T*>(); }
template <class T, class C> GlobalObjectTagFromPtr<T (C::*)> inline GlobalObjectTagFromVal(T (C::*)) { return GlobalObjectTagFromPtr<T (C::*)>(); }

#define UEI(v) &(::ui::GlobalObjectTagFromVal(v).template make<v>().tag)

struct UniqueElementIdentifier
{
	uintptr_t value;
	UniqueElementIdentifier(void const volatile* ptr)
		: value(reinterpret_cast<uintptr_t>(ptr)) { }
	UniqueElementIdentifier(uintptr_t value)
		: value(value) { }

	bool operator ==(UniqueElementIdentifier const& r) const { return value == r.value; }
};

struct Mouse
{
	bool primary, primaryChanged;
	bool secondary, secondaryChanged;
	glm::ivec2 pos;
};

struct Cursor
{
	int row;
	int column;
	glm::ivec2 pos;
};

struct InputKeys
{
	static unsigned const KeyStart		= 0x80000000;

	static unsigned const ManipKeyMask	= 0x81000000;
	static unsigned const DeleteLast	= ManipKeyMask + 0;
	static unsigned const DeleteNext	= ManipKeyMask + 1;

	static unsigned const NavKeyMask	= 0x82000000;
	static unsigned const MoveUp		= NavKeyMask;
	static unsigned const MoveDown		= NavKeyMask + 1;
	static unsigned const MoveLeft		= NavKeyMask + 2;
	static unsigned const MoveRight		= NavKeyMask + 3;
};

struct CaptureState
{
	enum T
	{
		Available,
		Owned,
		Unavailable
	};
};

struct TextUi
{
	struct Options
	{
		unsigned indent, lineHeight;
		int labelDelta, controlBaseline;

		explicit Options(unsigned lineHeight = 24, unsigned indent = 3, int labelDelta = 24, int controlBaseline = -3) 
			: indent(indent)
			, lineHeight(lineHeight)
			, labelDelta(labelDelta)
			, controlBaseline(controlBaseline) { }
	} options;

	UiRenderer* uiRenderer;
	TextRenderer* textRenderer;
	
	Mouse mouse;
	Cursor cursor;

	std::vector<UniqueElementIdentifier> capturePath;
	std::vector<UniqueElementIdentifier> entryPath;
	std::vector<UniqueElementIdentifier> focusPath;

	TextUi(UiRenderer* uiRenderer, TextRenderer* textRenderer, Options options = Options())
		: uiRenderer(uiRenderer)
		, textRenderer(textRenderer)
		, options(options)
	{
		cursor.row = 0;
		cursor.column = -1;
	}
	
	void reset()
	{
		if (!mouse.primary && !mouse.secondary)
			capturePath.clear();
		// todo: make value-sensitive
		if (cursor.column < -1)
			cursor.column = -1;
		if (cursor.row < 0)
			cursor.row = 0;
	}

	void capture(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id)
	{
		capturePath.assign(path.begin(), path.end());
		capturePath.push_back(id);
	}
	CaptureState::T captureState(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id) const
	{
		if (capturePath.empty())
			return CaptureState::Available;
		else if (capturePath.size() - 1 == path.size() && capturePath.back() == id && std::equal(path.begin(), path.end(), capturePath.data()))
			return CaptureState::Owned;
		else
			return CaptureState::Unavailable;
	}
	bool capturedOrAcquired(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id, bool acquire)
	{
		auto state = captureState(path, id);
		if (acquire && state == CaptureState::Available)
		{
			capture(path, id);
			return true;
		}
		else
			return (state == CaptureState::Owned);
	}

	struct Renderer
	{
		TextUi *ui;
	
		glm::ivec2 insertBegin;
		glm::ivec2 insertEnd;

		bool cursorVisible;
		std::vector<unsigned> pendingInput;

		std::vector<UniqueElementIdentifier> pathStack;

		glm::ivec2 insertPos;
		int insertLine;
		unsigned pendingIndent;

		Renderer(TextUi* ui, glm::ivec2 insertPos, glm::uvec2 insertFrame)
			: ui(ui)
			, insertBegin(insertPos)
			, insertEnd(insertPos + glm::ivec2(insertFrame))
			, cursorVisible(true)
			, insertPos(insertPos)
			, insertLine(0)
			, pendingIndent(0)
		{
		}

		size_t addInput(stdx::data_range_param<unsigned const> queue)
		{
			auto& cursor = ui->cursor;

			auto it = queue.begin(), itEnd = queue.end();
			for (; it < itEnd && (*it & InputKeys::NavKeyMask) == InputKeys::NavKeyMask; ++it)
				switch (*it)
				{
				case InputKeys::MoveDown: ++cursor.row; break;
				case InputKeys::MoveUp: --cursor.row; break;
				case InputKeys::MoveLeft: --cursor.column; break;
				case InputKeys::MoveRight: ++cursor.column; break;
				}

			// todo: make value-sensitive during draw/interact
			if (cursor.column < -1)
				cursor.column = -1;
			if (cursor.row < 0)
				cursor.row = 0;

			for (; it < itEnd && (*it & InputKeys::NavKeyMask) != InputKeys::NavKeyMask; ++it)
				pendingInput.push_back(*it);

			return it - queue.begin();
		}

		void pushGroup(UniqueElementIdentifier id)
		{
			pathStack.push_back(id);

			pendingIndent += ui->options.indent;
		}
		void popGroup(UniqueElementIdentifier id)
		{
			assert(!pathStack.empty() && id == pathStack.back());
			pathStack.pop_back();

			if (pendingIndent >= ui->options.indent)
				pendingIndent -= ui->options.indent;
			else
				insertPos.x -= ui->options.indent;
		}
		void nextLine()
		{
			insertPos.x += pendingIndent;
			pendingIndent = 0;
			insertPos.y += ui->options.lineHeight;
			++insertLine;
		}

		void maybeDrawCursor(glm::ivec2 valuePos, char const* value)
		{
			if (insertLine == ui->cursor.row)
				drawCursor(valuePos, value);
		}
		void drawCursor(glm::ivec2 valuePos, char const* value)
		{
			auto cursorPos = insertPos;
			if (ui->cursor.column >= 0)
			{
				cursorPos = valuePos;
				if (ui->cursor.column > 0)
					cursorPos.x = ui->textRenderer->boundText(value, ui->cursor.column, valuePos).max.x;
			}
			else
				cursorPos.x -= ui->options.labelDelta / 3;
			
			if (cursorVisible)
				ui->textRenderer->drawText(cursorPos, "_");

			ui->cursor.pos = cursorPos;
		}

		void addLabel(char const* label)
		{
			auto treePos = insertPos;
			treePos.x -= ui->options.labelDelta * 3 / 4;
//			treePos.y -= ui->options.lineHeight / 4;

			static unsigned short const arrow[3] = { '\\', '-' };
			static unsigned short const entry[3] = { '|', '-' };
			ui->textRenderer->drawText(treePos, (pendingIndent) ? arrow : entry);
			
			auto labelPos = insertPos;
			labelPos.x -= ui->textRenderer->boundText(label).max.x + ui->options.labelDelta;
			ui->textRenderer->drawText(labelPos, label);
		}

		template <class Value>
		struct Interaction
		{
			virtual void updateValue(Value const& value) = 0;
		};
		template <class Value>
		struct ValueInteraction : Interaction<Value>
		{
			Value* value;
			ValueInteraction(nullptr_t) { }
			ValueInteraction(Value& value)
				: value(&value) { }
			void updateValue(Value const& value) override {
				*this->value = value; }
		};
		template <class Value>
		struct InteractionParam
		{
			Interaction<Value>* ptr;
			InteractionParam(nullptr_t) : ptr() { }
			InteractionParam(Value& value, ValueInteraction<Value>& interaction = ValueInteraction<Value>(nullptr))
				: ptr(&interaction) { interaction = ValueInteraction<Value>(value); }
		};

		std::vector<char> editText(UniqueElementIdentifier id, char const* text, unsigned& textCursor) const
		{
			auto textLen = strlen(text);
			textCursor = std::min(textCursor, (unsigned) textLen);
			
			std::vector<char> newText(textLen + pendingInput.size() + 1);
			std::copy_n(text, textCursor, newText.data());

			auto headCursor = textCursor;
			auto tailCursor = textCursor;

			for (auto chr : pendingInput)
			{
				if (chr < InputKeys::KeyStart)
					newText[headCursor++] = (char) chr; // todo: utf-8
				else if (chr == InputKeys::DeleteLast && textCursor > 0)
					--headCursor;
				else if (chr == InputKeys::DeleteNext)
					++tailCursor;
			}

			size_t newTextLen = headCursor + (tailCursor < textLen ? textLen - tailCursor : 0);
			std::copy_n(text + tailCursor, newTextLen - headCursor, newText.data() + headCursor);
			newText[newTextLen] = 0;
			newText.resize(newTextLen);

			textCursor = headCursor;
			return newText;
		}
		template <class Func>
		void maybeEditText(UniqueElementIdentifier id, char const* text, Func&& func)
		{
			auto& cursor = ui->cursor;
			if (!pendingInput.empty() && cursor.row == insertLine && cursor.column >= 0)
			{
				unsigned newCursor = cursor.column;
				
				auto newText = editText(id, text, newCursor);
				func(newText.data());
				
				cursor.column = (int) newCursor;
			}
		}

		void addText(UniqueElementIdentifier id, char const* label, char const* text, bool editable)
		{
			addLabel(label);

			auto valBox = ui->textRenderer->drawText(insertPos, text);
			maybeDrawCursor(insertPos, text);

			auto& mouse = ui->mouse;
			if ((mouse.primary || mouse.secondary) && in_aabb(mouse.pos, valBox))
			{
				size_t newCol;
				ui->textRenderer->selectChar(mouse.pos, newCol, insertPos, text);
				if (newCol != ~0)
				{
					// todo: delay, might double input otherwise
					ui->cursor.row = insertLine;
					ui->cursor.column = (int) newCol;
				}
			}

			nextLine();
		}

		struct Slider
		{
			UniqueElementIdentifier id;
			glm::aabb<glm::ivec2> rect;
			float value;
			float range;
			float valueBase;
		};
		Slider addSlider(UniqueElementIdentifier id, char const* label, float value, float range, InteractionParam<float> interact)
		{
			addLabel(label);

			char numBuf[32];
			sprintf(numBuf, "%f", value);
			auto* num = (numBuf[0] == '0') ? &numBuf[1] : numBuf;
			
			auto valBox = ui->textRenderer->boundText(num);
			
			unsigned sliderPadding = 6;
			unsigned sliderBarInset = 3;

			auto sliderPos = insertPos;
			sliderPos.y += valBox.min.y - sliderPadding; 
			auto sliderSize = glm::uvec2(valBox.max - valBox.min) + glm::uvec2(2 * sliderPadding);
			sliderSize.x = std::max((int) sliderSize.x, (int) insertEnd.x - insertPos.x);
			ui->uiRenderer->drawWidget(sliderPos, sliderSize, ui::UiElement::Frame);
			
			auto barPos = sliderPos + glm::ivec2(sliderBarInset);
			auto barSize = sliderSize - glm::uvec2(2 * sliderBarInset);
			auto barEnd = barPos + glm::ivec2(barSize);
			float relativeValue = value / range;
			float relativeValueBase = floor(relativeValue);
			barSize.x = unsigned((relativeValue - relativeValueBase) * (float) barSize.x);
			ui->uiRenderer->drawWidget(barPos, barSize, ui::UiElement::Bar);

			auto valPos = insertPos;
			valPos.x += (sliderSize.x - valBox.max.x) / 2;
			valBox = ui->textRenderer->drawText(valPos, num);
			maybeDrawCursor(valPos, num);
			
			auto& mouse = ui->mouse;
			if ((mouse.primary || mouse.secondary) && in_aabb(mouse.pos, valBox))
			{
				size_t newCol;
				ui->textRenderer->selectChar(mouse.pos, newCol, valPos, num);
				if (newCol != ~0)
				{
					// todo: delay, might double input otherwise
					ui->cursor.row = insertLine;
					ui->cursor.column = (int) newCol;
				}
			}

			if (interact.ptr)
				maybeEditText(id, num, [&](char const* newText)
				{
					float newVal = value;
					if (sscanf(newText, "%f", &newVal) == 1)
						interact.ptr->updateValue(newVal);
				});

			nextLine();

			Slider slider = { id, { barPos, barEnd }, value, range, relativeValueBase * range };
			
			if (interact.ptr)
			{
				if (mouse.primary && ui->capturedOrAcquired(pathStack, slider.id, mouse.primaryChanged && glm::in_aabb(mouse.pos, slider.rect)))
					interact.ptr->updateValue(
						  slider.valueBase
						+ float(mouse.pos.x - slider.rect.min.x) / float(slider.rect.max.x - slider.rect.min.x) * slider.range
						);
			}
			
			return slider;
		}
	};
};

struct TextUiGroup : stdx::noncopyable
{
	UniqueElementIdentifier id;
	TextUi::Renderer* ui;

	TextUiGroup(nullptr_t) : id(nullptr), ui(nullptr) { }
	TextUiGroup(TextUi::Renderer& ui, UniqueElementIdentifier id) : id(id), ui(&ui) { ui.pushGroup(id); }
	TextUiGroup(TextUiGroup&& right) : id(right.id), ui(right.ui) { right.id = nullptr; right.ui = nullptr; }
	~TextUiGroup() { if (ui) ui->popGroup(id); }

	TextUiGroup& operator =(TextUiGroup&& right)
	{
		id = right.id; ui = right.ui;
		right.id = nullptr; right.ui = nullptr;
		return *this;
	}
};

} // namespace
