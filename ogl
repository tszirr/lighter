#pragma once

#include "oglbase"
#include <glfw/glfw3.h>

#include "stdx"
#include "file"

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
#include <functional>

#ifndef OGL_COMPATIBILITY_PREPROCESSING
	#define OGL_COMPATIBILITY_PREPROCESSING true
#endif

namespace ogl
{

struct GLFW : stdx::noncopyable
{
	static GLFW*& instance();

	static void errorCallback(int error, const char* description);

	GLFW(int major, int minor, bool coreProfile = false, bool debug = true)
	{
		if (instance())
			throwx( ogl_error("GLFW has already been initialized!") );

		glfwSetErrorCallback(errorCallback);

		if (!glfwInit())
			throwx( ogl_error("Failed to init glfw!") );

		glfwDefaultWindowHints();
		configureGl(major, minor, coreProfile, debug);

		instance() = this;
	}
	~GLFW()
	{
		glfwTerminate();

		instance() = nullptr;
	}
	
	void configureGl(int major, int minor, bool coreProfile = false, bool debug = true)
	{
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, major);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, minor);
		glfwWindowHint(GLFW_SRGB_CAPABLE, GL_TRUE);
		glfwWindowHint(GLFW_OPENGL_PROFILE, (coreProfile) ? GLFW_OPENGL_CORE_PROFILE : GLFW_OPENGL_COMPAT_PROFILE);
		if (debug)
			glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);
	}
	void enableVSync(bool enable)
	{
		glfwSwapInterval((int) enable);
	}
	
	static void APIENTRY debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

	void enableDebugMessages()
	{
		glEnable(GL_DEBUG_OUTPUT);
		glGetError();
		glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
		glGetError();
		if (glDebugMessageControl)
			glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_TRUE);
		if (glDebugMessageCallback)
			glDebugMessageCallback(&GLFW::debugCallback, NULL);
	}
};

struct GLEW : stdx::noncopyable
{
	GLEW()
	{
		// see http://www.opengl.org/wiki/OpenGL_Loading_Library
		glewExperimental = GL_TRUE;
		auto err = glewInit();
		if (GLEW_OK != err)
			throwx( std::runtime_error((char const*) glewGetErrorString(err)) );
		while (glGetError() != GL_NO_ERROR);
	}
};

struct TrackedGLFWWindow : stdx::fun_delete<GLFWwindow*, glfwDestroyWindow>::handle_type
{
	explicit TrackedGLFWWindow(GLFWwindow* wnd = nullptr) throw()
		: unique_handle(wnd)
	{
		registerThis();
	}
	TrackedGLFWWindow(TrackedGLFWWindow &&right) throw()
		: unique_handle(std::move(right))
	{
		registerThis();
	}
	TrackedGLFWWindow& operator =(TrackedGLFWWindow &&right) throw()
	{
		this->swap(right);
		return *this;
	}

	void reset(GLFWwindow* wnd = nullptr) throw()
	{
		unique_handle::reset(wnd);
		registerThis();
	}
	GLFWwindow* release() throw()
	{
		unregisterThis();
		return unique_handle::release();
	}
	void swap(TrackedGLFWWindow& right) throw()
	{
		unique_handle::swap(right);
		registerThis();
		right.registerThis();
	}

	void registerThis() throw()
	{
		if (valid())
			glfwSetWindowUserPointer(*this, this);
	}
	void unregisterThis() throw()
	{
		if (valid())
			glfwSetWindowUserPointer(*this, nullptr);
	}
	template <class GLFWWindow>
	static GLFWWindow* getThis(GLFWwindow* wnd)
	{
		return static_cast<GLFWWindow*>( static_cast<TrackedGLFWWindow*>( glfwGetWindowUserPointer(wnd) ) );
	}
};

struct GLFWWindow : TrackedGLFWWindow
{
	MOVE_GENERATE(GLFWWindow, MOVE_6, BASE, TrackedGLFWWindow
		, MEMBER, resize, MEMBER, keyboard, MEMBER, text, MEMBER, mouse, MEMBER, buttons)

	static void resizeCallback(GLFWwindow *window, int w, int h);
	static void keyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);
	static void textCallback(GLFWwindow *window, unsigned chr);
	static void mouseCallback(GLFWwindow *window, double x, double y);
	static void buttonsCallback(GLFWwindow *window, int button, int action, int mods);

	std::function<void (unsigned w, unsigned h)> resize;
	std::function<void (int key, bool pressed, bool repeat)> keyboard;
	std::function<void (unsigned)> text;
	std::function<void (int x, int y)> mouse;
	std::function<void (int button, bool pressed)> buttons;

	GLFWWindow(int w, int h, char const *title, GLFWmonitor *monitor = glfwGetPrimaryMonitor(), GLFWwindow *share = nullptr)
		: TrackedGLFWWindow( glfwCreateWindow(w, h, title, monitor, share) )
	{
		if (!valid()) throwx( ogl_error("Failed to create glfw window!") );
		glfwSetFramebufferSizeCallback(*this, resizeCallback);
		glfwSetKeyCallback(*this, keyCallback);
		glfwSetCharCallback(*this, textCallback);
		glfwSetCursorPosCallback(*this, mouseCallback);
		glfwSetMouseButtonCallback(*this, buttonsCallback);
	}

	void makeCurrent()
	{
		glfwMakeContextCurrent(*this);
	}

	void swapBuffers()
	{
		glfwSwapBuffers(*this);
	}

	bool shouldClose() const
	{
		return glfwWindowShouldClose(*this) != 0;
	}

	void initialResize()
	{
		if (resize)
		{
			int w, h;
			glfwGetFramebufferSize(*this, &w, &h);
			resize((unsigned) w, (unsigned) h);
		}
	}
};

struct Buffer : glew_delete<GLuint, glDeleteBuffers>::handle_type
{
	MOVE_BASE(Buffer, unique_handle)

	Buffer(std::nullptr_t) { }
	Buffer()
	{
		glGenBuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenBuffers()");
	}

	void bind(GLenum bufferType)
	{
		glBindBuffer(bufferType, *this);
	}

	static void unbind(GLenum bufferType)
	{
		glBindBuffer(bufferType, 0);
	}

	void bind(GLenum bufferType, unsigned slot)
	{
		glBindBufferBase(bufferType, slot, *this);
	}

	static void unbind(GLenum bufferType, unsigned slot)
	{
		glBindBufferBase(bufferType, slot, 0);
	}

	static Buffer create(GLenum bufferType, size_t size, void const* data = nullptr, GLenum usage = GL_STATIC_DRAW)
	{
		Buffer result;
		result.bind(bufferType);

		glBufferData(bufferType, size, data, usage);
		THROW_OPENGL_LASTERROR("glBufferData()");

		return result;
	}

	template <class Range>
	static Buffer init(GLenum bufferType, Range const& range, GLenum usage = GL_STATIC_DRAW)
	{
		return create(bufferType, sizeof(*range.data()) * range.size(), range.data(), usage);
	}
	template <class Range>
	void write(GLenum bufferType, Range const& range, size_t destOffset = 0)
	{
		bind(bufferType);
		glBufferSubData(bufferType, sizeof(*range.data()) * destOffset, sizeof(*range.data()) * range.size(), range.data());
		THROW_OPENGL_LASTERROR("glBufferSubData()");
	}
	template <class Range>
	void read(GLenum bufferType, Range const& range, size_t srcOffset = 0)
	{
		bind(bufferType);
		glGetBufferSubData(bufferType, sizeof(*range.data()) * srcOffset, sizeof(*range.data()) * range.size(), range.data());
		THROW_OPENGL_LASTERROR("glGetBufferSubData()");
	}
};

inline size_t computeMipLevelCount(size_t dim)
{
	size_t c = 1;
	for (; dim > 1; dim = dim >> 1)
		++c;
	return c;
}

inline bool is3DTexture(GLenum textureType) {
	return (textureType == GL_TEXTURE_3D); }

struct Texture : gl_delete<GLuint, glDeleteTextures>::handle_type
{
	MOVE_BASE(Texture, unique_handle)

	Texture(std::nullptr_t) { }
	Texture()
	{
		glGenTextures(1, rebind());
		THROW_OPENGL_LASTERROR("glGenTextures()");
	}

	void bind(GLenum textureType, unsigned slot = 0)
	{
		glActiveTexture((GLenum) (GL_TEXTURE0 + slot));
		glBindTexture(textureType, *this);
	}

	static void unbind(GLenum textureType, unsigned slot = 0)
	{
		glActiveTexture((GLenum) (GL_TEXTURE0 + slot));
		glBindTexture(textureType, 0);
	}

	static Texture create2D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t levels = 1
		, void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED)
	{
		return create3D(textureType, internalFormat, width, height, 0, levels, data, dataType, dataFormat);
	}

	static Texture create3D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t depth, size_t levelsOrGen = 1
		, void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED)
	{
		Texture result;
		result.bind(textureType);

		size_t levels = (levelsOrGen >= 1U) ? levelsOrGen : computeMipLevelCount(std::max(std::max(width, height), depth));

		glTexParameteri(textureType, GL_TEXTURE_MAG_FILTER, (levels == 1) ? GL_NEAREST : GL_LINEAR);
		glTexParameteri(textureType, GL_TEXTURE_MIN_FILTER, (levels == 1) ? GL_NEAREST_MIPMAP_NEAREST : GL_LINEAR_MIPMAP_LINEAR);
		auto defaultWrapMode = (levels == 1) ? GL_CLAMP_TO_EDGE : GL_REPEAT;
		glTexParameteri(textureType, GL_TEXTURE_WRAP_S, defaultWrapMode);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_T, defaultWrapMode);
		if (depth > 0)
			glTexParameteri(textureType, GL_TEXTURE_WRAP_R, defaultWrapMode);
		THROW_OPENGL_LASTERROR("glTexParameteri()");

		if (depth == 0) {
			glTexStorage2D(textureType, (GLsizei) levels, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glTexStorage2D()");
		}
		else {
			glTexStorage3D(textureType, (GLsizei) levels, internalFormat, (GLsizei) width, (GLsizei) height, (GLsizei) depth);
			THROW_OPENGL_LASTERROR("glTexStorage3D()");
		}

		glTexParameteri(textureType, GL_TEXTURE_BASE_LEVEL, 0);
		glTexParameteri(textureType, GL_TEXTURE_MAX_LEVEL, (int) levels - 1);
		THROW_OPENGL_LASTERROR("glTexParameteri()");

		if (data)
		{
			result.write(textureType, 0, data, dataType, dataFormat, width, height, depth);

			if (levelsOrGen == 0)
				result.genMipMaps(textureType);
		}

		return result;
	}

	void filterMode(GLenum textureType, GLint min, GLint mag)
	{
		bind(textureType);
		glTexParameteri(textureType, GL_TEXTURE_MAG_FILTER, mag);
		glTexParameteri(textureType, GL_TEXTURE_MIN_FILTER, min);
		THROW_OPENGL_LASTERROR("glTexParameteri()");
	}
	void filterNearest(GLenum textureType) { filterMode(textureType, GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST); }
	void filterLinear(GLenum textureType) { filterMode(textureType, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);  }

	void wrapMode(GLenum textureType, GLint mode)
	{
		bind(textureType);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_S, mode);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_T, mode);
		if (is3DTexture(textureType))
			glTexParameteri(textureType, GL_TEXTURE_WRAP_R, mode);
		THROW_OPENGL_LASTERROR("glTexParameteri()");
	}
	void wrapRepeat(GLenum textureType) { wrapMode(textureType, GL_REPEAT); }
	void wrapClamp(GLenum textureType) { wrapMode(textureType, GL_CLAMP_TO_EDGE); }

	void write(GLenum textureType, size_t level
		, void const* data, GLenum dataType, GLenum dataFormat
		, size_t width, size_t height, size_t depth = 0
		, size_t offsetX = 0, size_t offsetY = 0, size_t offsetZ = 0)
	{
		bind(textureType);

		if (depth == 0) {
			glTexSubImage2D(textureType, (GLsizei) level, (GLsizei) offsetX, (GLsizei) offsetY
				, (GLsizei) width, (GLsizei) height
				, dataFormat, dataType, data);
			THROW_OPENGL_LASTERROR("glTexSubImage2D()");
		}
		else {
			glTexSubImage3D(textureType, (GLsizei) level, (GLsizei) offsetX, (GLsizei) offsetY, (GLsizei) offsetZ
				, (GLsizei) width, (GLsizei) height, (GLsizei) depth
				, dataFormat, dataType, data);
			THROW_OPENGL_LASTERROR("glTexSubImage3D()");
		}
	}

	void genMipMaps(GLenum textureType)
	{
		bind(textureType);
		glGenerateMipmap(textureType);
		THROW_OPENGL_LASTERROR("glGenerateMipmap()");
	}
};

struct Sampler : glew_delete<GLuint, glDeleteSamplers>::handle_type
{
	MOVE_BASE(Sampler, unique_handle)

	Sampler(std::nullptr_t) { }
	Sampler()
	{
		glGenSamplers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenSamplers()");
	}

	void bind(unsigned slot = 0)
	{
		glBindSampler(slot, *this);
	}

	static void unbind(unsigned slot = 0)
	{
		glBindSampler(slot, 0);
	}

	static Sampler createLinear(GLint wrapMode = GL_REPEAT, GLint min = GL_LINEAR_MIPMAP_LINEAR, GLint mag = GL_LINEAR)
	{
		Sampler r;
		r.filterMode(min, mag);
		r.wrapMode(wrapMode);
		return r;
	}
	static Sampler createNearest(GLint wrapMode = GL_REPEAT, GLint min = GL_NEAREST_MIPMAP_NEAREST, GLint mag = GL_NEAREST)
	{
		Sampler r;
		r.filterMode(min, mag);
		r.wrapMode(wrapMode);
		r.anisotropy(1);
		return r;
	}

	void filterMode(GLint min, GLint mag)
	{
		glSamplerParameteri(*this, GL_TEXTURE_MAG_FILTER, mag);
		glSamplerParameteri(*this, GL_TEXTURE_MIN_FILTER, min);
		THROW_OPENGL_LASTERROR("glSamplerParameteri()");
	}
	void filterNearest() { filterMode(GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST); }
	void filterLinear() { filterMode(GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);  }

	void wrapMode(GLint mode)
	{
		glSamplerParameteri(*this, GL_TEXTURE_WRAP_S, mode);
		glSamplerParameteri(*this, GL_TEXTURE_WRAP_T, mode);
		glSamplerParameteri(*this, GL_TEXTURE_WRAP_R, mode);
		THROW_OPENGL_LASTERROR("glSamplerParameteri()");
	}
	void wrapRepeat() { wrapMode(GL_REPEAT); }
	void wrapClamp() { wrapMode(GL_CLAMP_TO_EDGE); }

	void levels(size_t level, size_t count = 1)
	{
		glSamplerParameteri(*this, GL_TEXTURE_BASE_LEVEL, int(level));
		glSamplerParameteri(*this, GL_TEXTURE_MAX_LEVEL, int(level + count - 1));
		THROW_OPENGL_LASTERROR("glSamplerParameteri()");
	}

	void anisotropy(size_t maxAnisotropy)
	{
		glSamplerParameteri(*this, GL_TEXTURE_MAX_ANISOTROPY_EXT, int(maxAnisotropy));
		THROW_OPENGL_LASTERROR("glSamplerParameteri()");
	}
};

struct RenderBuffer : glew_delete<GLuint, glDeleteRenderbuffers>::handle_type
{
	MOVE_BASE(RenderBuffer, unique_handle)

	RenderBuffer(std::nullptr_t) { }
	RenderBuffer()
	{
		glGenRenderbuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenRenderbuffers()");
	}

	void bind()
	{
		glBindRenderbuffer(GL_RENDERBUFFER, *this);
	}

	static void unbind()
	{
		glBindRenderbuffer(GL_RENDERBUFFER, 0);
	}

	static RenderBuffer create(GLenum internalFormat, size_t width, size_t height, size_t samples = 1)
	{
		RenderBuffer result;
		result.bind();

		if(samples > 1)
		{
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, (GLsizei) samples, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glRenderbufferStorageMultisample()");
		}
		else
		{
			glRenderbufferStorage(GL_RENDERBUFFER, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glRenderbufferStorage()");
		}

		return result;
	}
};

template <class Resource>
struct AutoTarget : Resource
{
	MOVE_GENERATE(AutoTarget, MOVE_2, BASE, Resource, MEMBER, target)

	using Resource::operator =;

	GLenum target;

	AutoTarget(GLenum target, Resource resource)
		: Resource(std::move(resource))
		, target(target) { }

	void bind()
	{
		Resource::bind(target);
	}

	void unbind()
	{
		Resource::unbind(target);
	}

	void bind(unsigned slot)
	{
		Resource::bind(target, slot);
	}

	void unbind(unsigned slot)
	{
		Resource::unbind(target, slot);
	}
};

template <class R>
inline AutoTarget<R> auto_target(GLenum target, R resource) { return AutoTarget<R>(target, std::move(resource)); }

struct VertexArrays : glew_delete<GLuint, glDeleteVertexArrays>::handle_type
{
	MOVE_BASE(VertexArrays, unique_handle)

	VertexArrays(std::nullptr_t) { }
	VertexArrays()
	{
		glGenVertexArrays(1, rebind());
		THROW_OPENGL_LASTERROR("glGenVertexArrays()");
	}

	void bind()
	{
		glBindVertexArray(*this);
	}

	static void unbind()
	{
		glBindVertexArray(0);
	}
};

struct Framebuffer : glew_delete<GLuint, glDeleteFramebuffers>::handle_type
{
	MOVE_BASE(Framebuffer, unique_handle)

	Framebuffer(std::nullptr_t) { }
	Framebuffer()
	{
		glGenFramebuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenFramebuffers()");
	}

	void bind(GLenum target = GL_FRAMEBUFFER)
	{
		glBindFramebuffer(target, *this);
	}
	static void unbind(GLenum target = GL_FRAMEBUFFER)
	{
		glBindFramebuffer(target, 0);
	}

	static Framebuffer create(GLuint const* textures, size_t textureCount, GLuint depthBuffer = 0)
	{
		Framebuffer result;
		result.bind();

		std::vector<GLenum> attachmentMapping(textureCount);

		for (size_t i = 0; i < textureCount; ++i)
		{
			GLenum attachment = (GLenum) (GL_COLOR_ATTACHMENT0 + i);
			glFramebufferTexture(GL_FRAMEBUFFER, attachment, textures[i], 0);
			THROW_OPENGL_LASTERROR("glFramebufferTexture()");
			attachmentMapping[i] = attachment;
		}

		glReadBuffer(GL_COLOR_ATTACHMENT0);
		glDrawBuffers((GLsizei) attachmentMapping.size(), attachmentMapping.data());

		if (depthBuffer)
		{
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthBuffer);
			THROW_OPENGL_LASTERROR("glFramebufferRenderbuffer()");
		}

		return result;
	}

	static Framebuffer createEmpty(size_t width, size_t height, size_t samples = 1)
	{
		Framebuffer result;
		result.bind();

		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_WIDTH, GLint(width));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_HEIGHT, GLint(height));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_SAMPLES, GLint(samples));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_LAYERS, 0);
		
		return result;
	}

	static Framebuffer default()
	{
		Framebuffer result(nullptr);
		result.reset(0);
		return result;
	}

	static GLuint getAttachement(GLenum attachment, GLenum target = GL_FRAMEBUFFER)
	{
		GLint object;
		glGetFramebufferAttachmentParameteriv(target, attachment, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &object);
		THROW_OPENGL_LASTERROR("glGetFramebufferAttachmentParameteriv()");
		return (GLuint) object;
	}
};

template <class Resource>
struct AutoViewport : Resource
{
	MOVE_GENERATE(AutoViewport, MOVE_5, BASE, Resource, MEMBER, x, MEMBER, y, MEMBER, width, MEMBER, height)

	using Resource::operator =;

	GLint x;
	GLint y;
	GLint width;
	GLint height;

	AutoViewport(nullptr_t) : Resource(nullptr) { }
	AutoViewport(Resource resource, GLint width, GLint height, GLint x = 0, GLint y = 0)
		: Resource(std::move(resource))
		, x(x)
		, y(y)
		, width(width)
		, height(height)
	{ }

	void bind(GLenum target = GL_FRAMEBUFFER)
	{
		Resource::bind(target);
		glViewport(x, y, width, height);
	}
};

template <class R>
inline AutoViewport<R> auto_viewport(R resource, GLint width, GLint height, GLint x = 0, GLint y = 0) {
	return AutoViewport<R>(std::move(resource), width, height, x, y); }

struct Shader : glew_delete_single<GLuint, glDeleteShader>::handle_type
{
	MOVE_BASE(Shader, unique_handle)

	Shader(std::nullptr_t) { }
	explicit Shader(GLenum shaderType)
	{
		reset( glCreateShader(shaderType) );
		THROW_OPENGL_LASTERROR("glCreateShader()");
	}

	static Shader compile(GLenum shaderType, char const* source, char const* preamble = "")
	{
		Shader result(shaderType);

		char const* shaderTypePreamble;
		switch (shaderType)
		{
		case GL_COMPUTE_SHADER: shaderTypePreamble = "#define cs_main main\n#define IN_CS\n"; break;
		case GL_VERTEX_SHADER: shaderTypePreamble = "#define vs_main main\n#define IN_VS\n#define VERTEX_OUT\n#define VERTEX_OUT_ARRAY\n"; break;
		case GL_FRAGMENT_SHADER: shaderTypePreamble = "#define fs_main main\n#define IN_FS\n#define VERTEX_IN\n#define VERTEX_IN_ARRAY\n"; break;
		case GL_GEOMETRY_SHADER: shaderTypePreamble = "#define gs_main main\n#define IN_GS\n#define VERTEX_IN\n#define VERTEX_IN_ARRAY []\n#define VERTEX_OUT\n#define VERTEX_OUT_ARRAY []\n"; break;
		case GL_TESS_CONTROL_SHADER: shaderTypePreamble = "#define tcs_main main\n#define IN_TCS\n#define VERTEX_IN\n#define VERTEX_IN_ARRAY []\n#define VERTEX_OUT\n#define VERTEX_OUT_ARRAY []\n"; break;
		case GL_TESS_EVALUATION_SHADER: shaderTypePreamble = "#define tes_main main\n#define IN_TES\n#define VERTEX_IN\n#define VERTEX_IN_ARRAY []\n#define VERTEX_OUT\n#define VERTEX_OUT_ARRAY\n"; break;
		default: shaderTypePreamble = "";
		};

		char const* sources[] = { nullptr, nullptr, shaderTypePreamble, preamble, source, nullptr, nullptr };
		int sourceLens[] = { 0, 0, -1, -1, -1, 0, 0 };
		static_assert(arraylen(sourceLens) == arraylen(sources), "strlen array dim mismatch");

		// move version to the beginning
		if (auto versionDir = strstr(source, "#version"))
		{
			sources[0] = versionDir;
			auto endOfVersionDir = strchr(versionDir, '\n');
			sourceLens[0] = (endOfVersionDir) ? int(endOfVersionDir - versionDir) : -1;

			sources[1] = "\n";
			sourceLens[1] = 1;

			sources[4] = source;
			sourceLens[4] = int(versionDir - source);

			sources[5] = "// moved: ";
			sourceLens[5] = -1;

			sources[6] = versionDir;
			sourceLens[6] = -1;
		}

		// Everything that follows minimizes driver incompatibilities
		int sourceCount = 0;
		size_t totalSourceLen = 0;
		for (size_t i = 0; i < arraylen(sources); ++i)
		{
			auto src = sources[i];
			auto srcLen = sourceLens[i];
			if (!src) srcLen = 0;
			if (srcLen < 0) srcLen = (int) strlen(src);
			if (srcLen > 0)
			{
				sources[sourceCount] = src;
				sourceLens[sourceCount] = srcLen;
				++sourceCount;
				totalSourceLen += srcLen;
			}
		}

		// Seriously, nothing works: Concatenate manually
		std::string testSrc;
		testSrc.reserve(totalSourceLen);
		for (int i = 0; i < sourceCount; ++i)
			testSrc.append(sources[i], sources[i] + sourceLens[i]);
		assert(testSrc.size() == totalSourceLen);
		sources[0] = testSrc.c_str();
		sourceLens[0] = (int) totalSourceLen;
		sourceCount = 1;
		// fall back to most common use case
		glShaderSource(result, 1, sources, nullptr);

//		glShaderSource(result, sourceCount, sources, sourceLens);
		THROW_OPENGL_LASTERROR("glShaderSource()");

		glCompileShader(result);
		THROW_OPENGL_LASTERROR("glCompileShader()");

		if (!printBuildLog(result))
			THROW_OPENGL_ERROR(GL_INVALID_OPERATION, "Failed to build OpenGL shader");

		return result;
	}

	static bool printBuildLog(GLuint shader)
	{
		GLint status;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
		THROW_OPENGL_LASTERROR("glGetShaderiv(GL_COMPILE_STATUS)");

		GLint logSize;
		glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logSize);
		THROW_OPENGL_LASTERROR("glGetShaderiv(GL_INFO_LOG_LENGTH)");
		
		if (logSize > 1)
		{
			std::string log(logSize, 0);
			glGetShaderInfoLog(shader, (GLsizei) log.size(), nullptr, &log[0]);
			THROW_OPENGL_LASTERROR("glGetShaderInfoLog()");

			std::cout << ((status) ? "Build info:" : "There were build errors:") << std::endl;
			std::cout << log << std::endl;
		}

		return (status == GL_TRUE);
	}

	static Shader fromFile(GLenum shaderType, char const* file, char const* preamble = "")
	{
		return compile(shaderType, stdx::load_file(file).c_str(), preamble);
	}
};

struct Program : glew_delete_single<GLuint, glDeleteProgram>::handle_type
{
	MOVE_BASE(Program, unique_handle)

	Program(std::nullptr_t) { }
	Program()
	{
		reset( glCreateProgram() );
		THROW_OPENGL_LASTERROR("glCreateProgram()");

		glProgramParameteri(*this, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRUE);
		THROW_OPENGL_LASTERROR("glProgramParameteri(GL_PROGRAM_BINARY_RETRIEVABLE_HINT)");
	}

	void bind()
	{
		glUseProgram(*this);
	}
	static void unbind()
	{
		glUseProgram(0);
	}

	Program& attach(GLuint shader)
	{
		glAttachShader(*this, shader);
		THROW_OPENGL_LASTERROR("glAttachShader()");
		return *this;
	}

	void link()
	{
		glLinkProgram(*this);
		THROW_OPENGL_LASTERROR("glLinkProgram()");
		
		if (!printLinkLog(*this))
			THROW_OPENGL_ERROR(GL_INVALID_OPERATION, "Failed to link OpenGL program");
	}

	std::vector<char> getBinary(GLenum *format = nullptr) const
	{
		std::vector<char> result;
		GLint length;
		glGetProgramiv(*this, GL_PROGRAM_BINARY_LENGTH, &length);
		THROW_OPENGL_LASTERROR("glGetProgramiv()");
		result.resize((size_t) length);
		GLenum formatTmp;
		glGetProgramBinary(*this, (GLsizei) result.size(), &length, &formatTmp, result.data());
		THROW_OPENGL_LASTERROR("glGetProgramBinary()");
		if (format) *format = formatTmp;
		return result;
	}

	static bool printLinkLog(GLuint program)
	{
		GLint status;
		glGetProgramiv(program, GL_LINK_STATUS, &status);
		THROW_OPENGL_LASTERROR("glGetProgramiv(GL_LINK_STATUS)");

		GLint logSize;
		glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logSize);
		THROW_OPENGL_LASTERROR("glGetProgramiv(GL_INFO_LOG_LENGTH)");
		
		if (logSize > 1)
		{
			std::string log(logSize, 0);
			glGetProgramInfoLog(program, (GLsizei) log.size(), nullptr, &log[0]);
			THROW_OPENGL_LASTERROR("glGetProgramInfoLog()");

			std::cout << ((status) ? "Link info:" : "There were linking errors:") << std::endl;
			std::cout << log << std::endl;
		}

		return (status == GL_TRUE);
	}

	static Program fromShaders(GLuint s1, GLuint s2 = 0, GLuint s3 = 0, GLuint s4 = 0, GLuint s5 = 0, GLuint s6 = 0)
	{
		Program result;
		if (s1) result.attach(s1);
		if (s2) result.attach(s2);
		if (s3) result.attach(s3);
		if (s4) result.attach(s4);
		if (s5) result.attach(s5);
		if (s6) result.attach(s6);
		result.link();
		return result;
	}
};

struct ProgramWithTime : Program
{
	enum Options
	{
		Default = 0x00, // Default is FS and VS, nothing else
		NoFS    = 0x01, // Fragment shader off, default ON
		NoVS    = 0x02, // Vertex shader off ...
		HasGS   = 0x04, // Geometry shader on, default OFF
		HasHS   = 0x08, // ...
		HasDS   = 0x10,
		HasCS   = 0x20
	};

	char const* preamble;
	std::string file;
	time_t time;
	unsigned options;
	bool compatibilityInclude;

	using Program::operator =;

	explicit ProgramWithTime(std::string file, char const *preamble = "", unsigned options = Options::Default, bool compatibilityInclude = OGL_COMPATIBILITY_PREPROCESSING)
		: Program(nullptr)
		, preamble(preamble)
		, file(std::move(file))
		, time(0)
		, options( (~options & HasCS) ? options : options | NoVS | NoFS ) // CS is exclusive
		, compatibilityInclude(compatibilityInclude)
	{
		load();
	}
	static std::string resolveIncludesCompat(char const* include, bool local)
	{
		return stdx::process_includes(stdx::load_file(include), include, resolveIncludesCompat, std::string(), true);
	}
	static std::string resolveIncludes(char const* include, bool local)
	{
		return stdx::process_includes(stdx::load_file(include), include, resolveIncludes);
	}
	void load()
	{
		auto& resolveFunc = (compatibilityInclude) ? resolveIncludesCompat : resolveIncludes;
		std::string src = resolveFunc(file.c_str(), true);

		*this = Program::fromShaders(
			!(options & Options::NoFS) ? (GLuint) Shader::compile(GL_FRAGMENT_SHADER, src.c_str(), preamble) : 0,
			!(options & Options::NoVS) ? (GLuint) Shader::compile(GL_VERTEX_SHADER, src.c_str(), preamble) : 0,
			(options & Options::HasGS) ? (GLuint) Shader::compile(GL_GEOMETRY_SHADER, src.c_str(), preamble) : 0,
			(options & Options::HasHS) ? (GLuint) Shader::compile(GL_TESS_CONTROL_SHADER, src.c_str(), preamble) : 0,
			(options & Options::HasDS) ? (GLuint) Shader::compile(GL_TESS_EVALUATION_SHADER, src.c_str(), preamble) : 0,
			(options & Options::HasCS) ? (GLuint) Shader::compile(GL_COMPUTE_SHADER, src.c_str(), preamble) : 0);

		time = stdx::file_time(file.c_str());
	}
	int maybeReload()
	{
		if (stdx::file_time(file.c_str()) > time)
		{
			try { load(); return 1; }
			catch (ogl_error const &) { return -1; }
		}
		return 0;
	}
};

struct Event : glew_delete<GLuint, glDeleteQueries>::handle_type
{
	MOVE_BASE(Event, unique_handle)

	Event(std::nullptr_t) { }
	explicit Event(GLuint event)
		: unique_handle(event) { }
	explicit Event()
	{
		glGenQueries(1, rebind());
		THROW_OPENGL_LASTERROR("Failed to create OGL event");
	}

	void record()
	{
		glQueryCounter(*this, GL_TIMESTAMP);
		THROW_OPENGL_LASTERROR("Failed to record OGL event");
	}
};

inline double diffMS(GLuint startEvent, GLuint endEvent, bool failQuiet = false)
{
	// synchronize
	for (GLint stopTimerAvailable = 0; !stopTimerAvailable; )
		glGetQueryObjectiv(endEvent, GL_QUERY_RESULT_AVAILABLE, &stopTimerAvailable);

	GLuint64 startTime, stopTime;
	glGetQueryObjectui64v(startEvent, GL_QUERY_RESULT, &startTime);
	glGetQueryObjectui64v(endEvent, GL_QUERY_RESULT, &stopTime);

	return double(stopTime - startTime) / 1000000.0;
}

} // namespace
