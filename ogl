#pragma once

#include "oglbase"
#include <glfw/glfw3.h>

#include "stdx"
#include "file"

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
#include <functional>

#ifndef OGL_COMPATIBILITY_PREPROCESSING
	#define OGL_COMPATIBILITY_PREPROCESSING true
#endif

namespace ogl
{

struct GLFW : stdx::noncopyable
{
	static GLFW*& instance();

	static void errorCallback(int error, const char* description);

	GLFW(int major, int minor, bool coreProfile = false, bool debug = true)
	{
		if (instance())
			throwx( ogl_error("GLFW has already been initialized!") );

		glfwSetErrorCallback(errorCallback);

		if (!glfwInit())
			throwx( ogl_error("Failed to init glfw!") );

		glfwDefaultWindowHints();
		configureGl(major, minor, coreProfile, debug);

		instance() = this;
	}
	~GLFW()
	{
		glfwTerminate();

		instance() = nullptr;
	}
	
	void configureGl(int major, int minor, bool coreProfile = false, bool debug = true)
	{
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, major);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, minor);
		glfwWindowHint(GLFW_SRGB_CAPABLE, GL_TRUE);
		glfwWindowHint(GLFW_OPENGL_PROFILE, (coreProfile) ? GLFW_OPENGL_CORE_PROFILE : GLFW_OPENGL_COMPAT_PROFILE);
		if (debug)
			glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);
	}
	void enableVSync(bool enable)
	{
		glfwSwapInterval((int) enable);
	}
	
	static void APIENTRY debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

	void enableDebugMessages()
	{
		glEnable(GL_DEBUG_OUTPUT);
		glGetError();
		glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
		glGetError();
		if (glDebugMessageControl)
			glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_TRUE);
		if (glDebugMessageCallback)
			glDebugMessageCallback(&GLFW::debugCallback, NULL);
	}
};

struct GLEW : stdx::noncopyable
{
	GLEW()
	{
		// see http://www.opengl.org/wiki/OpenGL_Loading_Library
		glewExperimental = GL_TRUE;
		auto err = glewInit();
		if (GLEW_OK != err)
			throwx( std::runtime_error((char const*) glewGetErrorString(err)) );
		while (glGetError() != GL_NO_ERROR);
	}
};

struct GLFWWindow : stdx::noncopyable
{
	void registerThis() throw();
	void unregisterThis() throw();

	static void resizeCallback(GLFWwindow *window, int w, int h);
	static void keyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);
	static void textCallback(GLFWwindow *window, unsigned chr);
	static void mouseCallback(GLFWwindow *window, double x, double y);
	static void buttonsCallback(GLFWwindow *window, int button, int action, int mods);

	stdx::unique_handle<GLFWwindow*> window;
	TRANSPARENT_MEMBER(GLFWWindow, window)

	std::function<void (unsigned w, unsigned h)> resize;
	std::function<void (int key, bool pressed, bool repeat)> keyboard;
	std::function<void (unsigned)> text;
	std::function<void (int x, int y)> mouse;
	std::function<void (int button, bool pressed)> buttons;

	GLFWWindow(int w, int h, char const *title, GLFWmonitor *monitor = glfwGetPrimaryMonitor(), GLFWwindow *share = nullptr)
	{
		window.reset( glfwCreateWindow(w, h, title, monitor, share) );
		if (!window.valid())
			throwx( ogl_error("Failed to create glfw window!") );
		glfwSetFramebufferSizeCallback(window, resizeCallback);
		glfwSetKeyCallback(window, keyCallback);
		glfwSetCharCallback(window, textCallback);
		glfwSetCursorPosCallback(window, mouseCallback);
		glfwSetMouseButtonCallback(window, buttonsCallback);

		registerThis();
	}
	~GLFWWindow()
	{
		if (window.valid())
		{
			glfwDestroyWindow(window);
			unregisterThis();
		}
	}
	GLFWWindow(GLFWWindow &&right)
		: window(std::move(right.window))
		, resize(std::move(right.resize))
		, keyboard(std::move(right.keyboard))
		, text(std::move(right.text))
		, mouse(std::move(right.mouse))
		, buttons(std::move(right.buttons))
	{
		registerThis();
	}
	GLFWWindow& operator =(GLFWWindow &&right)
	{
		std::swap(window, right.window);
		std::swap(resize, right.resize);
		std::swap(keyboard, right.keyboard);
		std::swap(text, right.text);
		std::swap(mouse, right.mouse);
		std::swap(buttons, right.buttons);

		registerThis();
		right.registerThis();

		return *this;
	}

	void makeCurrent()
	{
		glfwMakeContextCurrent(window);
	}

	void swapBuffers()
	{
		glfwSwapBuffers(window);
	}

	bool shouldClose() const
	{
		return glfwWindowShouldClose(window) != 0;
	}

	void initialResize()
	{
		if (resize)
		{
			int w, h;
			glfwGetFramebufferSize(window, &w, &h);
			resize((unsigned) w, (unsigned) h);
		}
	}
};

struct Buffer : glew_delete<GLuint, glDeleteBuffers>::handle_type
{
	MOVE_BASE(Buffer, unique_handle)

	Buffer(nullptr_t) { }
	Buffer()
	{
		glGenBuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenBuffers()");
	}

	void bind(GLenum bufferType)
	{
		glBindBuffer(bufferType, *this);
	}

	static void unbind(GLenum bufferType)
	{
		glBindBuffer(bufferType, 0);
	}

	void bind(GLenum bufferType, unsigned slot)
	{
		glBindBufferBase(bufferType, slot, *this);
	}

	static void unbind(GLenum bufferType, unsigned slot)
	{
		glBindBufferBase(bufferType, slot, 0);
	}

	static Buffer create(GLenum bufferType, size_t size, void const* data = nullptr, GLenum usage = GL_STATIC_DRAW)
	{
		Buffer result;
		result.bind(bufferType);

		glBufferData(bufferType, size, data, usage);
		THROW_OPENGL_LASTERROR("glBufferData()");

		return result;
	}

	template <class Range>
	static Buffer init(GLenum bufferType, Range const& range, GLenum usage = GL_STATIC_DRAW)
	{
		return create(bufferType, sizeof(*range.data()) * range.size(), range.data(), usage);
	}
	template <class Range>
	void write(GLenum bufferType, Range const& range, size_t destOffset = 0)
	{
		bind(bufferType);
		glBufferSubData(bufferType, sizeof(*range.data()) * destOffset, sizeof(*range.data()) * range.size(), range.data());
		THROW_OPENGL_LASTERROR("glBufferSubData()");
	}
	template <class Range>
	void read(GLenum bufferType, Range const& range, size_t srcOffset = 0)
	{
		bind(bufferType);
		glGetBufferSubData(bufferType, sizeof(*range.data()) * srcOffset, sizeof(*range.data()) * range.size(), range.data());
		THROW_OPENGL_LASTERROR("glGetBufferSubData()");
	}
};

struct Texture : gl_delete<GLuint, glDeleteTextures>::handle_type
{
	MOVE_BASE(Texture, unique_handle)

	Texture(nullptr_t) { }
	Texture()
	{
		glGenTextures(1, rebind());
		THROW_OPENGL_LASTERROR("glGenTextures()");
	}

	void bind(GLenum textureType, unsigned slot = 0)
	{
		glActiveTexture((GLenum) (GL_TEXTURE0 + slot));
		glBindTexture(textureType, *this);
	}

	static void unbind(GLenum textureType, unsigned slot = 0)
	{
		glActiveTexture((GLenum) (GL_TEXTURE0 + slot));
		glBindTexture(textureType, 0);
	}

	static Texture create2D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t levels = 1
		, void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED)
	{
		return create3D(textureType, internalFormat, width, height, 0, levels, data, dataType, dataFormat);
	}

	static Texture create3D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t depth, size_t levels = 1
		, void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED)
	{
		Texture result;
		result.bind(textureType);

		if (levels < 1)
			levels = 1;

		glTexParameteri(textureType, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(textureType, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		if (depth > 0)
			glTexParameteri(textureType, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
		THROW_OPENGL_LASTERROR("glTexParameteri()");

		if (depth == 0) {
			glTexStorage2D(textureType, (GLsizei) levels, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glTexStorage2D()");
		}
		else {
			glTexStorage3D(textureType, (GLsizei) levels, internalFormat, (GLsizei) width, (GLsizei) height, (GLsizei) depth);
			THROW_OPENGL_LASTERROR("glTexStorage3D()");
		}

		glTexParameteri(textureType, GL_TEXTURE_BASE_LEVEL, 0);
		glTexParameteri(textureType, GL_TEXTURE_MAX_LEVEL, (int) levels - 1);
		THROW_OPENGL_LASTERROR("glTexParameteri()");

		if (data)
			result.write(textureType, 0, data, dataType, dataFormat, width, height, depth);

		return result;
	}

	void write(GLenum textureType, size_t level
		, void const* data, GLenum dataType, GLenum dataFormat
		, size_t width, size_t height, size_t depth = 0
		, size_t offsetX = 0, size_t offsetY = 0, size_t offsetZ = 0)
	{
		bind(textureType);

		if (depth == 0) {
			glTexSubImage2D(textureType, (GLsizei) level, (GLsizei) offsetX, (GLsizei) offsetY
				, (GLsizei) width, (GLsizei) height
				, dataFormat, dataType, data);
			THROW_OPENGL_LASTERROR("glTexSubImage2D()");
		}
		else {
			glTexSubImage3D(textureType, (GLsizei) level, (GLsizei) offsetX, (GLsizei) offsetY, (GLsizei) offsetZ
				, (GLsizei) width, (GLsizei) height, (GLsizei) depth
				, dataFormat, dataType, data);
			THROW_OPENGL_LASTERROR("glTexSubImage3D()");
		}
	}
};

struct RenderBuffer : glew_delete<GLuint, glDeleteRenderbuffers>::handle_type
{
	MOVE_BASE(RenderBuffer, unique_handle)

	RenderBuffer(nullptr_t) { }
	RenderBuffer()
	{
		glGenRenderbuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenRenderbuffers()");
	}

	void bind()
	{
		glBindRenderbuffer(GL_RENDERBUFFER, *this);
	}

	static void unbind()
	{
		glBindRenderbuffer(GL_RENDERBUFFER, 0);
	}

	static RenderBuffer create(GLenum internalFormat, size_t width, size_t height, size_t samples = 1)
	{
		RenderBuffer result;
		result.bind();

		if(samples > 1)
		{
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, (GLsizei) samples, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glRenderbufferStorageMultisample()");
		}
		else
		{
			glRenderbufferStorage(GL_RENDERBUFFER, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glRenderbufferStorage()");
		}

		return result;
	}
};

template <class Resource>
struct AutoTarget : Resource
{
	using Resource::operator =;

	GLenum target;

	AutoTarget(GLenum target, Resource resource)
		: Resource(std::move(resource))
		, target(target) { }

	void bind()
	{
		Resource::bind(target);
	}

	void unbind()
	{
		Resource::unbind(target);
	}

	void bind(unsigned slot)
	{
		Resource::bind(target, slot);
	}

	void unbind(unsigned slot)
	{
		Resource::unbind(target, slot);
	}
};

struct VertexArrays : glew_delete<GLuint, glDeleteVertexArrays>::handle_type
{
	MOVE_BASE(VertexArrays, unique_handle)

	VertexArrays(nullptr_t) { }
	VertexArrays()
	{
		glGenVertexArrays(1, rebind());
		THROW_OPENGL_LASTERROR("glGenVertexArrays()");
	}

	void bind()
	{
		glBindVertexArray(*this);
	}

	static void unbind()
	{
		glBindVertexArray(0);
	}
};

struct Framebuffer : glew_delete<GLuint, glDeleteFramebuffers>::handle_type
{
	MOVE_BASE(Framebuffer, unique_handle)

	Framebuffer(nullptr_t) { }
	Framebuffer()
	{
		glGenFramebuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenFramebuffers()");
	}

	void bind(GLenum target = GL_FRAMEBUFFER)
	{
		glBindFramebuffer(target, *this);
	}
	static void unbind(GLenum target = GL_FRAMEBUFFER)
	{
		glBindFramebuffer(target, 0);
	}

	static Framebuffer create(GLuint const* textures, size_t textureCount, GLuint depthBuffer = 0)
	{
		Framebuffer result;
		result.bind();

		std::vector<GLenum> attachmentMapping(textureCount);

		for (size_t i = 0; i < textureCount; ++i)
		{
			GLenum attachment = (GLenum) (GL_COLOR_ATTACHMENT0 + i);
			glFramebufferTexture(GL_FRAMEBUFFER, attachment, textures[i], 0);
			THROW_OPENGL_LASTERROR("glFramebufferTexture()");
			attachmentMapping[i] = attachment;
		}

		glReadBuffer(GL_COLOR_ATTACHMENT0);
		glDrawBuffers((GLsizei) attachmentMapping.size(), attachmentMapping.data());

		if (depthBuffer)
		{
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthBuffer);
			THROW_OPENGL_LASTERROR("glFramebufferRenderbuffer()");
		}

		return result;
	}

	static Framebuffer createEmpty(size_t width, size_t height, size_t samples = 1)
	{
		Framebuffer result;
		result.bind();

		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_WIDTH, GLint(width));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_HEIGHT, GLint(height));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_SAMPLES, GLint(samples));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_LAYERS, 0);
		
		return result;
	}

	static GLuint getAttachement(GLenum attachment, GLenum target = GL_FRAMEBUFFER)
	{
		GLint object;
		glGetFramebufferAttachmentParameteriv(target, attachment, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &object);
		THROW_OPENGL_LASTERROR("glGetFramebufferAttachmentParameteriv()");
		return (GLuint) object;
	}
};

struct Shader : glew_delete_single<GLuint, glDeleteShader>::handle_type
{
	MOVE_BASE(Shader, unique_handle)

	Shader(nullptr_t) { }
	explicit Shader(GLenum shaderType)
	{
		reset( glCreateShader(shaderType) );
		THROW_OPENGL_LASTERROR("glCreateShader()");
	}

	static Shader compile(GLenum shaderType, char const* source, char const* preamble = "")
	{
		Shader result(shaderType);

		char const* shaderTypePreamble;
		switch (shaderType)
		{
		case GL_COMPUTE_SHADER: shaderTypePreamble = "#define cs_main main\n#define IN_CS\n"; break;
		case GL_VERTEX_SHADER: shaderTypePreamble = "#define vs_main main\n#define IN_VS\n"; break;
		case GL_FRAGMENT_SHADER: shaderTypePreamble = "#define fs_main main\n#define IN_FS\n"; break;
		case GL_GEOMETRY_SHADER: shaderTypePreamble = "#define gs_main main\n#define IN_GS\n"; break;
		case GL_TESS_CONTROL_SHADER: shaderTypePreamble = "#define tcs_main main\n#define IN_TCS\n"; break;
		case GL_TESS_EVALUATION_SHADER: shaderTypePreamble = "#define tes_main main\n#define IN_TES\n"; break;
		default: shaderTypePreamble = "";
		};

		char const* sources[] = { nullptr, nullptr, shaderTypePreamble, preamble, source, nullptr, nullptr };
		int sourceLens[] = { 0, 0, -1, -1, -1, 0, 0 };
		static_assert(arraylen(sourceLens) == arraylen(sources), "strlen array dim mismatch");

		// move version to the beginning
		if (auto versionDir = strstr(source, "#version"))
		{
			sources[0] = versionDir;
			auto endOfVersionDir = strchr(versionDir, '\n');
			sourceLens[0] = (endOfVersionDir) ? int(endOfVersionDir - versionDir) : -1;

			sources[1] = "\n";
			sourceLens[1] = 1;

			sources[4] = source;
			sourceLens[4] = int(versionDir - source);

			sources[5] = "// moved: ";
			sourceLens[5] = -1;

			sources[6] = versionDir;
			sourceLens[6] = -1;
		}

		// Everything that follows minimizes driver incompatibilities
		int sourceCount = 0;
		size_t totalSourceLen = 0;
		for (size_t i = 0; i < arraylen(sources); ++i)
		{
			auto src = sources[i];
			auto srcLen = sourceLens[i];
			if (!src) srcLen = 0;
			if (srcLen < 0) srcLen = (int) strlen(src);
			if (srcLen > 0)
			{
				sources[sourceCount] = src;
				sourceLens[sourceCount] = srcLen;
				++sourceCount;
				totalSourceLen += srcLen;
			}
		}

		// Seriously, nothing works: Concatenate manually
		std::string testSrc;
		testSrc.reserve(totalSourceLen);
		for (int i = 0; i < sourceCount; ++i)
			testSrc.append(sources[i], sources[i] + sourceLens[i]);
		assert(testSrc.size() == totalSourceLen);
		sources[0] = testSrc.c_str();
		sourceLens[0] = (int) totalSourceLen;
		sourceCount = 1;
		// fall back to most common use case
		glShaderSource(result, 1, sources, nullptr);

//		glShaderSource(result, sourceCount, sources, sourceLens);
		THROW_OPENGL_LASTERROR("glShaderSource()");

		glCompileShader(result);
		THROW_OPENGL_LASTERROR("glCompileShader()");

		if (!printBuildLog(result))
			THROW_OPENGL_ERROR(GL_INVALID_OPERATION, "Failed to build OpenGL shader");

		return result;
	}

	static bool printBuildLog(GLuint shader)
	{
		GLint status;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
		THROW_OPENGL_LASTERROR("glGetShaderiv(GL_COMPILE_STATUS)");

		GLint logSize;
		glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logSize);
		THROW_OPENGL_LASTERROR("glGetShaderiv(GL_INFO_LOG_LENGTH)");
		
		if (logSize > 1)
		{
			std::string log(logSize, 0);
			glGetShaderInfoLog(shader, (GLsizei) log.size(), nullptr, &log[0]);
			THROW_OPENGL_LASTERROR("glGetShaderInfoLog()");

			std::cout << ((status) ? "Build info:" : "There were build errors:") << std::endl;
			std::cout << log << std::endl;
		}

		return (status == GL_TRUE);
	}

	static Shader fromFile(GLenum shaderType, char const* file, char const* preamble = "")
	{
		return compile(shaderType, stdx::load_file(file).c_str(), preamble);
	}
};

struct Program : glew_delete_single<GLuint, glDeleteProgram>::handle_type
{
	MOVE_BASE(Program, unique_handle)

	Program(nullptr_t) { }
	Program()
	{
		reset( glCreateProgram() );
		THROW_OPENGL_LASTERROR("glCreateProgram()");

		glProgramParameteri(*this, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRUE);
		THROW_OPENGL_LASTERROR("glProgramParameteri(GL_PROGRAM_BINARY_RETRIEVABLE_HINT)");
	}

	void bind()
	{
		glUseProgram(*this);
	}
	static void unbind()
	{
		glUseProgram(0);
	}

	Program& attach(GLuint shader)
	{
		glAttachShader(*this, shader);
		THROW_OPENGL_LASTERROR("glAttachShader()");
		return *this;
	}

	void link()
	{
		glLinkProgram(*this);
		THROW_OPENGL_LASTERROR("glLinkProgram()");
		
		if (!printLinkLog(*this))
			THROW_OPENGL_ERROR(GL_INVALID_OPERATION, "Failed to link OpenGL program");
	}

	std::vector<char> getBinary(GLenum *format = nullptr) const
	{
		std::vector<char> result;
		GLint length;
		glGetProgramiv(*this, GL_PROGRAM_BINARY_LENGTH, &length);
		THROW_OPENGL_LASTERROR("glGetProgramiv()");
		result.resize((size_t) length);
		GLenum formatTmp;
		glGetProgramBinary(*this, (GLsizei) result.size(), &length, &formatTmp, result.data());
		THROW_OPENGL_LASTERROR("glGetProgramBinary()");
		if (format) *format = formatTmp;
		return result;
	}

	static bool printLinkLog(GLuint program)
	{
		GLint status;
		glGetProgramiv(program, GL_LINK_STATUS, &status);
		THROW_OPENGL_LASTERROR("glGetProgramiv(GL_LINK_STATUS)");

		GLint logSize;
		glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logSize);
		THROW_OPENGL_LASTERROR("glGetProgramiv(GL_INFO_LOG_LENGTH)");
		
		if (logSize > 1)
		{
			std::string log(logSize, 0);
			glGetProgramInfoLog(program, (GLsizei) log.size(), nullptr, &log[0]);
			THROW_OPENGL_LASTERROR("glGetProgramInfoLog()");

			std::cout << ((status) ? "Link info:" : "There were linking errors:") << std::endl;
			std::cout << log << std::endl;
		}

		return (status == GL_TRUE);
	}

	static Program fromShaders(GLuint s1, GLuint s2 = 0, GLuint s3 = 0, GLuint s4 = 0, GLuint s5 = 0)
	{
		Program result;
		result.attach(s1);
		if (s2) result.attach(s2);
		if (s3) result.attach(s3);
		if (s4) result.attach(s4);
		if (s5) result.attach(s5);
		result.link();
		return result;
	}
};

struct ProgramWithTime : Program
{
	enum Options
	{
		NoGS,
		HasGS,
		GSOnly
	};

	char const* preamble;
	std::string file;
	time_t time;
	Options options;
	bool compatibilityInclude;

	using Program::operator =;

	explicit ProgramWithTime(std::string file, char const *preamble = "", Options options = NoGS, bool compatibilityInclude = OGL_COMPATIBILITY_PREPROCESSING)
		: Program(nullptr)
		, preamble(preamble)
		, file(std::move(file))
		, time(0)
		, options(options)
		, compatibilityInclude(compatibilityInclude)
	{
		load();
	}
	static std::string resolveIncludesCompat(char const* include, bool local)
	{
		return stdx::process_includes(stdx::load_file(include), include, resolveIncludesCompat, std::string(), true);
	}
	static std::string resolveIncludes(char const* include, bool local)
	{
		return stdx::process_includes(stdx::load_file(include), include, resolveIncludes);
	}
	void load()
	{
		auto& resolveFunc = (compatibilityInclude) ? resolveIncludesCompat : resolveIncludes;
		std::string src = resolveFunc(file.c_str(), true);
		*this = Program::fromShaders(
			Shader::compile(GL_FRAGMENT_SHADER, src.c_str(), preamble)
		, (options != GSOnly) ? (GLuint) Shader::compile(GL_VERTEX_SHADER, src.c_str(), preamble) : 0
		, (options != NoGS) ? (GLuint) Shader::compile(GL_GEOMETRY_SHADER, src.c_str(), preamble) : 0
		);
		time = stdx::file_time(file.c_str());
	}
	int maybeReload()
	{
		if (stdx::file_time(file.c_str()) > time)
		{
			try { load(); return 1; }
			catch (ogl_error const &) { return -1; }
		}
		return 0;
	}
};

} // namespace
