#pragma once

#include "oglbase"
#include <glfw/glfw3.h>

#include "stdx"
#include "filex"

#include <algorithm>
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <functional>

namespace ogl
{

struct GLFW : stdx::noncopyable
{
	static GLFW*& instance()
	{
		static GLFW* i;
		return i;
	}

	static void errorCallback(int error, const char* description)
	{
		std::cout << "GLFW error #" << error << ": " << description << std::endl;
	}

	GLFW(int major, int minor, bool debug = true, bool coreProfile = true)
	{
		if (instance())
			throwx( ogl_error("GLFW has already been initialized!") );

		glfwSetErrorCallback(errorCallback);

		if (!glfwInit())
			throwx( ogl_error("Failed to init glfw!") );

		glfwDefaultWindowHints();
		configureGl(major, minor, debug, coreProfile);

		instance() = this;
	}
	~GLFW()
	{
		glfwTerminate();

		instance() = nullptr;
	}
	
	void configureGl(int major, int minor, bool debug = true, bool coreProfile = true)
	{
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, major);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, minor);
		glfwWindowHint(GLFW_SRGB_CAPABLE, GL_TRUE);
		if (coreProfile)
			glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_COMPAT_PROFILE);
		if (debug)
			glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);
	}
	void enableVSync(bool enable)
	{
		glfwSwapInterval((int) enable);
	}
	
	static void APIENTRY debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam)
	{
		bool Error = false;
		bool Info = false;

		char const* srcS = "Unknown Source";
		if(source == GL_DEBUG_SOURCE_API_ARB)
			srcS = "OpenGL";
		else if(source == GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB)
			srcS = "Windows";
		else if(source == GL_DEBUG_SOURCE_SHADER_COMPILER_ARB)
			srcS = "Shader Compiler";
		else if(source == GL_DEBUG_SOURCE_THIRD_PARTY_ARB)
			srcS = "Third Party";
		else if(source == GL_DEBUG_SOURCE_APPLICATION_ARB)
			srcS = "Application";
		else if(source == GL_DEBUG_SOURCE_OTHER_ARB)
			srcS = "Other";

		char const* typeS = "unknown error";
		if(type == GL_DEBUG_TYPE_ERROR_ARB)
			typeS = "error";
		else if(type == GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB)
			typeS = "deprecated behavior";
		else if(type == GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB)
			typeS = "undefined behavior";
		else if(type == GL_DEBUG_TYPE_PORTABILITY_ARB)
			typeS = "portability";
		else if(type == GL_DEBUG_TYPE_PERFORMANCE_ARB)
			typeS = "performance";
		else if(type == GL_DEBUG_TYPE_OTHER_ARB)
		{
			typeS = "message";
			Info = (strstr(message, "info:") != nullptr);
		}

		char const* severityS= "unknown severity";
		if(severity == GL_DEBUG_SEVERITY_HIGH_ARB)
		{
			severityS = "high";
			Error = true;
		}
		else if(severity == GL_DEBUG_SEVERITY_MEDIUM_ARB)
			severityS = "medium";
		else if(severity == GL_DEBUG_SEVERITY_LOW_ARB)
			severityS = "low";

		if (Error || !Info)
			std::cout << srcS << ": " << typeS << "(" << severityS << ") " << id << ": " << message << std::endl;
	}

	void enableDebugMessages()
	{
		glEnable(GL_DEBUG_OUTPUT);
		glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
		glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_TRUE);
		glDebugMessageCallback(&GLFW::debugCallback, NULL);
	}
};

struct GLEW : stdx::noncopyable
{
	GLEW()
	{
		// see http://www.opengl.org/wiki/OpenGL_Loading_Library
		glewExperimental = GL_TRUE;
		auto err = glewInit();
		if (GLEW_OK != err)
			throwx( std::runtime_error((char const*) glewGetErrorString(err)) );
		while (glGetError() != GL_NO_ERROR);
	}
};

struct GLFWWindow : stdx::noncopyable
{
	static std::map<GLFWwindow*, GLFWWindow*>& windows()
	{
		static std::map<GLFWwindow*, GLFWWindow*> w;
		return w;
	}
	
	void registerThis() throw()
	{
		if (window)
			windows()[window] = this;
	}
	void unregisterThis() throw()
	{
		if (window)
			windows().erase(window);
	}

	static void resizeCallback(GLFWwindow *window, int w, int h)
	{
		auto* self = windows()[window];
		if (self && self->resize)
			self->resize((unsigned) w, (unsigned) h);
	}
	static void keyCallback(GLFWwindow *window, int key, int scancode, int action, int mods)
	{
		auto* self = windows()[window];
		if (action != GLFW_REPEAT && self && self->keyboard)
			self->keyboard(key, action == GLFW_PRESS);
	}
	static void mouseCallback(GLFWwindow *window, double x, double y)
	{
		auto* self = windows()[window];
		if (self && self->mouse)
			self->mouse((int) x, (int) y);
	}
	static void buttonsCallback(GLFWwindow *window, int button, int action, int mods)
	{
		auto* self = windows()[window];
		if (self && self->buttons)
			self->buttons(button, action == GLFW_PRESS);
	}

	stdx::unique_handle<GLFWwindow*> window;
	TRANSPARENT_MEMBER(GLFWWindow, window)

	std::function<void (unsigned w, unsigned h)> resize;
	std::function<void (int key, bool pressed)> keyboard;
	std::function<void (int x, int y)> mouse;
	std::function<void (int button, bool pressed)> buttons;

	GLFWWindow(int w, int h, char const *title, GLFWmonitor *monitor = glfwGetPrimaryMonitor(), GLFWwindow *share = nullptr)
	{
		window.reset( glfwCreateWindow(w, h, title, monitor, share) );
		if (!window)
			throwx( ogl_error("Failed to create glfw window!") );
		glfwSetFramebufferSizeCallback(window, resizeCallback);
		glfwSetKeyCallback(window, keyCallback);
		glfwSetCursorPosCallback(window, mouseCallback);
		glfwSetMouseButtonCallback(window, buttonsCallback);

		registerThis();
	}
	~GLFWWindow()
	{
		if (window)
		{
			glfwDestroyWindow(window);
			unregisterThis();
		}
	}
	GLFWWindow(GLFWWindow &&right)
		: window(std::move(right.window))
		, resize(std::move(right.resize))
		, keyboard(std::move(right.keyboard))
		, mouse(std::move(right.mouse))
		, buttons(std::move(right.buttons))
	{
		registerThis();
	}
	GLFWWindow& operator =(GLFWWindow &&right)
	{
		std::swap(window, right.window);
		std::swap(resize, right.resize);
		std::swap(keyboard, right.keyboard);
		std::swap(mouse, right.mouse);
		std::swap(buttons, right.buttons);

		registerThis();
		right.registerThis();

		return *this;
	}

	void makeCurrent()
	{
		glfwMakeContextCurrent(window);
	}

	void swapBuffers()
	{
		glfwSwapBuffers(window);
	}

	bool shouldClose() const
	{
		return glfwWindowShouldClose(window) != 0;
	}

	void initialResize()
	{
		if (resize)
		{
			int w, h;
			glfwGetFramebufferSize(window, &w, &h);
			resize((unsigned) w, (unsigned) h);
		}
	}
};

struct Buffer : glew_delete<GLuint, glDeleteBuffers>::handle_type
{
	MOVE_BASE(Buffer, unique_handle)

	Buffer(nullptr_t) { }
	Buffer()
	{
		glGenBuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenBuffers()");
	}

	void bind(GLenum bufferType)
	{
		glBindBuffer(bufferType, *this);
	}

	static void unbind(GLenum bufferType)
	{
		glBindBuffer(bufferType, 0);
	}

	void bind(GLenum bufferType, unsigned slot)
	{
		glBindBufferBase(bufferType, slot, *this);
	}

	static void unbind(GLenum bufferType, unsigned slot)
	{
		glBindBufferBase(bufferType, slot, 0);
	}

	static Buffer create(GLenum bufferType, size_t size, void const* data = nullptr, GLenum usage = GL_STATIC_DRAW)
	{
		Buffer result;
		result.bind(bufferType);

		glBufferData(bufferType, size, data, usage);
		THROW_OPENGL_LASTERROR("glBufferData()");

		return result;
	}

	template <class Range>
	static Buffer init(GLenum bufferType, Range const& range, GLenum usage = GL_STATIC_DRAW)
	{
		return create(bufferType, sizeof(*range.data()) * range.size(), range.data(), usage);
	}
	template <class Range>
	void write(GLenum bufferType, Range const& range, size_t destOffset = 0)
	{
		bind(bufferType);
		glBufferSubData(bufferType, sizeof(*range.data()) * destOffset, sizeof(*range.data()) * range.size(), range.data());
		THROW_OPENGL_LASTERROR("glBufferSubData()");
	}
	template <class Range>
	void read(GLenum bufferType, Range const& range, size_t srcOffset = 0)
	{
		bind(bufferType);
		glGetBufferSubData(target, sizeof(*range.data()) * srcOffset, sizeof(*range.data()) * range.size(), range.data());
		THROW_OPENGL_LASTERROR("glGetBufferSubData()");
	}
};

struct Texture : gl_delete<GLuint, glDeleteTextures>::handle_type
{
	MOVE_BASE(Texture, unique_handle)

	Texture(nullptr_t) { }
	Texture()
	{
		glGenTextures(1, rebind());
		THROW_OPENGL_LASTERROR("glGenTextures()");
	}

	void bind(GLenum textureType, unsigned slot = 0)
	{
		glActiveTexture((GLenum) (GL_TEXTURE0 + slot));
		glBindTexture(textureType, *this);
	}

	static void unbind(GLenum textureType, unsigned slot = 0)
	{
		glActiveTexture((GLenum) (GL_TEXTURE0 + slot));
		glBindTexture(textureType, 0);
	}

	static Texture create2D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t levels = 1
		, void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED)
	{
		return create3D(textureType, internalFormat, width, height, 0, levels, data, dataType, dataFormat);
	}

	static Texture create3D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t depth, size_t levels = 1
		, void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED)
	{
		Texture result;
		result.bind(textureType);

		if (levels < 1)
			levels = 1;

		glTexParameteri(textureType, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(textureType, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_S, GL_CLAMP);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_T, GL_CLAMP);
		if (depth > 0)
			glTexParameteri(textureType, GL_TEXTURE_WRAP_R, GL_CLAMP);
		THROW_OPENGL_LASTERROR("glTexParameteri()");

		if (depth == 0) {
			glTexStorage2D(textureType, (GLsizei) levels, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glTexStorage2D()");
		}
		else {
			glTexStorage3D(textureType, (GLsizei) levels, internalFormat, (GLsizei) width, (GLsizei) height, (GLsizei) depth);
			THROW_OPENGL_LASTERROR("glTexStorage3D()");
		}

		glTexParameteri(textureType, GL_TEXTURE_BASE_LEVEL, 0);
		glTexParameteri(textureType, GL_TEXTURE_MAX_LEVEL, (int) levels - 1);
		THROW_OPENGL_LASTERROR("glTexParameteri()");

		if (data)
			result.write(textureType, 0, data, dataType, dataFormat, width, height, depth);

		return result;
	}

	void write(GLenum textureType, size_t level
		, void const* data, GLenum dataType, GLenum dataFormat
		, size_t width, size_t height, size_t depth = 0
		, size_t offsetX = 0, size_t offsetY = 0, size_t offsetZ = 0)
	{
		bind(textureType);

		if (depth == 0) {
			glTexSubImage2D(textureType, (GLsizei) level, (GLsizei) offsetX, (GLsizei) offsetY
				, (GLsizei) width, (GLsizei) height
				, dataFormat, dataType, data);
			THROW_OPENGL_LASTERROR("glTexSubImage2D()");
		}
		else {
			glTexSubImage3D(textureType, (GLsizei) level, (GLsizei) offsetX, (GLsizei) offsetY, (GLsizei) offsetZ
				, (GLsizei) width, (GLsizei) height, (GLsizei) depth
				, dataFormat, dataType, data);
			THROW_OPENGL_LASTERROR("glTexSubImage3D()");
		}
	}
};

struct RenderBuffer : glew_delete<GLuint, glDeleteRenderbuffers>::handle_type
{
	MOVE_BASE(RenderBuffer, unique_handle)

	RenderBuffer(nullptr_t) { }
	RenderBuffer()
	{
		glGenRenderbuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenRenderbuffers()");
	}

	void bind()
	{
		glBindRenderbuffer(GL_RENDERBUFFER, *this);
	}

	static void unbind()
	{
		glBindRenderbuffer(GL_RENDERBUFFER, 0);
	}

	static RenderBuffer create(GLenum internalFormat, size_t width, size_t height, size_t samples = 1)
	{
		RenderBuffer result;
		result.bind();

		if(samples > 1)
		{
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, (GLsizei) samples, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glRenderbufferStorageMultisample()");
		}
		else
		{
			glRenderbufferStorage(GL_RENDERBUFFER, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glRenderbufferStorage()");
		}

		return result;
	}
};

template <class Resource>
struct AutoTarget : Resource
{
	using Resource::operator =;

	GLenum target;

	AutoTarget(GLenum target, Resource resource)
		: Resource(std::move(resource))
		, target(target) { }

	void bind()
	{
		Resource::bind(target);
	}

	static void unbind()
	{
		Resource::unbind(target);
	}

	void bind(unsigned slot)
	{
		Resource::bind(target, slot);
	}

	static void unbind(unsigned slot)
	{
		Resource::unbind(target, slot);
	}
};

struct VertexArrays : glew_delete<GLuint, glDeleteVertexArrays>::handle_type
{
	MOVE_BASE(VertexArrays, unique_handle)

	VertexArrays(nullptr_t) { }
	VertexArrays()
	{
		glGenVertexArrays(1, rebind());
		THROW_OPENGL_LASTERROR("glGenVertexArrays()");
	}

	void bind()
	{
		glBindVertexArray(*this);
	}

	static void unbind()
	{
		glBindVertexArray(0);
	}
};

struct Framebuffer : glew_delete<GLuint, glDeleteFramebuffers>::handle_type
{
	MOVE_BASE(Framebuffer, unique_handle)

	Framebuffer(nullptr_t) { }
	Framebuffer()
	{
		glGenFramebuffers(1, rebind());
		THROW_OPENGL_LASTERROR("glGenFramebuffers()");
	}

	void bind(GLenum target = GL_FRAMEBUFFER)
	{
		glBindFramebuffer(target, *this);
	}
	static void unbind(GLenum target = GL_FRAMEBUFFER)
	{
		glBindFramebuffer(target, 0);
	}

	static Framebuffer create(GLuint const* textures, size_t textureCount, GLuint depthBuffer = 0)
	{
		Framebuffer result;
		result.bind();

		std::vector<GLenum> attachmentMapping(textureCount);

		for (size_t i = 0; i < textureCount; ++i)
		{
			GLenum attachment = (GLenum) (GL_COLOR_ATTACHMENT0 + i);
			glFramebufferTexture(GL_FRAMEBUFFER, attachment, textures[i], 0);
			THROW_OPENGL_LASTERROR("glFramebufferTexture()");
			attachmentMapping[i] = attachment;
		}

		glReadBuffer(GL_COLOR_ATTACHMENT0);
		glDrawBuffers((GLsizei) attachmentMapping.size(), attachmentMapping.data());

		if (depthBuffer)
		{
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthBuffer);
			THROW_OPENGL_LASTERROR("glFramebufferRenderbuffer()");
		}

		return result;
	}

	static GLuint getAttachement(GLenum attachment, GLenum target = GL_FRAMEBUFFER)
	{
		GLint object;
		glGetFramebufferAttachmentParameteriv(target, attachment, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &object);
		THROW_OPENGL_LASTERROR("glGetFramebufferAttachmentParameteriv()");
		return (GLuint) object;
	}
};

struct Shader : glew_delete_single<GLuint, glDeleteShader>::handle_type
{
	MOVE_BASE(Shader, unique_handle)

	Shader(nullptr_t) { }
	explicit Shader(GLenum shaderType)
	{
		reset( glCreateShader(shaderType) );
		THROW_OPENGL_LASTERROR("glCreateShader()");
	}

	static Shader compile(GLenum shaderType, char const* source, char const* preamble = "")
	{
		Shader result(shaderType);

		char const* shaderTypePreamble;
		switch (shaderType)
		{
		case GL_COMPUTE_SHADER: shaderTypePreamble = "#define cs_main main\n#define IN_CS\n"; break;
		case GL_VERTEX_SHADER: shaderTypePreamble = "#define vs_main main\n#define IN_VS\n"; break;
		case GL_FRAGMENT_SHADER: shaderTypePreamble = "#define fs_main main\n#define IN_FS\n"; break;
		case GL_GEOMETRY_SHADER: shaderTypePreamble = "#define gs_main main\n#define IN_GS\n"; break;
		case GL_TESS_CONTROL_SHADER: shaderTypePreamble = "#define tcs_main main\n#define IN_TCS\n"; break;
		case GL_TESS_EVALUATION_SHADER: shaderTypePreamble = "#define tes_main main\n#define IN_TES\n"; break;
		default: shaderTypePreamble = "";
		};

		char const* sources[] = { shaderTypePreamble, preamble, source };
		glShaderSource(result, arraylen(sources), sources, nullptr);
		THROW_OPENGL_LASTERROR("glShaderSource()");

		glCompileShader(result);
		THROW_OPENGL_LASTERROR("glCompileShader()");

		if (!printBuildLog(result))
			THROW_OPENGL_ERROR(GL_INVALID_OPERATION, "Failed to build OpenGL shader");

		return result;
	}

	static bool printBuildLog(GLuint shader)
	{
		GLint status;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
		THROW_OPENGL_LASTERROR("glGetShaderiv(GL_COMPILE_STATUS)");

		GLint logSize;
		glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logSize);
		THROW_OPENGL_LASTERROR("glGetShaderiv(GL_INFO_LOG_LENGTH)");
		
		if (logSize > 1)
		{
			std::string log(logSize, 0);
			glGetShaderInfoLog(shader, (GLsizei) log.size(), nullptr, &log[0]);
			THROW_OPENGL_LASTERROR("glGetShaderInfoLog()");

			std::cout << ((status) ? "Build info:" : "There were build errors:") << std::endl;
			std::cout << log << std::endl;
		}

		return (status == GL_TRUE);
	}

	static Shader fromFile(GLenum shaderType, char const* file, char const* preamble = "")
	{
		return compile(shaderType, stdx::load_file(file).c_str(), preamble);
	}
};

struct Program : glew_delete_single<GLuint, glDeleteProgram>::handle_type
{
	MOVE_BASE(Program, unique_handle)

	Program(nullptr_t) { }
	Program()
	{
		reset( glCreateProgram() );
		THROW_OPENGL_LASTERROR("glCreateProgram()");

		glProgramParameteri(*this, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRUE);
		THROW_OPENGL_LASTERROR("glProgramParameteri(GL_PROGRAM_BINARY_RETRIEVABLE_HINT)");
	}

	void bind()
	{
		glUseProgram(*this);
	}
	static void unbind()
	{
		glUseProgram(0);
	}

	Program& attach(GLuint shader)
	{
		glAttachShader(*this, shader);
		THROW_OPENGL_LASTERROR("glAttachShader()");
		return *this;
	}

	void link()
	{
		glLinkProgram(*this);
		THROW_OPENGL_LASTERROR("glLinkProgram()");
		
		if (!printLinkLog(*this))
			THROW_OPENGL_ERROR(GL_INVALID_OPERATION, "Failed to link OpenGL program");
	}

	std::vector<char> getBinary(GLenum *format = nullptr) const
	{
		std::vector<char> result;
		GLint length;
		glGetProgramiv(*this, GL_PROGRAM_BINARY_LENGTH, &length);
		THROW_OPENGL_LASTERROR("glGetProgramiv()");
		result.resize((size_t) length);
		GLenum formatTmp;
		glGetProgramBinary(*this, (GLsizei) result.size(), &length, &formatTmp, result.data());
		THROW_OPENGL_LASTERROR("glGetProgramBinary()");
		if (format) *format = formatTmp;
		return result;
	}

	static bool printLinkLog(GLuint program)
	{
		GLint status;
		glGetProgramiv(program, GL_LINK_STATUS, &status);
		THROW_OPENGL_LASTERROR("glGetProgramiv(GL_LINK_STATUS)");

		GLint logSize;
		glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logSize);
		THROW_OPENGL_LASTERROR("glGetProgramiv(GL_INFO_LOG_LENGTH)");
		
		if (logSize > 1)
		{
			std::string log(logSize, 0);
			glGetProgramInfoLog(program, (GLsizei) log.size(), nullptr, &log[0]);
			THROW_OPENGL_LASTERROR("glGetProgramInfoLog()");

			std::cout << ((status) ? "Link info:" : "There were linking errors:") << std::endl;
			std::cout << log << std::endl;
		}

		return (status == GL_TRUE);
	}

	static Program fromShaders(GLuint s1, GLuint s2 = 0, GLuint s3 = 0, GLuint s4 = 0, GLuint s5 = 0)
	{
		Program result;
		result.attach(s1);
		if (s2) result.attach(s2);
		if (s3) result.attach(s3);
		if (s4) result.attach(s4);
		if (s5) result.attach(s5);
		result.link();
		return result;
	}
};

struct ProgramWithTime : Program
{
	char const* preamble;
	std::string file;
	time_t time;

	using Program::operator =;

	explicit ProgramWithTime(std::string file, char const *preamble = "")
		: Program(nullptr)
		, preamble(preamble)
		, file(std::move(file))
		, time(0)
	{
		load();
	}
	static std::string resolveIncludes(std::string const& include, bool local)
	{
		return stdx::process_includes(stdx::load_file(include.c_str()), include, resolveIncludes);
	}
	void load()
	{
		std::string src = stdx::process_includes(stdx::load_file(file.c_str()), file, resolveIncludes);
		*this = Program::fromShaders(
		  Shader::compile(GL_VERTEX_SHADER, src.c_str(), preamble)
		, Shader::compile(GL_FRAGMENT_SHADER, src.c_str(), preamble)
		);
		time = stdx::file_time(file.c_str());
	}
	int maybeReload()
	{
		if (stdx::file_time(file.c_str()) > time)
		{
			try { load(); return 1; }
			catch (ogl_error const &) { return -1; }
		}
		return 0;
	}
};

} // namespace
