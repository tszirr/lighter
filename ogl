#pragma once

#include "oglbase"
#include <GLFW/glfw3.h>

#include "stdx"
#include "file"

#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
#include <functional>

#ifndef DEFAULT_ASSIGN_NULL_REFERENCE
	#ifndef NO_DEFAULT_ASSIGN_NULL_REFERENCE
		#define DEFAULT_ASSIGN_NULL_REFERENCE = nullptr
	#else
		#define DEFAULT_ASSIGN_NULL_REFERENCE
	#endif
#endif

#ifndef OGL_COMPATIBILITY_PREPROCESSING
	#ifdef NO_OGL_COMPATIBILITY_PREPROCESSING
		#define OGL_COMPATIBILITY_PREPROCESSING false
	#else
		#define OGL_COMPATIBILITY_PREPROCESSING true
	#endif
#endif

namespace ogl
{

struct GLFW : stdx::noncopyable
{
	static GLFW*& instance();

	static void errorCallback(int error, const char* description);

	GLFW(int major, int minor, bool coreProfile = false, bool debug = true)
	{
		if (instance())
			throwx( ogl_error("GLFW has already been initialized!") );

		glfwSetErrorCallback(errorCallback);

		if (!glfwInit())
			throwx( ogl_error("Failed to init glfw!") );

		glfwDefaultWindowHints();
		configureGl(major, minor, coreProfile, debug);

		instance() = this;
	}
	~GLFW()
	{
		glfwTerminate();

		instance() = nullptr;
	}
	
	void configureGl(int major, int minor, bool coreProfile = false, bool debug = true)
	{
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, major);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, minor);
		glfwWindowHint(GLFW_SRGB_CAPABLE, GL_TRUE);
		if (major > 3 || major == 3 && minor >= 2)
			glfwWindowHint(GLFW_OPENGL_PROFILE, (coreProfile) ? GLFW_OPENGL_CORE_PROFILE : GLFW_OPENGL_COMPAT_PROFILE);
		if (debug)
			glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);
	}
	void enableVSync(bool enable)
	{
		glfwSwapInterval((int) enable);
	}
	
	static void APIENTRY debugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

	void enableDebugMessages()
	{
		glEnable(GL_DEBUG_OUTPUT);
		glGetError();
		glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
		glGetError();
		if (glDebugMessageControl) {
			glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_MEDIUM, 0, nullptr, GL_TRUE);
			glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_HIGH, 0, nullptr, GL_TRUE);
		}
		if (glDebugMessageCallback)
			glDebugMessageCallback(&GLFW::debugCallback, NULL);
	}

	void enableMultisampling(size_t samples = 4)
	{
		glfwWindowHint(GLFW_SAMPLES, int(samples));
	}

	void noDepthStencil()
	{
		glfwWindowHint(GLFW_DEPTH_BITS, 0);
		glfwWindowHint(GLFW_STENCIL_BITS, 0);
	}
};
typedef GLFW Platform;

struct GLEW : stdx::noncopyable
{
	GLEW()
	{
		// see http://www.opengl.org/wiki/OpenGL_Loading_Library
		glewExperimental = GL_TRUE;
		auto err = glewInit();
		if (GLEW_OK != err)
			throwx( std::runtime_error((char const*) glewGetErrorString(err)) );
		while (glGetError() != GL_NO_ERROR);
	}
};

struct TrackedGLFWWindow : stdx::fun_delete<GLFWwindow*, glfwDestroyWindow>::handle_type
{
	explicit TrackedGLFWWindow(GLFWwindow* wnd = nullptr) throw()
		: unique_handle(wnd)
	{
		registerThis();
	}
	TrackedGLFWWindow(TrackedGLFWWindow &&right) throw()
		: unique_handle(std::move(right))
	{
		registerThis();
	}
	TrackedGLFWWindow& operator =(TrackedGLFWWindow &&right) throw()
	{
		this->swap(right);
		return *this;
	}

	void reset(GLFWwindow* wnd = nullptr) throw()
	{
		unique_handle::reset(wnd);
		registerThis();
	}
	GLFWwindow* release() throw()
	{
		unregisterThis();
		return unique_handle::release();
	}
	void swap(TrackedGLFWWindow& right) throw()
	{
		unique_handle::swap(right);
		registerThis();
		right.registerThis();
	}

	void registerThis() throw()
	{
		if (valid())
			glfwSetWindowUserPointer(*this, this);
	}
	void unregisterThis() throw()
	{
		if (valid())
			glfwSetWindowUserPointer(*this, nullptr);
	}
	template <class GLFWWindow>
	static GLFWWindow* getThis(GLFWwindow* wnd)
	{
		return static_cast<GLFWWindow*>( static_cast<TrackedGLFWWindow*>( glfwGetWindowUserPointer(wnd) ) );
	}
};

struct GLFWWindow : TrackedGLFWWindow
{
	MOVE_GENERATE(GLFWWindow, MOVE_6, BASE, TrackedGLFWWindow
		, MEMBER, resize, MEMBER, keyboard, MEMBER, text, MEMBER, mouse, MEMBER, buttons)

	static void resizeCallback(GLFWwindow *window, int w, int h);
	static void keyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);
	static void textCallback(GLFWwindow *window, unsigned chr);
	static void mouseCallback(GLFWwindow *window, double x, double y);
	static void buttonsCallback(GLFWwindow *window, int button, int action, int mods);
	static void scrollCallback(GLFWwindow *window, double x, double y);

	std::function<void (unsigned w, unsigned h)> resize;
	std::function<void (int key, bool pressed, bool repeat)> keyboard;
	std::function<void (int key, bool pressed, bool repeat, int modifiers)> modKeyboard;
	std::function<void (unsigned)> text;
	std::function<void (int x, int y)> mouse;
	std::function<void (int button, bool pressed)> buttons;
	std::function<void (int x, int y)> scroll;

	GLFWWindow(int w, int h, char const *title, GLFWmonitor *monitor = glfwGetPrimaryMonitor(), GLFWwindow *share = nullptr)
		: TrackedGLFWWindow( glfwCreateWindow(w, h, title, monitor, share) )
	{
		if (!valid()) throwx( ogl_error("Failed to create glfw window!") );
		glfwSetFramebufferSizeCallback(*this, resizeCallback);
		glfwSetKeyCallback(*this, keyCallback);
		glfwSetCharCallback(*this, textCallback);
		glfwSetCursorPosCallback(*this, mouseCallback);
		glfwSetMouseButtonCallback(*this, buttonsCallback);
		glfwSetScrollCallback(*this, scrollCallback);
	}

	void makeCurrent()
	{
		glfwMakeContextCurrent(*this);
	}

	void swapBuffers()
	{
		glfwSwapBuffers(*this);
	}

	bool shouldClose() const
	{
		return glfwWindowShouldClose(*this) != 0;
	}

	void initialResize()
	{
		if (resize)
		{
			int w, h;
			glfwGetFramebufferSize(*this, &w, &h);
			resize((unsigned) w, (unsigned) h);
		}
	}
};
typedef GLFWWindow Window;

struct BufferRef : glew_destroy<BufferRef, GLuint, glDeleteBuffers>
{
	BufferRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	BufferRef(GLuint ref) { this->ref = ref; }
	
	static owned create()
	{
		owned r = nullptr;
		glGenBuffers(1, &r.ref);
		THROW_OPENGL_LASTERROR("glGenBuffers()");
		return r;
	}
	
	void bind(GLenum bufferType)
	{
		glBindBuffer(bufferType, *this);
	}

	static void unbind(GLenum bufferType)
	{
		glBindBuffer(bufferType, 0);
	}

	void bind(GLenum bufferType, unsigned slot)
	{
		glBindBufferBase(bufferType, slot, *this);
	}

	static void unbind(GLenum bufferType, unsigned slot)
	{
		glBindBufferBase(bufferType, slot, 0);
	}

	static owned create(GLenum bufferType, GLbitfield flags, size_t size, void const* data = nullptr)
	{
		auto result = create();
		result.bind(bufferType);

		glBufferStorage(bufferType, size, data, flags);
		THROW_OPENGL_LASTERROR("glBufferData()");

		return result;
	}
	// legacy
	static owned create(GLenum bufferType, size_t size, void const* data = nullptr, GLenum usage = GL_STATIC_DRAW)
	{
		auto result = create();
		result.bind(bufferType);

		glBufferData(bufferType, size, data, usage);
		THROW_OPENGL_LASTERROR("glBufferData()");

		return result;
	}
	
	template <class Range>
	static owned init(GLenum bufferType, GLbitfield flags, Range const& range)
	{
		return create(bufferType, flags, sizeof(*range.data()) * range.size(), range.data());
	}
	// legacy
	template <class Range>
	static owned init(GLenum bufferType, Range const& range, GLenum usage = GL_STATIC_DRAW)
	{
		return create(bufferType, sizeof(*range.data()) * range.size(), range.data(), usage);
	}

	template <class Range>
	void write(GLenum bufferType, Range const& range, size_t destOffset = 0)
	{
		bind(bufferType);
		glBufferSubData(bufferType, sizeof(*range.data()) * destOffset, sizeof(*range.data()) * range.size(), range.data());
		THROW_OPENGL_LASTERROR("glBufferSubData()");
	}
	template <class Range>
	void read(GLenum bufferType, Range& range, size_t srcOffset = 0)
	{
		bind(bufferType);
		glGetBufferSubData(bufferType, sizeof(*range.data()) * srcOffset, sizeof(*range.data()) * range.size(), range.data());
		THROW_OPENGL_LASTERROR("glGetBufferSubData()");
	}

	void clear(GLenum bufferType, GLenum internalFormat = GL_R32F, GLenum type = GL_FLOAT)
	{
		bind(bufferType);
		glClearBufferData(bufferType, internalFormat, GL_RED, type, nullptr);
		THROW_OPENGL_LASTERROR("glClearBufferData()");
	}
};
typedef BufferRef::owned Buffer;

#pragma pack(push, 1)
struct BufferDesc
{
	typedef Buffer resource;

	GLenum bufferType;
	size_t size;
	GLenum usage;

	static BufferDesc make(GLenum bufferType, size_t size, GLenum usage = GL_STATIC_DRAW)
	{
		BufferDesc desc = { bufferType, size, usage };
		return desc;
	}

	Buffer create() const
	{
		return Buffer::create(bufferType, size, nullptr, usage);
	}
};
#pragma pack(pop)

inline size_t computeMipLevelCount(size_t dim)
{
	size_t c = 1;
	for (; dim > 1; dim = dim >> 1)
		++c;
	return c;
}

inline bool is3DTexture(GLenum textureType)
{	return (textureType == GL_TEXTURE_3D); }

struct TextureRef : gl_destroy<TextureRef, GLuint, glDeleteTextures>
{
	TextureRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	TextureRef(GLuint ref) { this->ref = ref; }

	static owned create()
	{
		owned r = nullptr;
		glGenTextures(1, &r.ref);
		THROW_OPENGL_LASTERROR("glGenTextures()");
		return r;
	}

	void bind(GLenum textureType, unsigned slot = 0)
	{
		glActiveTexture((GLenum) (GL_TEXTURE0 + slot));
		glBindTexture(textureType, *this);
	}

	static void unbind(GLenum textureType, unsigned slot = 0)
	{
		glActiveTexture((GLenum) (GL_TEXTURE0 + slot));
		glBindTexture(textureType, 0);
	}

	static owned create2D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t levels = 1
		, void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED)
	{
		return create3D(textureType, internalFormat, width, height, 0, levels, data, dataType, dataFormat);
	}

	static owned create3D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t depth, size_t levelsOrGen = 1
		, void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED)
	{
		auto result = create();
		result.bind(textureType);

		size_t levels = (levelsOrGen >= 1U) ? levelsOrGen : computeMipLevelCount(std::max(std::max(width, height), depth));

		glTexParameteri(textureType, GL_TEXTURE_MAG_FILTER, (levels == 1) ? GL_NEAREST : GL_LINEAR);
		glTexParameteri(textureType, GL_TEXTURE_MIN_FILTER, (levels == 1) ? GL_NEAREST_MIPMAP_NEAREST : GL_LINEAR_MIPMAP_LINEAR);
		auto defaultWrapMode = (levels == 1) ? GL_CLAMP_TO_EDGE : GL_REPEAT;
		glTexParameteri(textureType, GL_TEXTURE_WRAP_S, defaultWrapMode);
		if (height > 0 && textureType != GL_TEXTURE_1D_ARRAY)
			glTexParameteri(textureType, GL_TEXTURE_WRAP_T, defaultWrapMode);
		if (depth > 0 && textureType != GL_TEXTURE_2D_ARRAY)
			glTexParameteri(textureType, GL_TEXTURE_WRAP_R, defaultWrapMode);
		THROW_OPENGL_LASTERROR("glTexParameteri()");

		if (depth == 0) {
			glTexStorage2D(textureType, (GLsizei) levels, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glTexStorage2D()");
		}
		else {
			glTexStorage3D(textureType, (GLsizei) levels, internalFormat, (GLsizei) width, (GLsizei) height, (GLsizei) depth);
			THROW_OPENGL_LASTERROR("glTexStorage3D()");
		}

		glTexParameteri(textureType, GL_TEXTURE_BASE_LEVEL, 0);
		glTexParameteri(textureType, GL_TEXTURE_MAX_LEVEL, (int) levels - 1);
		THROW_OPENGL_LASTERROR("glTexParameteri(GL_TEXTURE_MAX_LEVEL | GL_TEXTURE_MAX_LEVEL)");

		if (data)
		{
			result.write(textureType, 0, data, dataType, dataFormat, width, height, depth);

			if (levelsOrGen == 0)
				result.genMipMaps(textureType);
		}

		return result;
	}

	void filterMode(GLenum textureType, GLint min, GLint mag)
	{
		bind(textureType);
		glTexParameteri(textureType, GL_TEXTURE_MAG_FILTER, mag);
		glTexParameteri(textureType, GL_TEXTURE_MIN_FILTER, min);
		THROW_OPENGL_LASTERROR("glTexParameteri(GL_TEXTURE_MAG_FILTER | GL_TEXTURE_MIN_FILTER)");
	}
	void filterNearest(GLenum textureType) { filterMode(textureType, GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST); }
	void filterLinear(GLenum textureType) { filterMode(textureType, GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);  }

	void wrapMode(GLenum textureType, GLint mode)
	{
		bind(textureType);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_S, mode);
		glTexParameteri(textureType, GL_TEXTURE_WRAP_T, mode);
		if (is3DTexture(textureType))
			glTexParameteri(textureType, GL_TEXTURE_WRAP_R, mode);
		THROW_OPENGL_LASTERROR("glTexParameteri(GL_TEXTURE_WRAP_*)");
	}
	void wrapRepeat(GLenum textureType) { wrapMode(textureType, GL_REPEAT); }
	void wrapClamp(GLenum textureType) { wrapMode(textureType, GL_CLAMP_TO_EDGE); }

	void write(GLenum textureType, size_t level
		, void const* data, GLenum dataType, GLenum dataFormat
		, size_t width, size_t height, size_t depth = 0
		, size_t offsetX = 0, size_t offsetY = 0, size_t offsetZ = 0)
	{
		bind(textureType);

		if (depth == 0) {
			glTexSubImage2D(textureType, (GLsizei) level, (GLsizei) offsetX, (GLsizei) offsetY
				, (GLsizei) width, (GLsizei) height
				, dataFormat, dataType, data);
			THROW_OPENGL_LASTERROR("glTexSubImage2D()");
		}
		else {
			glTexSubImage3D(textureType, (GLsizei) level, (GLsizei) offsetX, (GLsizei) offsetY, (GLsizei) offsetZ
				, (GLsizei) width, (GLsizei) height, (GLsizei) depth
				, dataFormat, dataType, data);
			THROW_OPENGL_LASTERROR("glTexSubImage3D()");
		}
	}

	void genMipMaps(GLenum textureType)
	{
		bind(textureType);
		glGenerateMipmap(textureType);
		THROW_OPENGL_LASTERROR("glGenerateMipmap()");
	}
};
typedef TextureRef::owned Texture;

#pragma pack(push, 1)
struct TextureDesc
{
	typedef Texture resource;

	GLenum textureType;
	GLenum internalFormat;
	size_t width;
	size_t height;
	size_t depth;
	size_t levelsOrGen;

	static TextureDesc make2D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t levelsOrGen = 1)
	{
		return make3D(textureType, internalFormat, width, height, 0, levelsOrGen);
	}

	static TextureDesc make3D(GLenum textureType, GLenum internalFormat, size_t width, size_t height, size_t depth, size_t levelsOrGen = 1)
	{
		TextureDesc desc = { textureType, internalFormat, width, height, depth, levelsOrGen };
		return desc;
	}

	Texture create(void const* data = nullptr, GLenum dataType = GL_FLOAT, GLenum dataFormat = GL_RED) const
	{
		return Texture::create3D(textureType, internalFormat, width, height, depth, levelsOrGen
			, data, dataType, dataFormat);
	}
};
#pragma pack(pop)

struct SamplerRef : glew_destroy<SamplerRef, GLuint, glDeleteSamplers>
{
	SamplerRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	SamplerRef(GLuint ref) { this->ref = ref; }

	static owned create()
	{
		owned r = nullptr;
		glGenSamplers(1, &r.ref);
		THROW_OPENGL_LASTERROR("glGenSamplers()");
		return r;
	}

	void bind(unsigned slot = 0)
	{
		glBindSampler(slot, *this);
	}

	static void unbind(unsigned slot = 0)
	{
		glBindSampler(slot, 0);
	}

	static owned createLinear(GLint wrapMode = GL_REPEAT, GLint min = GL_LINEAR_MIPMAP_LINEAR, GLint mag = GL_LINEAR)
	{
		auto r = create();
		r.filterMode(min, mag);
		r.wrapMode(wrapMode);
		return r;
	}
	static owned createNearest(GLint wrapMode = GL_REPEAT, GLint min = GL_NEAREST_MIPMAP_NEAREST, GLint mag = GL_NEAREST)
	{
		auto r = create();
		r.filterMode(min, mag);
		r.wrapMode(wrapMode);
		r.anisotropy(1);
		return r;
	}

	void filterMode(GLint min, GLint mag)
	{
		glSamplerParameteri(*this, GL_TEXTURE_MAG_FILTER, mag);
		glSamplerParameteri(*this, GL_TEXTURE_MIN_FILTER, min);
		THROW_OPENGL_LASTERROR("glSamplerParameteri(GL_TEXTURE_MAG_FILTER | GL_TEXTURE_MIN_FILTER)");
	}
	void filterNearest() { filterMode(GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST); }
	void filterLinear() { filterMode(GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR);  }

	void wrapMode(GLint mode)
	{
		glSamplerParameteri(*this, GL_TEXTURE_WRAP_S, mode);
		glSamplerParameteri(*this, GL_TEXTURE_WRAP_T, mode);
		glSamplerParameteri(*this, GL_TEXTURE_WRAP_R, mode);
		THROW_OPENGL_LASTERROR("glSamplerParameteri(GL_TEXTURE_WRAP_*)");
	}
	void wrapRepeat() { wrapMode(GL_REPEAT); }
	void wrapClamp() { wrapMode(GL_CLAMP_TO_EDGE); }

	void levels(size_t level, size_t count = 1)
	{
		glSamplerParameteri(*this, GL_TEXTURE_BASE_LEVEL, int(level));
		glSamplerParameteri(*this, GL_TEXTURE_MAX_LEVEL, int(level + count - 1));
		THROW_OPENGL_LASTERROR("glSamplerParameteri(GL_TEXTURE_BASE_LEVEL | GL_TEXTURE_MAX_LEVEL)");
	}

	void anisotropy(float maxAnisotropy)
	{
		glSamplerParameterf(*this, GL_TEXTURE_MAX_ANISOTROPY_EXT, maxAnisotropy);
		THROW_OPENGL_LASTERROR("glSamplerParameterf(GL_TEXTURE_MAX_ANISOTROPY_EXT)");
	}
};
typedef SamplerRef::owned Sampler;

struct RenderBufferRef : glew_destroy<RenderBufferRef, GLuint, glDeleteRenderbuffers>
{
	RenderBufferRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	RenderBufferRef(GLuint ref) { this->ref = ref; }

	static owned create()
	{
		owned r = nullptr;
		glGenRenderbuffers(1, &r.ref);
		THROW_OPENGL_LASTERROR("glGenRenderbuffers()");
		return r;
	}

	void bind()
	{
		glBindRenderbuffer(GL_RENDERBUFFER, *this);
	}

	static void unbind()
	{
		glBindRenderbuffer(GL_RENDERBUFFER, 0);
	}

	static owned create(GLenum internalFormat, size_t width, size_t height, size_t samples = 1)
	{
		auto result = create();
		result.bind();

		if(samples > 1)
		{
			glRenderbufferStorageMultisample(GL_RENDERBUFFER, (GLsizei) samples, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glRenderbufferStorageMultisample()");
		}
		else
		{
			glRenderbufferStorage(GL_RENDERBUFFER, internalFormat, (GLsizei) width, (GLsizei) height);
			THROW_OPENGL_LASTERROR("glRenderbufferStorage()");
		}

		return result;
	}
};
typedef RenderBufferRef::owned RenderBuffer;

#pragma pack(push, 1)
struct RenderBufferDesc
{
	typedef RenderBuffer resource;

	GLenum internalFormat;
	size_t width;
	size_t height;
	size_t samples;

	static RenderBufferDesc make(GLenum internalFormat, size_t width, size_t height, size_t samples = 1)
	{
		RenderBufferDesc desc = { internalFormat, width, height, samples };
		return desc;
	}

	RenderBuffer create() const
	{
		return RenderBuffer::create(internalFormat, width, height, samples);
	}
};
#pragma pack(pop)

template <class Resource>
struct AutoTarget : Resource
{
	MOVE_GENERATE(AutoTarget, MOVE_2, BASE, Resource, MEMBER, target)

	using Resource::operator =;

	GLenum target;

	AutoTarget(GLenum target, Resource resource)
		: Resource(std::move(resource))
		, target(target) { }

	void bind()
	{
		Resource::bind(target);
	}

	void unbind()
	{
		Resource::unbind(target);
	}

	void bind(unsigned slot)
	{
		Resource::bind(target, slot);
	}

	void unbind(unsigned slot)
	{
		Resource::unbind(target, slot);
	}
};

template <class R>
inline AutoTarget<R> auto_target(GLenum target, R resource) { return AutoTarget<R>(target, std::move(resource)); }

template <class Target, class Slot>
struct BindingInfo
{
	Target target;
	Slot slot;

	template <class Resource> void bind(Resource& res) { res.bind(target, slot); }
	template <class Resource> void unbind(Resource& res) { res.unbind(target, slot); }
};
template <class Target>
struct BindingInfo<Target, void>
{
	Target target;

	template <class Resource> void bind(Resource& res) { res.bind(target); }
	template <class Resource> void unbind(Resource& res) { res.unbind(target); }
};
template <class Slot>
struct BindingInfo<void, Slot>
{
	Slot slot;

	template <class Resource> void bind(Resource& res) { res.bind(slot); }
	template <class Resource> void unbind(Resource& res) { res.unbind(slot); }
};
template <>
struct BindingInfo<void, void>
{
	template <class Resource> static void bind(Resource& res) { res.bind(); }
	template <class Resource> static void unbind(Resource& res) { res.unbind(); }
};

template <class T, class BindInfo>
struct BindGuard
{
	MOVE_GENERATE(BindGuard, MOVE_2, MEMBER, info, MEMBER, bound)

	BindInfo info;
	T* bound;

	BindGuard(std::nullptr_t)
		: bound(nullptr) { }
	BindGuard(BindInfo info, T &bound)
		: info(info)
		, bound(&bound)
	{
		info.bind(bound);
	}
	~BindGuard()
	{
		if (bound)
			info.bind(*bound);
	}

	void disarm() { bound = nullptr; }
};

template <class T>
inline BindGuard<T, BindingInfo<void, void>> bind_guarded(T &bound) { return BindGuard<T, BindingInfo<void, void>>(BindingInfo<void, void>(), bound); }
template <class T>
inline BindGuard<T, BindingInfo<void, unsigned>> bind_guarded(T &bound, unsigned slot) { BindingInfo<void, unsigned> info = { slot }; return BindGuard<T, decltype(info)>(info, bound); }
template <class T>
inline BindGuard<T, BindingInfo<GLenum, void>> bind_guarded(GLenum target, T &bound) { BindingInfo<GLenum, void> info = { target }; return BindGuard<T, decltype(info)>(info, bound); }
template <class T>
inline BindGuard<T, BindingInfo<GLenum, unsigned>> bind_guarded(GLenum target, T &bound, unsigned slot) { BindingInfo<GLenum, unsigned> info = { target, slot }; return BindGuard<T, decltype(info)>(info, bound); }

struct VertexArraysRef : glew_destroy<VertexArraysRef, GLuint, glDeleteVertexArrays>
{
	VertexArraysRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	VertexArraysRef(GLuint ref) { this->ref = ref; }

	static owned create()
	{
		owned r = nullptr;
		glGenVertexArrays(1, &r.ref);
		THROW_OPENGL_LASTERROR("glGenVertexArrays()");
		return r;
	}

	void bind()
	{
		glBindVertexArray(*this);
	}

	static void unbind()
	{
		glBindVertexArray(0);
	}
};
typedef VertexArraysRef::owned VertexArrays;

struct FramebufferRef : glew_destroy<FramebufferRef, GLuint, glDeleteFramebuffers>
{
	FramebufferRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	FramebufferRef(GLuint ref) { this->ref = ref; }

	static owned create()
	{
		owned r = nullptr;
		glGenFramebuffers(1, &r.ref);
		THROW_OPENGL_LASTERROR("glGenFramebuffers()");
		return r;
	}

	void bind(GLenum target = GL_FRAMEBUFFER)
	{
		glBindFramebuffer(target, *this);
	}
	static void unbind(GLenum target = GL_FRAMEBUFFER)
	{
		glBindFramebuffer(target, 0);
	}

	static void copy(GLuint src, GLuint dest, size_t width, size_t height
		, size_t srcX = 0, size_t srcY = 0, size_t destX = 0, size_t destY = 0
		, GLbitfield mask = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT
		, GLbitfield filter = GL_NEAREST)
	{
		glBindFramebuffer(GL_READ_FRAMEBUFFER, src);
		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, dest);

		glBlitFramebuffer(
			  GLint(srcX), GLint(srcY), GLint(srcX + width), GLint(srcY + height)
			, GLint(destX), GLint(destY), GLint(destX + width), GLint(destY + height)
			, mask, filter
			);
		THROW_OPENGL_LASTERROR("glBlitFramebuffer()");
	}

	static void attachTextureToBound(GLenum attachment, GLuint texture, size_t level = 0)
	{
		glFramebufferTexture(GL_FRAMEBUFFER, attachment, texture, GLint(level));
		THROW_OPENGL_LASTERROR("glFramebufferTexture()");
	}
	static void attachRenderbufferToBound(GLenum attachment, GLuint renderBuffer)
	{
		glFramebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, renderBuffer);
		THROW_OPENGL_LASTERROR("glFramebufferRenderbuffer()");
	}

	static owned create(GLuint const* textures, size_t textureCount, GLuint depthBuffer = 0
		, GLenum depthBufferType = GL_RENDERBUFFER, GLenum colorBufferType = GL_TEXTURE_2D)
	{
		auto result = create();
		result.bind();

		std::vector<GLenum> attachmentMapping(textureCount);

		for (size_t i = 0; i < textureCount; ++i)
		{
			GLenum attachment = (GLenum) (GL_COLOR_ATTACHMENT0 + i);
			if (colorBufferType != GL_RENDERBUFFER)
				attachTextureToBound(attachment, textures[i]);
			else
				attachRenderbufferToBound(attachment, textures[i]);
			attachmentMapping[i] = attachment;
		}

		glReadBuffer(GL_COLOR_ATTACHMENT0);
		glDrawBuffers((GLsizei) attachmentMapping.size(), attachmentMapping.data());

		if (depthBuffer)
		{
			if (depthBufferType == GL_RENDERBUFFER)
				attachRenderbufferToBound(GL_DEPTH_ATTACHMENT, depthBuffer);
			else
				attachTextureToBound(GL_DEPTH_ATTACHMENT, depthBuffer);
		}

		return result;
	}
	static owned createFromRenderbuffers(GLuint const* buffers, size_t bufferCount, GLuint depthBuffer = 0
		, GLenum depthBufferType = GL_RENDERBUFFER, GLenum colorBufferType = GL_RENDERBUFFER)
	{
		return create(buffers, bufferCount, depthBuffer, depthBufferType, colorBufferType);
	}

	static owned createEmpty(size_t width, size_t height, size_t samples = 1)
	{
		auto result = create();
		result.bind();

		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_WIDTH, GLint(width));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_HEIGHT, GLint(height));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_SAMPLES, GLint(samples));
		glFramebufferParameteri(GL_FRAMEBUFFER, GL_FRAMEBUFFER_DEFAULT_LAYERS, 0);
		
		return result;
	}

	static FramebufferRef get_default()
	{
		return FramebufferRef(0U);
	}

	static GLuint getAttachementFromBound(GLenum attachment, GLenum target = GL_FRAMEBUFFER)
	{
		GLint object;
		glGetFramebufferAttachmentParameteriv(target, attachment, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &object);
		THROW_OPENGL_LASTERROR("glGetFramebufferAttachmentParameteriv()");
		return (GLuint) object;
	}
};
typedef FramebufferRef::owned Framebuffer;

#pragma pack(push, 1)

template <size_t MaxTextures = 4, GLuint DepthBufferType = 0, GLuint TextureType = GL_TEXTURE_2D>
struct FramebufferAttachments;

template <GLuint TextureType>
struct FramebufferAttachments<0, 0, TextureType>
{
	typedef FramebufferAttachments without_depth;

	static size_t const maxTextures = 0;
	static GLuint const textureType = TextureType;
	static GLuint const textures[1];
	static GLuint const depthType = GL_RENDERBUFFER;
	static GLuint const depth = 0;

	void assign(FramebufferAttachments const& other) { }
};
template <GLuint TextureType>
GLuint const FramebufferAttachments<0, 0, TextureType>::textures[1] = { 0 };

template <size_t MaxTextures, GLuint TextureType>
struct FramebufferAttachments<MaxTextures, 0, TextureType>
{
	typedef FramebufferAttachments without_depth;

	static size_t const maxTextures = MaxTextures;
	static GLuint const textureType = TextureType;
	GLuint textures[maxTextures];
	static GLuint const depthType = GL_RENDERBUFFER;
	static GLuint const depth = 0;

	template <size_t MT>
	void assign(FramebufferAttachments<MT, 0, TextureType> const& other)
	{
		static_assert(MT <= MaxTextures, "Texture storage mismatch");
		for (size_t i = 0; i < MT; ++i) this->textures[i] = other.textures[i];
		for (size_t i = MT; i < MaxTextures; ++i) this->textures[i] = 0;
	}
};

template <size_t MaxTextures, GLuint DepthBufferType, GLuint TextureType>
struct FramebufferAttachments : FramebufferAttachments<MaxTextures, 0, TextureType>
{
	static GLuint const depthType = DepthBufferType;
	GLuint depth;

	template <size_t MT, GLuint DBT>
	void assign(FramebufferAttachments<MT, DBT, TextureType> const& other)
	{
		typedef typename FramebufferAttachments::without_depth without_depth_t;
		this->without_depth_t::assign(other);
		static_assert(DBT == 0 || DBT == DepthBufferType, "Depth buffer type mismatch");
		this->depth = other.depth;
	}
};

template <>
struct FramebufferAttachments<0, 0, 0> // : FramebufferAttachments<0, 0, GL_TEXTURE_2D>
{
	size_t width;
	size_t height;
	size_t samples;
};

template <size_t MaxTextures = 4, GLuint DepthBufferType = 0, GLuint TextureType = GL_TEXTURE_2D>
struct FramebufferDesc : FramebufferAttachments<MaxTextures, DepthBufferType, TextureType>
{
	typedef Framebuffer resource;
	typedef std::true_type is_shared;

	template <size_t MT>
	Framebuffer _create(std::integral_constant<size_t, MT>) const
	{
		return Framebuffer::create(this->textures, this->maxTextures, this->depth, this->depthType, this->textureType);
	}
	Framebuffer _create(std::integral_constant<size_t, 0>) const
	{
		return Framebuffer::createEmpty(this->width, this->height, this->samples);
	}

	Framebuffer create() const
	{
		return _create(std::integral_constant<size_t, MaxTextures>());
	}
};

#pragma pack(pop)

struct MakeFramebufferDesc
{
	template <size_t MaxTextures, GLuint DepthBufferType, GLuint TextureType>
	struct State : FramebufferDesc<MaxTextures, DepthBufferType, TextureType>
	{
		State<MaxTextures + 1, DepthBufferType, TextureType> color(GLuint att)
		{
			State<MaxTextures + 1, DepthBufferType, TextureType> next;
			next.assign(*this);
			next.textures[MaxTextures] = att;
			return next;
		}

		State<MaxTextures, GL_RENDERBUFFER, TextureType> depthBuffer(GLuint att)
		{
			State<MaxTextures, GL_RENDERBUFFER, TextureType> next;
			next.without_depth::assign(*this);
			next.depth = att;
			return next;
		}

		State<MaxTextures, GL_TEXTURE_2D, TextureType> depthTexture(GLuint att)
		{
			State<MaxTextures, GL_TEXTURE_2D, TextureType> next;
			next.without_depth::assign(*this);
			next.depth = att;
			return next;
		}
	};

	static FramebufferDesc<0, 0, 0> empty(size_t width, size_t height, size_t samples = 1)
	{
		FramebufferDesc<0, 0, 0> r;
		r.width = width;
		r.height = height;
		r.samples = samples;
		return r;
	}
	static State<0, 0, GL_TEXTURE_2D> textures()
	{
		return State<0, 0, GL_TEXTURE_2D>();
	}
	static State<0, 0, GL_RENDERBUFFER> renderBuffers()
	{
		return State<0, 0, GL_RENDERBUFFER>();
	}
};

template <class Resource>
struct AutoViewport : Resource
{
	MOVE_GENERATE(AutoViewport, MOVE_5, BASE, Resource, MEMBER, x, MEMBER, y, MEMBER, width, MEMBER, height)

	using Resource::operator =;

	GLint x;
	GLint y;
	GLint width;
	GLint height;

	AutoViewport(std::nullptr_t) : Resource(nullptr) { }
	AutoViewport(Resource resource, size_t width, size_t height, int x = 0, int y = 0)
		: Resource(std::move(resource))
		, x(GLint(x))
		, y(GLint(y))
		, width(GLint(width))
		, height(GLint(height))
	{ }

	void bind(GLenum target = GL_FRAMEBUFFER)
	{
		Resource::bind(target);
		glViewport(x, y, width, height);
	}
};

template <class R>
inline AutoViewport<R> auto_viewport(R resource, size_t width, size_t height, int x = 0, int y = 0)
{	return AutoViewport<R>(std::move(resource), width, height, x, y); }

struct ShaderRef : glew_destroy_single<ShaderRef, GLuint, glDeleteShader>
{
	ShaderRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	ShaderRef(GLuint ref) { this->ref = ref; }

	static owned create(GLenum shaderType)
	{
		owned r( glCreateShader(shaderType) );
		THROW_OPENGL_LASTERROR("glCreateShader()");
		return r;
	}

	static owned compile(GLenum shaderType, char const* source, char const* preamble = "")
	{
		auto result = create(shaderType);

		char const* shaderTypePreamble;
		switch (shaderType)
		{
		case GL_COMPUTE_SHADER: shaderTypePreamble = "#define cs_main main\n#define IN_CS\n"; break;
		case GL_VERTEX_SHADER: shaderTypePreamble = "#define vs_main main\n#define IN_VS\n#define VERTEX_OUT\n#define VERTEX_OUT_ARRAY\n"; break;
		case GL_FRAGMENT_SHADER: shaderTypePreamble = "#define fs_main main\n#define IN_FS\n#define VERTEX_IN\n#define VERTEX_IN_ARRAY\n"; break;
		case GL_GEOMETRY_SHADER: shaderTypePreamble = "#define gs_main main\n#define IN_GS\n#define VERTEX_IN\n#define VERTEX_IN_ARRAY []\n#define VERTEX_OUT\n#define VERTEX_OUT_ARRAY []\n"; break;
		case GL_TESS_CONTROL_SHADER: shaderTypePreamble = "#define tcs_main main\n#define IN_TCS\n#define VERTEX_IN\n#define VERTEX_IN_ARRAY []\n#define VERTEX_OUT\n#define VERTEX_OUT_ARRAY []\n"; break;
		case GL_TESS_EVALUATION_SHADER: shaderTypePreamble = "#define tes_main main\n#define IN_TES\n#define VERTEX_IN\n#define VERTEX_IN_ARRAY []\n#define VERTEX_OUT\n#define VERTEX_OUT_ARRAY\n"; break;
		default: shaderTypePreamble = "";
		};

		char const* sources[] = { nullptr, nullptr, shaderTypePreamble, preamble, source, nullptr, nullptr };
		int sourceLens[] = { 0, 0, -1, -1, -1, 0, 0 };
		static_assert(arraylen(sourceLens) == arraylen(sources), "strlen array dim mismatch");

		// move version to the beginning
		if (auto versionDir = strstr(source, "#version"))
		{
			sources[0] = versionDir;
			auto endOfVersionDir = strchr(versionDir, '\n');
			sourceLens[0] = (endOfVersionDir) ? int(endOfVersionDir - versionDir) : -1;

			sources[1] = "\n";
			sourceLens[1] = 1;

			sources[4] = source;
			sourceLens[4] = int(versionDir - source);

			sources[5] = "// moved: ";
			sourceLens[5] = -1;

			sources[6] = versionDir;
			sourceLens[6] = -1;
		}

		// Everything that follows minimizes driver incompatibilities
		int sourceCount = 0;
		size_t totalSourceLen = 0;
		for (size_t i = 0; i < arraylen(sources); ++i)
		{
			auto src = sources[i];
			auto srcLen = sourceLens[i];
			if (!src) srcLen = 0;
			if (srcLen < 0) srcLen = (int) strlen(src);
			if (srcLen > 0)
			{
				sources[sourceCount] = src;
				sourceLens[sourceCount] = srcLen;
				++sourceCount;
				totalSourceLen += srcLen;
			}
		}

		// Seriously, nothing works: Concatenate manually
		std::string testSrc;
		testSrc.reserve(totalSourceLen);
		for (int i = 0; i < sourceCount; ++i)
			testSrc.append(sources[i], sources[i] + sourceLens[i]);
		assert(testSrc.size() == totalSourceLen);
		sources[0] = testSrc.c_str();
		sourceLens[0] = (int) totalSourceLen;
		sourceCount = 1;
		// fall back to most common use case
		glShaderSource(result, 1, sources, nullptr);

//		glShaderSource(result, sourceCount, sources, sourceLens);
		THROW_OPENGL_LASTERROR("glShaderSource()");

		glCompileShader(result);
		THROW_OPENGL_LASTERROR("glCompileShader()");

		if (!printBuildLog(result))
			THROW_OPENGL_ERROR(GL_INVALID_OPERATION, "Failed to build OpenGL shader");

		return result;
	}

	static bool printBuildLog(GLuint shader)
	{
		GLint status;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
		THROW_OPENGL_LASTERROR("glGetShaderiv(GL_COMPILE_STATUS)");

		GLint logSize;
		glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logSize);
		THROW_OPENGL_LASTERROR("glGetShaderiv(GL_INFO_LOG_LENGTH)");
		
		if (logSize > 1)
		{
			std::string log(logSize, 0);
			glGetShaderInfoLog(shader, (GLsizei) log.size(), nullptr, &log[0]);
			THROW_OPENGL_LASTERROR("glGetShaderInfoLog()");

			std::cerr << ((status) ? "Build info:\n" : "There were build errors:\n")
				<< log << std::endl;
		}

		return (status == GL_TRUE);
	}

	static owned fromFile(GLenum shaderType, char const* file, char const* preamble = "")
	{
		return compile(shaderType, stdx::load_file(file).c_str(), preamble);
	}
};
typedef ShaderRef::owned Shader;

struct ProgramRef : glew_destroy_single<ProgramRef, GLuint, glDeleteProgram>
{
	ProgramRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	ProgramRef(GLuint ref) { this->ref = ref; }

	static owned create()
	{
		owned r( glCreateProgram() );
		THROW_OPENGL_LASTERROR("glCreateProgram()");

		glProgramParameteri(r, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRUE);
		THROW_OPENGL_LASTERROR("glProgramParameteri(GL_PROGRAM_BINARY_RETRIEVABLE_HINT)");
		return r;
	}

	void bind()
	{
		glUseProgram(*this);
	}
	static void unbind()
	{
		glUseProgram(0);
	}

	ProgramRef& attach(GLuint shader)
	{
		glAttachShader(*this, shader);
		THROW_OPENGL_LASTERROR("glAttachShader()");
		return *this;
	}

	void link()
	{
		glLinkProgram(*this);
		THROW_OPENGL_LASTERROR("glLinkProgram()");
		
		if (!printLinkLog(*this))
			THROW_OPENGL_ERROR(GL_INVALID_OPERATION, "Failed to link OpenGL program");
	}

	std::vector<char> getBinary(GLenum *format = nullptr) const
	{
		std::vector<char> result;
		GLint length;
		glGetProgramiv(*this, GL_PROGRAM_BINARY_LENGTH, &length);
		THROW_OPENGL_LASTERROR("glGetProgramiv()");
		result.resize((size_t) length);
		GLenum formatTmp;
		glGetProgramBinary(*this, (GLsizei) result.size(), &length, &formatTmp, result.data());
		THROW_OPENGL_LASTERROR("glGetProgramBinary()");
		if (format) *format = formatTmp;
		return result;
	}

	static bool printLinkLog(GLuint program)
	{
		GLint status;
		glGetProgramiv(program, GL_LINK_STATUS, &status);
		THROW_OPENGL_LASTERROR("glGetProgramiv(GL_LINK_STATUS)");

		GLint logSize;
		glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logSize);
		THROW_OPENGL_LASTERROR("glGetProgramiv(GL_INFO_LOG_LENGTH)");
		
		if (logSize > 1)
		{
			std::string log(logSize, 0);
			glGetProgramInfoLog(program, (GLsizei) log.size(), nullptr, &log[0]);
			THROW_OPENGL_LASTERROR("glGetProgramInfoLog()");

			std::cerr << ((status) ? "Link info:\n" : "There were linking errors:\n") 
				<< log << std::endl;
		}

		return (status == GL_TRUE);
	}

	static owned fromShaders(GLuint s1, GLuint s2 = 0, GLuint s3 = 0, GLuint s4 = 0, GLuint s5 = 0, GLuint s6 = 0)
	{
		auto result = create();
		if (s1) result.attach(s1);
		if (s2) result.attach(s2);
		if (s3) result.attach(s3);
		if (s4) result.attach(s4);
		if (s5) result.attach(s5);
		if (s6) result.attach(s6);
		result.link();
		return result;
	}
};
typedef ProgramRef::owned Program;

struct ProgramWithTime : Program
{
	enum Options
	{
		Default = 0x00, // Default is FS and VS, nothing else
		NoFS    = 0x01, // Fragment shader off, default ON
		NoVS    = 0x02, // Vertex shader off ...
		HasGS   = 0x04, // Geometry shader on, default OFF
		HasHS   = 0x08, // ...
		HasDS   = 0x10,
		HasCS   = 0x20
	};

	char const* preamble;
	std::string file;
	time_t time;
	unsigned options;
	bool compatibilityInclude;

	using Program::operator =;

	explicit ProgramWithTime(std::string file, char const *preamble = "", unsigned options = Options::Default, bool compatibilityInclude = OGL_COMPATIBILITY_PREPROCESSING)
		: Program(nullptr)
		, preamble(preamble)
		, file(std::move(file))
		, time(0)
		, options( (~options & HasCS) ? options : options | NoVS | NoFS ) // CS is exclusive
		, compatibilityInclude(compatibilityInclude)
	{
		load();
	}
	static std::string resolveIncludesCompat(char const* include, bool local)
	{
		return stdx::process_includes(stdx::load_file(include), include, resolveIncludesCompat, std::string(), true);
	}
	static std::string resolveIncludes(char const* include, bool local)
	{
		return stdx::process_includes(stdx::load_file(include), include, resolveIncludes);
	}
	void load()
	{
		auto& resolveFunc = (compatibilityInclude) ? resolveIncludesCompat : resolveIncludes;
		std::string src = resolveFunc(file.c_str(), true);

		*this = Program::fromShaders(
			!(options & Options::NoFS) ? (GLuint) Shader::compile(GL_FRAGMENT_SHADER, src.c_str(), preamble) : 0,
			!(options & Options::NoVS) ? (GLuint) Shader::compile(GL_VERTEX_SHADER, src.c_str(), preamble) : 0,
			(options & Options::HasGS) ? (GLuint) Shader::compile(GL_GEOMETRY_SHADER, src.c_str(), preamble) : 0,
			(options & Options::HasHS) ? (GLuint) Shader::compile(GL_TESS_CONTROL_SHADER, src.c_str(), preamble) : 0,
			(options & Options::HasDS) ? (GLuint) Shader::compile(GL_TESS_EVALUATION_SHADER, src.c_str(), preamble) : 0,
			(options & Options::HasCS) ? (GLuint) Shader::compile(GL_COMPUTE_SHADER, src.c_str(), preamble) : 0);

		time = stdx::file_time(file.c_str());
	}
	int maybeReload()
	{
		if (stdx::file_time(file.c_str()) > time)
		{
			try { load(); return 1; }
			catch (ogl_error const &) { return -1; }
		}
		return 0;
	}
};

struct EventRef : glew_destroy<EventRef, GLuint, glDeleteQueries>
{
	EventRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	EventRef(GLuint ref) { this->ref = ref; }

	static owned create()
	{
		owned r = nullptr;
		glGenQueries(1, &r.ref);
		THROW_OPENGL_LASTERROR("Failed to create OGL event");
		return r;
	}

	void record()
	{
		glQueryCounter(*this, GL_TIMESTAMP);
		THROW_OPENGL_LASTERROR("Failed to record OGL event");
	}
};
typedef EventRef::owned Event;

inline double diffMS(GLuint startEvent, GLuint endEvent, bool failQuiet = false)
{
	// synchronize
	for (GLint stopTimerAvailable = 0; !stopTimerAvailable; )
		glGetQueryObjectiv(endEvent, GL_QUERY_RESULT_AVAILABLE, &stopTimerAvailable);

	GLuint64 startTime, stopTime;
	glGetQueryObjectui64v(startEvent, GL_QUERY_RESULT, &startTime);
	glGetQueryObjectui64v(endEvent, GL_QUERY_RESULT, &stopTime);

	return double(stopTime - startTime) / 1000000.0;
}

struct SyncRef : glew_destroy_single<SyncRef, GLsync, glDeleteSync>
{
	SyncRef(std::nullptr_t DEFAULT_ASSIGN_NULL_REFERENCE) { this->ref = 0; }
	SyncRef(GLsync ref) { this->ref = ref; }

	static owned fence(GLenum condition, GLbitfield flags = 0)
	{
		owned r = nullptr;
		r.ref = glFenceSync(condition, flags);
		THROW_OPENGL_LASTERROR("Failed to create OGL fence");
		return r;
	}

	bool hostSync(GLuint64 timeout, GLbitfield flags = GL_SYNC_FLUSH_COMMANDS_BIT)
	{
		auto r = glClientWaitSync(ref, flags, timeout);
		THROW_OPENGL_LASTERROR("Failed to sync host");
		return r == GL_CONDITION_SATISFIED || r == GL_ALREADY_SIGNALED;
	}

	void deviceSync(GLuint64 timeout = GL_TIMEOUT_IGNORED, GLbitfield flags = 0)
	{
		glWaitSync(ref, flags, timeout);
		THROW_OPENGL_LASTERROR("Failed to sync device");
	}
};
typedef SyncRef::owned Sync;

struct NullVertexArray : VertexArrays
{
	MOVE_GENERATE(NullVertexArray, MOVE_2, BASE, VertexArrays, MEMBER, buffer)

	Buffer buffer;

	NullVertexArray(std::nullptr_t)
		: VertexArrays(nullptr)
		, buffer(nullptr)
	{
	}
	NullVertexArray()
		: VertexArrays( create() )
		, buffer( Buffer::create(GL_ARRAY_BUFFER, sizeof(float) * 4) )
	{
		bind();
		buffer.bind(GL_ARRAY_BUFFER);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 1, GL_FLOAT, GL_FALSE, 0, nullptr);
		buffer.unbind(GL_ARRAY_BUFFER);
		unbind();
	}
};

} // namespace
