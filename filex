#pragma once

#include "stdx"
#include <fstream>
#include <map>

namespace stdx
{
	struct file_tag;
	typedef stdx::error<file_tag> file_error;

	inline std::string load_file(char const* name)
	{
		std::string str;

		std::ifstream t(name);
		if (t.fail())
			throwx( file_error(name) );

		t.exceptions(std::ifstream::failbit | std::ifstream::badbit);
		t.seekg(0, std::ios::end);   
		str.reserve((size_t) t.tellg());
		t.seekg(0, std::ios::beg);

		str.assign(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());
		return str;
	}
	
	inline std::vector<char> load_binary_file(char const* name)
	{
		std::vector<char> data;

		std::ifstream t(name, std::ios_base::binary);
		if (t.fail())
			throwx( file_error(name) );

		t.exceptions(std::ifstream::failbit | std::ifstream::badbit);
		t.seekg(0, std::ios::end);   
		data.resize((size_t) t.tellg());
		t.seekg(0, std::ios::beg);

		t.read(data.data(), data.size());
		return data;
	}
	
	/// Character stream buffer class that is required to allow for allocation-free usage of STL streaming facilities.
	template < class Elem, class Traits = std::char_traits<Elem> >
	class basic_charbuf : public std::basic_streambuf<Elem, Traits>
	{
	protected:
		virtual void __CLR_OR_THIS_CALL _Lock() { }
		virtual void __CLR_OR_THIS_CALL _Unlock() { }

	public:
		typedef typename Traits::char_type char_type;

		/// Constructs a character stream buffer from the given character range.
		basic_charbuf(char_type *begin, char_type *end)
		{
			setp(begin, end);
			setg(begin, begin, end);
		}

		/// Resets the character stream buffer.
		void reset()
		{
			setp(pbase(), epptr());
			setg(eback(), eback(), egptr());
		}

		/// Gets the beginning of the underlying buffer.
		char_type* begin() const { return pbase(); }
		/// Gets the end of the underlying buffer.
		char_type* end() const { return epptr(); }
		/// Gets the current write position in the underlying buffer.
		char_type* write_end() const { return pptr(); }
		/// Gets the current read position in the underlying buffer.
		char_type* read_end() const { return gptr(); }

	};

	namespace impl
	{
		/// Helper class that allows for automatic stream buffer construction before stream base class construction.
		template < class Elem, class Traits = std::char_traits<Elem> >
		class charbuf_holder
		{
		protected:
			/// Stream buffer type.
			typedef basic_charbuf<Elem, Traits> stream_buffer;
			/// Stream buffer.
			stream_buffer m_buffer;

			/// Constructs a character stream buffer from the given character range.
			charbuf_holder(typename stream_buffer::char_type *begin, typename stream_buffer::char_type *end)
				: m_buffer(begin, end) { }
		};
	}

	// Obscure MS iostream warning
	#pragma warning(push)
	#pragma warning(disable : 4250)

	/// Character stream class that allows for allocation-free usage of STL streaming facilities.
	template < class Elem, class Traits = std::char_traits<Elem> >
	class basic_charstream : private impl::charbuf_holder<Elem, Traits>, public std::basic_iostream<Elem, Traits>
	{
	private:
		typedef impl::charbuf_holder<char_type, traits_type> holder_base_type;
		typedef std::basic_iostream<char_type, traits_type> stream_base_type;

	public:
		typedef typename Traits::char_type char_type;
		/// Stream buffer type.
		typedef typename holder_base_type::stream_buffer stream_buffer;

		/// Constructs a character stream from the given character range.
		basic_charstream(basic_charstream const &right)
				: holder_base_type(right.begin(), right.end()),
				stream_base_type(&m_buffer) { }
		/// Constructs a character stream from the given character range.
		basic_charstream(char_type *begin, char_type *end)
				: holder_base_type(begin, end),
				stream_base_type(&m_buffer) { }
		/// Constructs an unlimited character stream from the given character buffer pointer.
		basic_charstream(char_type *begin)
				: holder_base_type(begin, begin + std::numeric_limits<int>::max()), // required to be int
				stream_base_type(&m_buffer) { }

		/// Resets the character stream.
		basic_charstream& reset()
		{
			m_buffer.reset();
			return *this;
		}

		/// Returns the address of the stored stream buffer object.
		stream_buffer* rdbuf() const { return static_cast<stream_buffer*>(stream_base_type::rdbuf()); }

		/// Gets the beginning of the underlying buffer.
		char_type* begin() const { return m_buffer.begin(); }
		/// Gets the end of the underlying buffer.
		char_type* end() const { return m_buffer.end(); }
		/// Gets the current write position in the underlying buffer.
		char_type* write_end() const { return m_buffer.write_end(); }
		/// Gets the current read position in the underlying buffer.
		char_type* read_end() const { return m_buffer.read_end(); }

	};

	#pragma warning(pop)

	/// Character stream class.
	typedef basic_charstream<char> charstream;
	/// Wide-character stream class.
	typedef basic_charstream<wchar_t> wcharstream;
	
	struct parse_tag;
	typedef stdx::error<parse_tag> parse_error;

	template <class Char>
	std::map< std::basic_string<Char>, std::basic_string<Char> > parse_ini_file(Char const *file)
	{
		typedef std::basic_string<Char> string_type;
		std::map<string_type, string_type> contents;

		Char const *keyBegin = file, *keyEnd = file;

		for (; *file; ++file)
		{
			if (*file == Char('\n'))
			{
				Char const *valBegin = keyEnd + 1, *valEnd = file;

				// Trim key
				while (keyBegin < keyEnd && *keyBegin == Char(' '))
					++keyBegin;
				while (keyBegin < keyEnd && keyEnd[-1] == Char(' '))
					--keyEnd;

				// ORDER: Make sure key was complete with '='
				if (keyBegin != keyEnd)
				{
					// Trim value
					while (valBegin < valEnd && *valBegin == Char(' '))
						++valBegin;
					while (valBegin < valEnd && valEnd[-1] == Char(' '))
						--valEnd;

					contents[string_type(keyBegin, keyEnd)] = string_type(valBegin, valEnd);
				}

				keyBegin = keyEnd = file + 1;
			}
			else if (*file == Char('=') && keyBegin == keyEnd)
				keyEnd = file;
		}

		return contents;
	}
	
	template <class Char>
	basic_charstream<Char> get_ini_stream(std::map< std::basic_string<Char>, std::basic_string<Char> > const &contents, typename std::identity<std::basic_string<Char>>::type const &name)
	{
		auto it = contents.find(name);
		if (it == contents.end()) throwx(parse_error(name));
		auto begin = it->second.c_str(), end = begin + it->second.size();
		basic_charstream<Char> result(const_cast<Char*>(begin), const_cast<Char*>(end));
		result.exceptions(std::ios_base::failbit | std::ios_base::badbit);
		return result;
	}

	template <class Value, class Char>
	Value get_ini_value(std::map< std::basic_string<Char>, std::basic_string<Char> > const &contents, typename std::identity<std::basic_string<Char>>::type const &name)
	{
		Value result;
		get_ini_stream(contents, name) >> result;
		return result;
	}

	template <class Char>
	std::basic_string<Char> const& get_ini_value(std::map< std::basic_string<Char>, std::basic_string<Char> > const &contents, typename std::identity<std::basic_string<Char>>::type const &name)
	{
		auto it = contents.find(name);
		if (it == contents.end()) throwx(parse_error(name));	
		return it->second;
	}

} // namespace
