#pragma once

#include "stdx"
#include <fstream>
#include <sstream>
#include <string>
#include <map>
#include <vector>

#include <sys/types.h>
#include <sys/stat.h>

namespace stdx
{
	struct file_tag;
	typedef stdx::error<file_tag> file_error;

	inline time_t file_time(char const* name)
	{
		struct stat buf;
		stat(name, &buf);
		return buf.st_mtime;
	}

	inline void enable_stream_exceptions(std::ios_base &t)
	{
		t.exceptions(std::ifstream::failbit | std::ifstream::badbit);
	}

	inline std::ifstream read_file(char const* name, std::ios_base::openmode om = std::ios_base::in)
	{
		std::ifstream t(name, om);
		if (t.fail())
			throwx( file_error(name) );

		enable_stream_exceptions(t);
		return t;
	}
	inline std::ifstream read_binary_file(char const* name, std::ios_base::openmode om = std::ios_base::in)
	{
		return read_file(name, om | std::ios_base::binary);
	}

	inline std::ofstream write_file(char const* name, std::ios_base::openmode om = std::ios_base::trunc)
	{
		std::ofstream t(name, om);
		if (t.fail())
			throwx( file_error(name) );

		enable_stream_exceptions(t);
		return t;
	}
	inline std::ofstream write_binary_file(char const* name, std::ios_base::openmode om = std::ios_base::trunc)
	{
		return write_file(name, om | std::ios_base::binary);
	}

	inline std::string load_file(char const* name)
	{
		std::string str;

		auto t = read_file(name);
		t.seekg(0, std::ios::end);   
		str.reserve((size_t) t.tellg());
		t.seekg(0, std::ios::beg);

		str.assign(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());
		return str;
	}
	
	inline std::vector<char> load_binary_file(char const* name, bool nullterminated = false)
	{
		std::vector<char> data;

		auto t = read_binary_file(name);
		t.seekg(0, std::ios::end);
		size_t fileSize = (size_t) t.tellg();
		data.resize(fileSize + (size_t) nullterminated);
		t.seekg(0, std::ios::beg);

		t.read(data.data(), fileSize);
		return data;
	}
	
	template <class T>
	inline void serialize_binary(std::ostream& stream, T const& val) {
		stream.write(&reinterpret_cast<char const&>(val), sizeof(val)); }
	template <class T>
	inline void serialize_binary(std::istream& stream, T& val) {
		stream.read(&reinterpret_cast<char&>(val), sizeof(val)); }

	template <class Range>
	inline void serialize_container_binary(std::ostream& stream, Range const& range) {
		serialize_binary(stream, range.size());
		stream.write(reinterpret_cast<char const*>(range.data()), sizeof(*range.data()) * range.size());
	}
	template <class Range>
	inline void serialize_container_binary(std::istream& stream, Range& range) {
		size_t size = 0;
		serialize_binary(stream, size);
		range.resize(size);
		stream.read(reinterpret_cast<char*>(range.data()), sizeof(*range.data()) * range.size());
	}

	/// Character stream buffer class that is required to allow for allocation-free usage of STL streaming facilities.
	template < class Elem, class Traits = std::char_traits<Elem> >
	class basic_charbuf : public std::basic_streambuf<Elem, Traits>
	{
	protected:
		virtual void __CLR_OR_THIS_CALL _Lock() { }
		virtual void __CLR_OR_THIS_CALL _Unlock() { }

	public:
		typedef typename Traits::char_type char_type;

		/// Constructs a character stream buffer from the given character range.
		basic_charbuf(char_type *begin, char_type *end)
		{
			setp(begin, end);
			setg(begin, begin, end);
		}

		/// Resets the character stream buffer.
		void reset()
		{
			setp(pbase(), epptr());
			setg(eback(), eback(), egptr());
		}

		/// Gets the beginning of the underlying buffer.
		char_type* begin() const { return pbase(); }
		/// Gets the end of the underlying buffer.
		char_type* end() const { return epptr(); }
		/// Gets the current write position in the underlying buffer.
		char_type* write_end() const { return pptr(); }
		/// Gets the current read position in the underlying buffer.
		char_type* read_end() const { return gptr(); }

	};

	namespace impl
	{
		/// Helper class that allows for automatic stream buffer construction before stream base class construction.
		template < class Elem, class Traits = std::char_traits<Elem> >
		class charbuf_holder
		{
		protected:
			/// Stream buffer type.
			typedef basic_charbuf<Elem, Traits> stream_buffer;
			/// Stream buffer.
			stream_buffer m_buffer;

			/// Constructs a character stream buffer from the given character range.
			charbuf_holder(typename stream_buffer::char_type *begin, typename stream_buffer::char_type *end)
				: m_buffer(begin, end) { }
		};
	}

	// Obscure MS iostream warning
	#pragma warning(push)
	#pragma warning(disable : 4250)

	/// Character stream class that allows for allocation-free usage of STL streaming facilities.
	template < class Elem, class Traits = std::char_traits<Elem> >
	class basic_charstream : private impl::charbuf_holder<Elem, Traits>, public std::basic_iostream<Elem, Traits>
	{
	private:
		typedef impl::charbuf_holder<char_type, traits_type> holder_base_type;
		typedef std::basic_iostream<char_type, traits_type> stream_base_type;

	public:
		typedef typename Traits::char_type char_type;
		/// Stream buffer type.
		typedef typename holder_base_type::stream_buffer stream_buffer;

		/// Constructs a character stream from the given character range.
		basic_charstream(basic_charstream const &right)
				: holder_base_type(right.begin(), right.end()),
				stream_base_type(&m_buffer) { }
		/// Constructs a character stream from the given character range.
		basic_charstream(char_type *begin, char_type *end)
				: holder_base_type(begin, end),
				stream_base_type(&m_buffer) { }
		/// Constructs an unlimited character stream from the given character buffer pointer.
		basic_charstream(char_type *begin)
				: holder_base_type(begin, begin + std::numeric_limits<int>::max()), // required to be int
				stream_base_type(&m_buffer) { }

		/// Resets the character stream.
		basic_charstream& reset()
		{
			m_buffer.reset();
			return *this;
		}

		/// Returns the address of the stored stream buffer object.
		stream_buffer* rdbuf() const { return static_cast<stream_buffer*>(stream_base_type::rdbuf()); }

		/// Gets the beginning of the underlying buffer.
		char_type* begin() const { return m_buffer.begin(); }
		/// Gets the end of the underlying buffer.
		char_type* end() const { return m_buffer.end(); }
		/// Gets the current write position in the underlying buffer.
		char_type* write_end() const { return m_buffer.write_end(); }
		/// Gets the current read position in the underlying buffer.
		char_type* read_end() const { return m_buffer.read_end(); }

	};

	#pragma warning(pop)

	/// Character stream class.
	typedef basic_charstream<char> charstream;
	/// Wide-character stream class.
	typedef basic_charstream<wchar_t> wcharstream;
	
	struct parse_tag;
	typedef stdx::error<parse_tag> parse_error;

	template <class Char>
	std::map< std::basic_string<Char>, std::basic_string<Char> > parse_ini_file(Char const *file)
	{
		typedef std::basic_string<Char> string_type;
		std::map<string_type, string_type> contents;

		Char const *keyBegin = file, *keyEnd = file;

		for (; *file; ++file)
		{
			if (*file == Char('\n'))
			{
				Char const *valBegin = keyEnd + 1, *valEnd = file;

				// Trim key
				while (keyBegin < keyEnd && *keyBegin == Char(' '))
					++keyBegin;
				while (keyBegin < keyEnd && keyEnd[-1] == Char(' '))
					--keyEnd;

				// ORDER: Make sure key was complete with '='
				if (keyBegin != keyEnd)
				{
					// Trim value
					while (valBegin < valEnd && *valBegin == Char(' '))
						++valBegin;
					while (valBegin < valEnd && valEnd[-1] == Char(' '))
						--valEnd;

					contents[string_type(keyBegin, keyEnd)] = string_type(valBegin, valEnd);
				}

				keyBegin = keyEnd = file + 1;
			}
			else if (*file == Char('=') && keyBegin == keyEnd)
				keyEnd = file;
		}

		return contents;
	}
	
	template <class Char>
	basic_charstream<Char> get_ini_stream(std::map< std::basic_string<Char>, std::basic_string<Char> > const &contents, typename std::identity<std::basic_string<Char>>::type const &name)
	{
		auto it = contents.find(name);
		if (it == contents.end()) throwx(parse_error(name));
		auto begin = it->second.c_str(), end = begin + it->second.size();
		basic_charstream<Char> result(const_cast<Char*>(begin), const_cast<Char*>(end));
		enable_stream_exceptions(result);
		return result;
	}

	template <class Value, class Char>
	Value get_ini_value(std::map< std::basic_string<Char>, std::basic_string<Char> > const &contents, typename std::identity<std::basic_string<Char>>::type const &name)
	{
		Value result;
		get_ini_stream(contents, name) >> result;
		return result;
	}

	template <class Char>
	std::basic_string<Char> const& get_ini_value(std::map< std::basic_string<Char>, std::basic_string<Char> > const &contents, typename std::identity<std::basic_string<Char>>::type const &name)
	{
		auto it = contents.find(name);
		if (it == contents.end()) throwx(parse_error(name));	
		return it->second;
	}

	namespace detail
	{
		namespace process_includes
		{
			template <class T>
			auto string_find(std::string const& str, T const& val, char const* cursor) -> char const*
			{
				size_t pos = str.find(val, cursor - str.data());
				return (pos != std::string::npos) ? str.data() + pos : str.data() + str.size();
			};
		}
	}

	template <class Resolve>
	std::string process_includes(std::string const& src, std::string const& filename, Resolve const& resolve_include, std::string const& preamble = std::string())
	{
		using namespace detail::process_includes;

		std::stringstream result;
		if (!preamble.empty())
			result << preamble << std::endl;

		char const *srcBegin = src.data(), *srcEnd = srcBegin + src.size();
		auto nextSrcCursor = srcBegin;
		size_t nextSrcLine = 1;

		while (nextSrcCursor < srcEnd)
		{
			auto nextIncludeCursor = string_find(src, "#include", nextSrcCursor);

			result << "#line " << nextSrcLine << " \"" << filename << "\"\n";
			result.write(nextSrcCursor, nextIncludeCursor - nextSrcCursor);

			nextSrcLine += std::count(nextSrcCursor, nextIncludeCursor, '\n');
			nextSrcCursor = nextIncludeCursor;

			if (nextIncludeCursor < srcEnd)
			{
				auto nextIncludeEnd = string_find(src, '\n', nextIncludeCursor);

				auto localInclueStart = string_find(src, '"', nextIncludeCursor);
				auto systemInclueStart = string_find(src, '<', nextIncludeCursor);

				bool localInclude = true;
				std::string includeName;

				if (localInclueStart < nextIncludeEnd)
				{
					includeName.assign(localInclueStart + 1, string_find(src, '"', localInclueStart + 1));
					localInclude = true;
				}
				else if (systemInclueStart < nextIncludeEnd)
				{
					includeName.assign(systemInclueStart + 1, string_find(src, '>', systemInclueStart + 1));
					localInclude = false;
				}

				result << resolve_include(includeName, localInclude) << '\n';

				// Skip #include directive
				nextSrcCursor = nextIncludeEnd;
				if (nextSrcCursor < srcEnd)
					++nextSrcCursor;
				++nextSrcLine;
			}
		}

		return result.str();
	}

} // namespace
