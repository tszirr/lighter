#pragma once

#include "stdx"
#include <vector>

namespace ui
{

namespace detail
{
	namespace unique_element_identifier
	{
		template <class T, T V> struct GlobalTagObject { union U { T p; char c; }; static U const tag; };
		template <class T, T V> typename GlobalTagObject<T, V>::U const GlobalTagObject<T, V>::tag = { V };

		template <class T>
		struct GlobalTagObjectFromPtr {
			template <T P> static inline GlobalTagObject<T, P> make() { return GlobalTagObject<T, P>(); }
		};
		template <class T> GlobalTagObjectFromPtr<T*> inline globalTagObjectFromPtr(T*) { return GlobalTagObjectFromPtr<T*>(); }
		template <class T, class C> GlobalTagObjectFromPtr<T (C::*)> inline globalTagObjectFromPtr(T (C::*)) { return GlobalTagObjectFromPtr<T (C::*)>(); }
	}
}

// generates a unique element identification pointer from the given pointer _literal_
#define UEI(v) &(::ui::detail::unique_element_identifier::globalTagObjectFromPtr(v).template make<v>().tag)

struct UniqueElementIdentifier
{
	uintptr_t value;
	UniqueElementIdentifier(void const volatile* ptr)
		: value(reinterpret_cast<uintptr_t>(ptr)) { }
	UniqueElementIdentifier(uintptr_t value)
		: value(value) { }

	bool operator ==(UniqueElementIdentifier const& r) const { return value == r.value; }
	bool operator <(UniqueElementIdentifier const& r) const { return value < r.value; }

	static std::vector<UniqueElementIdentifier> concat(stdx::data_range_param<UniqueElementIdentifier const> path, UniqueElementIdentifier head)
	{
		std::vector<UniqueElementIdentifier> r;
		r.reserve(path.size() + 1);
		r.assign(path.begin(), path.end());
		r.push_back(head);
		return r;
	}
};

struct UniversalInterface
{
	virtual void pushGroup(UniqueElementIdentifier id) = 0;
	virtual void popGroup(UniqueElementIdentifier id) = 0;
	virtual void addLabel(char const* label) = 0;

	virtual void beginUnion() = 0;
	virtual void endUnion() = 0;
	
	template <class Value>
	struct Interaction
	{
		virtual void updateValue(Value const& value) = 0;
	};
	template <>
	struct Interaction<void>
	{
		virtual void trigger() = 0;
	};
	template <class Value, class ModifiedValue = Value>
	struct ValueInteraction : Interaction<Value>
	{
		ModifiedValue* value;
		ValueInteraction(std::nullptr_t) { }
		ValueInteraction(ModifiedValue& value)
			: value(&value) { }
		void updateValue(Value const& value) override {
			*this->value = value; }
	};
	template <class Value, class Function>
	struct FunctionInteraction : Interaction<Value>
	{
		Function* fun;
		FunctionInteraction(std::nullptr_t) { }
		FunctionInteraction(Function& fun)
			: fun(&fun) { }
		void updateValue(Value const& value) override {
			(*this->fun)(value); }
	};
	template <class Function>
	struct FunctionInteraction<void, Function> : Interaction<void>
	{
		Function* fun;
		FunctionInteraction(std::nullptr_t) { }
		FunctionInteraction(Function& fun)
			: fun(&fun) { }
		void trigger() override {
			(*this->fun)(); }
	};
	template <class Value>
	struct InteractionParam
	{
		Interaction<Value>* ptr;
		InteractionParam(std::nullptr_t) : ptr() { }
		InteractionParam(Value& value, ValueInteraction<Value>&& interaction = nullptr)
			: ptr(&interaction) { interaction = ValueInteraction<Value>(value); }
		template <class ModifiedValue>
		InteractionParam(ModifiedValue& value, ValueInteraction<Value, ModifiedValue>&& interaction  =nullptr
			, typename std::enable_if<std::is_assignable<ModifiedValue, Value>::value>::type* enable_if_var = nullptr)
			: ptr(&interaction) { interaction = ValueInteraction<Value, ModifiedValue>(value); }
		template <class Function>
		InteractionParam(Function&& fun, FunctionInteraction<Value, typename std::remove_reference<Function>::type>&& interaction = nullptr
			, typename std::enable_if<!std::is_assignable<Function, Value>::value>::type* enable_if_not_var = nullptr)
			: ptr(&interaction) { interaction = FunctionInteraction<Value, typename std::remove_reference<Function>::type>(fun); }
	};
	template <>
	struct InteractionParam<void>
	{
		Interaction<void>* ptr;
		InteractionParam(std::nullptr_t) : ptr() { }
		template <class Function>
		InteractionParam(Function&& fun, FunctionInteraction<void, typename std::remove_reference<Function>::type>&& interaction = nullptr)
			: ptr(&interaction) { interaction = FunctionInteraction<void, typename std::remove_reference<Function>::type>(fun); }
	};

	struct Button;
	struct ButtonEvent { enum T { Down, UpAccept, UpDismiss }; };
	virtual Button addButton(UniqueElementIdentifier id, char const* text, InteractionParam<void> interact) = 0;
	virtual Button addButton(UniqueElementIdentifier id, char const* text, bool value, InteractionParam<ButtonEvent::T> interact) = 0;
	virtual Button addOption(UniqueElementIdentifier id, char const* text, bool value, InteractionParam<bool> interact) = 0;
	virtual void addText(UniqueElementIdentifier id, char const* label, char const* text, InteractionParam<char const*> interact) = 0;
	struct Slider;
	virtual Slider addSlider(UniqueElementIdentifier id, char const* label, float value, float range, InteractionParam<float> interact, float ticks = 0.0f) = 0;
};

struct Group : stdx::noncopyable
{
	UniqueElementIdentifier id;
	UniversalInterface* ui;

	Group(std::nullptr_t) : id(nullptr), ui(nullptr) { }
	Group(UniversalInterface& ui, UniqueElementIdentifier id) : id(id), ui(&ui) { ui.pushGroup(id); }
	Group(Group&& right) : id(right.id), ui(right.ui) { right.id = nullptr; right.ui = nullptr; }
	~Group() { if (ui) ui->popGroup(id); }

	Group& operator =(Group&& right)
	{
		id = right.id; ui = right.ui;
		right.id = nullptr; right.ui = nullptr;
		return *this;
	}

	operator bool() const { return true; }
};

struct Union : stdx::noncopyable
{
	UniversalInterface* ui;

	Union(std::nullptr_t) : ui(nullptr) { }
	Union(UniversalInterface& ui) : ui(&ui) { ui.beginUnion(); }
	Union(Union&& right) : ui(right.ui) { right.ui = nullptr; }
	~Union() { if (ui) ui->endUnion(); }

	Union& operator =(Union&& right)
	{
		ui = right.ui;
		right.ui = nullptr;
		return *this;
	}

	operator bool() const { return true; }
};

} // namespace
