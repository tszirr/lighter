#pragma once

#include "stdx"
#include <vector>

namespace ui
{

namespace detail
{
	namespace unique_element_identifier
	{
		template <class T, T V> struct GlobalTagObject { union U { T p; char c; }; static U const tag; };
		template <class T, T V> typename GlobalTagObject<T, V>::U const GlobalTagObject<T, V>::tag = { V };

		template <class T>
		struct GlobalTagObjectFromPtr {
			template <T P> static inline GlobalTagObject<T, P> make() { return GlobalTagObject<T, P>(); }
		};
		template <class T> GlobalTagObjectFromPtr<T*> inline globalTagObjectFromPtr(T*) { return GlobalTagObjectFromPtr<T*>(); }
		template <class T, class C> GlobalTagObjectFromPtr<T (C::*)> inline globalTagObjectFromPtr(T (C::*)) { return GlobalTagObjectFromPtr<T (C::*)>(); }
	}
}

// generates a unique element identification pointer from the given pointer _literal_
#define UEI(v) &(::ui::detail::unique_element_identifier::globalTagObjectFromPtr(v).template make<v>().tag)

struct UniqueElementIdentifier
{
	uintptr_t value;
	UniqueElementIdentifier(void const volatile* ptr)
		: value(reinterpret_cast<uintptr_t>(ptr)) { }
	UniqueElementIdentifier(uintptr_t value)
		: value(value) { }

	bool operator ==(UniqueElementIdentifier const& r) const { return value == r.value; }
	bool operator <(UniqueElementIdentifier const& r) const { return value < r.value; }

	static std::vector<UniqueElementIdentifier> concat(stdx::data_range_param<UniqueElementIdentifier const> path, UniqueElementIdentifier head)
	{
		std::vector<UniqueElementIdentifier> r;
		r.reserve(path.size() + 1);
		r.assign(path.begin(), path.end());
		r.push_back(head);
		return r;
	}
};

struct UniversalInterfaceInteraction
{
	template <class Value>
	struct Interaction
	{
		virtual void updateValue(Value const& value) = 0;
	};
	template <>
	struct Interaction<void>
	{
		virtual void trigger() = 0;
	};

	template <class Value>
	struct InteractionParam;

	struct InteractionParamHelper
	{
		template <class Value, class ModifiedValue = Value>
		struct ValueInteraction : Interaction<Value>
		{
			ModifiedValue* value;
			ValueInteraction(std::nullptr_t) { }
			ValueInteraction(ModifiedValue& value)
				: value(&value) { }
			void updateValue(Value const& value) override {
				*this->value = value; }
		};
		template <class Value, class Function>
		struct FunctionInteraction : Interaction<Value>
		{
			Function* fun;
			FunctionInteraction(std::nullptr_t) { }
			FunctionInteraction(Function& fun)
				: fun(&fun) { }
			void updateValue(Value const& value) override {
				(*this->fun)(value); }
		};
		template <class Function>
		struct FunctionInteraction<void, Function> : Interaction<void>
		{
			Function* fun;
			FunctionInteraction(std::nullptr_t) { }
			FunctionInteraction(Function& fun)
				: fun(&fun) { }
			void trigger() override {
				(*this->fun)(); }
		};

		template <class IA = void>
		struct ParamStorage
		{
			char buffer[sizeof(IA)];
		};
		template <>
		struct ParamStorage<void>
		{
			char* buffer;
			template <class T>
			ParamStorage(ParamStorage<T>&& s)
				: buffer(s.buffer) { }
		};

		template <class ModifiedValue, class Value>
		struct enable_if_value : std::enable_if<
			!std::is_same< typename std::decay<ModifiedValue>::type, InteractionParam<Value> >::value && std::is_assignable<ModifiedValue, Value>::value
		> { };
		template <class Function, class Value>
		struct enable_if_function : std::enable_if<
			!std::is_same< typename std::decay<Function>::type, InteractionParam<Value> >::value && !std::is_assignable<Function, Value>::value
		> { };
	};

	template <class Value>
	struct InteractionParam : InteractionParamHelper
	{
		Interaction<Value>* ptr;
		InteractionParam(std::nullptr_t) : ptr() { }
		InteractionParam(Value& value, ValueInteraction<Value>&& interaction = nullptr)
			: ptr(&interaction) { interaction = ValueInteraction<Value>(value); }
		template <class ModifiedValue>
		InteractionParam(ModifiedValue& value, ParamStorage<> interaction = ParamStorage< ValueInteraction<Value, ModifiedValue> >()
			, typename enable_if_value<ModifiedValue, Value>::type* enable_if_var = nullptr)
			: ptr( new(interaction.buffer) ValueInteraction<Value, ModifiedValue>(value) ) { }
		template <class Function>
		InteractionParam(Function&& fun, ParamStorage<> interaction = ParamStorage< FunctionInteraction<Value, typename std::remove_reference<Function>::type> >()
			, typename enable_if_function<Function, Value>::type* enable_if_not_var = nullptr)
			: ptr( new(interaction.buffer) FunctionInteraction<Value, typename std::remove_reference<Function>::type>(fun) ) { }
		template <class Function>
		InteractionParam(Function* fun, ParamStorage<> interaction = ParamStorage< FunctionInteraction<Value, Function> >() 
			, typename enable_if_function<Function, Value>::type* enable_if_not_var = nullptr)
			: ptr( new(interaction.buffer) FunctionInteraction<Value, Function>(*fun) ) { }

		Interaction<Value>* operator ->() const { return ptr; }
		operator bool() const { return ptr != nullptr; }
	};
	template <>
	struct InteractionParam<void> : InteractionParamHelper
	{
		Interaction<void>* ptr;
		InteractionParam(std::nullptr_t) : ptr() { }
		template <class Function>
		InteractionParam(Function&& fun, ParamStorage<> interaction = ParamStorage< FunctionInteraction<void, typename std::remove_reference<Function>::type> >()
			, typename enable_if_function<Function, void>::type* enable_if_not_var = nullptr)
			: ptr( new(interaction.buffer) FunctionInteraction<void, typename std::remove_reference<Function>::type>(fun) ) { }
		template <class Function>
		InteractionParam(Function* fun, ParamStorage<> interaction = ParamStorage< FunctionInteraction<void, Function> >()
			, typename enable_if_function<Function, void>::type* enable_if_not_var = nullptr)
			: ptr( new(interaction.buffer) FunctionInteraction<void, Function>(*fun) ) { }

		Interaction<void>* operator ->() const { return ptr; }
		operator bool() const { return ptr != nullptr; }
	};
};

struct UniversalInterface : UniversalInterfaceInteraction
{
	virtual void pushGroup(UniqueElementIdentifier id) = 0;
	virtual void popGroup(UniqueElementIdentifier id) = 0;
	virtual void addLabel(char const* label) = 0;

	virtual void beginUnion() = 0;
	virtual void endUnion() = 0;

	struct Button;
	struct ButtonEvent { enum T { Down, UpAccept, UpDismiss }; };
	virtual void addButton(UniqueElementIdentifier id, char const* text, InteractionParam<void> interact, char const* fullText = nullptr, InteractionParam<Button> control = nullptr) = 0;
	virtual void addButton(UniqueElementIdentifier id, char const* text, bool value, InteractionParam<ButtonEvent::T> interact, InteractionParam<Button> control = nullptr) = 0;
	virtual void addOption(UniqueElementIdentifier id, char const* text, bool value, InteractionParam<bool> interact, InteractionParam<Button> control = nullptr) = 0;
	virtual void addText(UniqueElementIdentifier id, char const* label, char const* text, InteractionParam<char const*> interact) = 0;
	struct Slider;
	virtual void addSlider(UniqueElementIdentifier id, char const* label, float value, float range, InteractionParam<float> interact, float ticks = 0.0f, InteractionParam<Slider> control = nullptr) = 0;
};

struct Group : stdx::noncopyable
{
	UniqueElementIdentifier id;
	UniversalInterface* ui;

	Group(std::nullptr_t) : id(nullptr), ui(nullptr) { }
	Group(UniversalInterface& ui, UniqueElementIdentifier id) : id(id), ui(&ui) { ui.pushGroup(id); }
	Group(Group&& right) : id(right.id), ui(right.ui) { right.id = nullptr; right.ui = nullptr; }
	~Group() { if (ui) ui->popGroup(id); }

	Group& operator =(Group&& right)
	{
		id = right.id; ui = right.ui;
		right.id = nullptr; right.ui = nullptr;
		return *this;
	}

	operator bool() const { return true; }
};

struct Union : stdx::noncopyable
{
	UniversalInterface* ui;

	Union(std::nullptr_t) : ui(nullptr) { }
	Union(UniversalInterface& ui) : ui(&ui) { ui.beginUnion(); }
	Union(Union&& right) : ui(right.ui) { right.ui = nullptr; }
	~Union() { if (ui) ui->endUnion(); }

	Union& operator =(Union&& right)
	{
		ui = right.ui;
		right.ui = nullptr;
		return *this;
	}

	operator bool() const { return true; }
};

} // namespace
