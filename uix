#pragma once

#include "ui"
#include "ogl"

#include <algorithm>
#include <vector>

namespace ui
{

struct UiElement
{
	enum T
	{
		Frame,
		Bar,
		Ticks,
	};
};

struct UiRenderer
{
	struct QueuedWidget
	{
		unsigned xy;
		unsigned sizeXY;
		unsigned clazz;
		unsigned ex;

		template <class T>
		static unsigned build_tuple(T x, T y)
		{
			return (unsigned) stdx::to_unsigned(x)
				| ((unsigned) stdx::to_unsigned(y) << unsigned(8 * sizeof(T)));
		}
	};

	ogl::Program* widgetProgram;
	ogl::VertexArrays widgetArrays;
	unsigned widgetBatchCnt, widgetBatchSize;
	std::unique_ptr<QueuedWidget[]> widgetMem;
	ogl::Buffer widgetBuffer;

	UiRenderer(ogl::Program* program, unsigned widgetBatchSize)
		: widgetProgram(move(program))
		, widgetArrays()
		, widgetBatchCnt(0)
		, widgetBatchSize(widgetBatchSize)
		, widgetMem(new QueuedWidget[widgetBatchSize])
		, widgetBuffer(ogl::Buffer::create(GL_ARRAY_BUFFER, widgetBatchSize * sizeof(QueuedWidget), nullptr, GL_STATIC_DRAW))
	{
		widgetArrays.bind();
		widgetBuffer.bind(GL_ARRAY_BUFFER);
		glVertexAttribIPointer(0, 4, GL_UNSIGNED_INT, 0, nullptr);
		glEnableVertexAttribArray(0);
		widgetBuffer.unbind(GL_ARRAY_BUFFER);
		widgetArrays.unbind();
	}

	void drawWidget(glm::ivec2 pos, glm::uvec2 size, UiElement::T clazz, unsigned ex = 0)
	{
		if (widgetBatchCnt >= widgetBatchSize)
			flushWidgets();

		QueuedWidget qc = { QueuedWidget::build_tuple( (short) pos.x, (short) pos.y )
			, QueuedWidget::build_tuple( (unsigned short) size.x, (unsigned short) size.y )
			, clazz
		  , ex };
		widgetMem[widgetBatchCnt] = qc;
		++widgetBatchCnt;
	}

	void flushWidgets()
	{
		if (widgetBatchCnt > 0)
		{
			widgetBuffer.write(GL_ARRAY_BUFFER, stdx::make_range_n(widgetMem.get(), widgetBatchCnt));
			
			widgetArrays.bind();
			widgetProgram->bind();
			glDrawArrays(GL_POINTS, 0, widgetBatchCnt);
			
			widgetBatchCnt = 0;
		}
	}
};

struct TextUi : UserInterface, UniversalInterface
{
	UiRenderer* uiRenderer;
	TextRenderer* textRenderer;
	
	struct AbstractContext
	{
		bool active;
		
		AbstractContext()
			: active(true) { }
		virtual ~AbstractContext() { }

		void touch() { active = true; }
	};
	template <class T>
	struct GenericContext : T, AbstractContext
	{
		GenericContext() { }
		GenericContext(T&& v) : T(std::move(v)) { }
	};

	struct HiddenContext
	{
		int insertLine;
		unsigned pendingIndent;
		bool horizontalGroup;

		typedef std::pair< std::vector<UniqueElementIdentifier>, std::unique_ptr<AbstractContext> > edit_ctx_mapping;
		std::vector<edit_ctx_mapping> editContext;

	} hiddenCtx;

	TextUi(UiRenderer* uiRenderer, TextRenderer* textRenderer, Options options = Options())
		: uiRenderer(uiRenderer)
		, textRenderer(textRenderer)
	{
		setup.options = options;

		state.cursor.row = 0;
		state.cursor.column = -1;

		state.cursorVisible = true;
		state.focus = false;
	}
	
	// prepare internal state for next cycle
	UniversalInterface& reset() override
	{
		if (!state.mouse.primary && !state.mouse.secondary)
		{
			state.captureReleasedPath = state.capturePath;
			state.capturePath.clear();
		}

		context.parentPath.clear();
		context.pendingInput.clear();
		context.insertPos = setup.rect.min;

		hiddenCtx.editContext.erase(
			  std::remove_if(hiddenCtx.editContext.begin(), hiddenCtx.editContext.end(),
				[](HiddenContext::edit_ctx_mapping& m) { bool remove = !m.second->active; m.second->active = false; return remove; })
			, hiddenCtx.editContext.end()
			);

		hiddenCtx.insertLine = 0;
		hiddenCtx.pendingIndent = 0;
		hiddenCtx.horizontalGroup = false;

		if ( (state.mouse.primary && state.mouse.primaryChanged || state.mouse.secondary && state.mouse.secondaryChanged)
			&& state.capturePath.empty())
		{
			state.focus = in_aabb(state.mouse.pos, setup.rect);
		}

		// get next input
		{
			auto& cursor = state.cursor;

			auto it = state.input.begin(), itEnd = state.input.end();

			// process keyboard navigation
			for (; it < itEnd && (*it & InputKeys::NavKeyMask) == InputKeys::NavKeyMask; ++it)
				switch (*it)
				{
				case InputKeys::MoveDown: ++cursor.row; break;
				case InputKeys::MoveUp: --cursor.row; break;
				case InputKeys::MoveLeft: --cursor.column; break;
				case InputKeys::MoveRight: ++cursor.column; break;
				}

			// todo: make value-sensitive during draw/interact
			if (cursor.column < -1)
				cursor.column = -1;
			if (cursor.row < 0)
				cursor.row = 0;

			// isolate next batch of value input
			auto pendingBegin = it;
			for (; it < itEnd && (*it & InputKeys::NavKeyMask) != InputKeys::NavKeyMask; ++it);
			auto pendingEnd = it;

			// move next input batch from state to context
			context.pendingInput.assign(pendingBegin, pendingEnd);
			state.input.erase(state.input.begin(), pendingEnd);
		}

		return *this;
	}
	UniversalInterface& reset(Mouse const& mouse, stdx::data_range_param<unsigned const> input) override
	{
		state.mouse = mouse;
		if (state.focus)
			state.input.insert(state.input.end(), input.begin(), input.end());
		return TextUi::reset();
	}

	void capture(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id) override
	{
		state.capturePath = UniqueElementIdentifier::concat(path, id);
	}
	CaptureState::T captureState(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id) const override
	{
		if (state.capturePath.empty())
			return CaptureState::Available;
		else if (state.capturePath.size() - 1 == path.size()
				&& state.capturePath.back() == id
				&& std::equal(path.begin(), path.end(), state.capturePath.data()))
			return CaptureState::Owned;
		else
			return CaptureState::Unavailable;
	}
	bool wasCaptureReleased(stdx::data_range_param<UniqueElementIdentifier> path, UniqueElementIdentifier id) const override
	{
		return state.captureReleasedPath.size() - 1 == path.size()
				&& state.captureReleasedPath.back() == id
				&& std::equal(path.begin(), path.end(), state.captureReleasedPath.data());
	}

	void pushGroup(UniqueElementIdentifier id) override
	{
		context.parentPath.push_back(id);

		hiddenCtx.pendingIndent += setup.options.indent;
	}
	void popGroup(UniqueElementIdentifier id) override
	{
		assert(!context.parentPath.empty() && id == context.parentPath.back());
		context.parentPath.pop_back();

		if (hiddenCtx.pendingIndent >= setup.options.indent)
			hiddenCtx.pendingIndent -= setup.options.indent;
		else
			context.insertPos.x -= setup.options.indent;
	}
	void nextLine()
	{
		if (hiddenCtx.horizontalGroup)
			return;

		context.insertPos.x += hiddenCtx.pendingIndent;
		hiddenCtx.pendingIndent = 0;
		context.insertPos.y += setup.options.lineHeight;
		++hiddenCtx.insertLine;
	}

	void beginUnion() override
	{
		hiddenCtx.horizontalGroup = true;
	}

	void endUnion() override
	{
		hiddenCtx.horizontalGroup = false;
		nextLine();
	}

	template <class Context, class ContextFactory>
	Context& editContext(UniqueElementIdentifier id, ContextFactory&& factory)
	{
		auto editCtxBegin = hiddenCtx.editContext.begin(), editCtxEnd = hiddenCtx.editContext.end();

		struct ParentCompare
		{
			std::vector<UniqueElementIdentifier> const& parentPath;

			enum parent_t { parent };
			bool operator ()(HiddenContext::edit_ctx_mapping const& elem, parent_t) {
				return std::lexicographical_compare(elem.first.begin(), --elem.first.end(), parentPath.begin(), parentPath.end()); }
			bool operator ()(parent_t, HiddenContext::edit_ctx_mapping const& elem) {
				return std::lexicographical_compare(parentPath.begin(), parentPath.end(), elem.first.begin(), --elem.first.end()); }
		};

		ParentCompare parentCompare = { context.parentPath };
		auto parentBegin = std::lower_bound(editCtxBegin, editCtxEnd, ParentCompare::parent, parentCompare);
		auto insertPos = parentBegin;
		if (parentBegin != editCtxEnd && !parentCompare(ParentCompare::parent, *parentBegin))
		{
			auto parentEnd = std::upper_bound(editCtxBegin, editCtxEnd, ParentCompare::parent, parentCompare);

			struct HeadCompare
			{
				UniqueElementIdentifier ueid;

				enum head_t { head };
				bool operator ()(HiddenContext::edit_ctx_mapping const& elem, head_t) { return elem.first.back() < ueid; }
				bool operator ()(head_t, HiddenContext::edit_ctx_mapping const& elem) { return ueid < elem.first.back(); }
			};

			HeadCompare headCompare = { id };
			auto candidate = std::lower_bound(parentBegin, parentEnd, HeadCompare::head, headCompare);
			insertPos = candidate;
			if (candidate != parentEnd && candidate->first.back() == id)
				return static_cast<Context&>(*candidate->second);
		}

		insertPos = hiddenCtx.editContext.emplace(insertPos,
				  UniqueElementIdentifier::concat(context.parentPath, id)
				, factory()
			);
		return static_cast<Context&>(*insertPos->second);
	}
	template <class Context, class ContextFactory>
	GenericContext<Context>& genericEditContext(UniqueElementIdentifier id, ContextFactory&& factory)
	{
		return editContext< GenericContext<Context> >(
			  id
			  , [&factory]() { return std::unique_ptr< GenericContext<Context> >( new GenericContext<Context>(factory()) ); }
			);
	}

	void maybeDrawCursor(glm::ivec2 valuePos, char const* value)
	{
		if (hiddenCtx.insertLine == state.cursor.row)
			drawCursor(valuePos, value);
	}
	void drawCursor(glm::ivec2 valuePos, char const* value)
	{
		auto cursorPos = context.insertPos;
		if (state.cursor.column >= 0)
		{
			cursorPos = valuePos;
			if (state.cursor.column > 0)
				cursorPos.x = textRenderer->boundText(value, state.cursor.column, valuePos).max.x;
		}
		else
			cursorPos.x -= setup.options.labelDelta / 3;
		
		if (state.cursorVisible)
			textRenderer->drawText(cursorPos, "_");

		state.cursor.pos = cursorPos;
	}

	void addLabel(char const* label)
	{
		auto treePos = context.insertPos;
		treePos.x -= setup.options.labelDelta * 3 / 4;
//		treePos.y -= setup.options.lineHeight / 4;

		static unsigned short const arrow[3] = { '\\', '-' };
		static unsigned short const entry[3] = { '|', '-' };
		textRenderer->drawText(treePos, (hiddenCtx.pendingIndent) ? arrow : entry);
		
		auto labelPos = context.insertPos;
		labelPos.x -= textRenderer->boundText(label).max.x + setup.options.labelDelta;
		textRenderer->drawText(labelPos, label);
	}
	std::vector<char> editText(UniqueElementIdentifier id, char const* text, unsigned& textCursor) const
	{
		auto textLen = strlen(text);
		textCursor = std::min(textCursor, (unsigned) textLen);
		
		std::vector<char> newText(textLen + context.pendingInput.size() + 1);
		std::copy_n(text, textCursor, newText.data());

		auto headCursor = textCursor;
		auto tailCursor = textCursor;

		for (auto chr : context.pendingInput)
		{
			if (chr < InputKeys::KeyStart)
				newText[headCursor++] = (char) chr; // todo: utf-8
			else if (chr == InputKeys::DeleteLast && textCursor > 0)
				--headCursor;
			else if (chr == InputKeys::DeleteNext)
				++tailCursor;
		}

		size_t newTextLen = headCursor + (tailCursor < textLen ? textLen - tailCursor : 0);
		std::copy_n(text + tailCursor, newTextLen - headCursor, newText.data() + headCursor);
		newText[newTextLen] = 0;
		newText.resize(newTextLen);

		textCursor = headCursor;
		return newText;
	}
	template <class Func>
	void maybeEditText(UniqueElementIdentifier id, char const* text, Func&& func)
	{
		auto& cursor = state.cursor;
		if (!context.pendingInput.empty() && cursor.row == hiddenCtx.insertLine && cursor.column >= 0)
		{
			unsigned newCursor = cursor.column;
			
			auto newText = editText(id, text, newCursor);
			func(newText.data());
			
			cursor.column = (int) newCursor;
		}
	}

	void addText(UniqueElementIdentifier id, char const* label, char const* text, InteractionParam<char const*> interact) override
	{
		addLabel(label);

		auto valBox = textRenderer->drawText(context.insertPos, text);
		maybeDrawCursor(context.insertPos, text);

		auto& mouse = state.mouse;
		if ((mouse.primary || mouse.secondary) && in_aabb(mouse.pos, valBox))
		{
			size_t newCol;
			textRenderer->selectChar(mouse.pos, newCol, context.insertPos, text);
			if (newCol != ~0)
			{
				// todo: delay, might double input otherwise
				state.cursor.row = hiddenCtx.insertLine;
				state.cursor.column = (int) newCol;
			}
		}

		if (interact.ptr)
			maybeEditText(id, text, [&](char const* newText)
			{
				interact.ptr->updateValue(newText);
			});
		// warning: text may be invalid from here on

		nextLine();
	}

	Button addButton(UniqueElementIdentifier id, char const* text, bool value, InteractionParam<ButtonEvent::T> interact) override
	{
		auto valBox = textRenderer->boundText(text);
		
		unsigned buttonPadding = 6;
		unsigned buttonInset = 3;

		auto buttonPos = context.insertPos;
		buttonPos.y += valBox.min.y - buttonPadding; 
		auto buttonSize = glm::uvec2(valBox.max - valBox.min) + glm::uvec2(2 * buttonPadding);
		uiRenderer->drawWidget(buttonPos, buttonSize, ui::UiElement::Frame);
		
		Button button = { id, { buttonPos, buttonPos + glm::ivec2(buttonSize) }, false };

		auto& mouse = state.mouse;
		if (mouse.primary && glm::in_aabb(mouse.pos, button.rect) && capturedOrAcquired(context.parentPath, button.id, mouse.primaryChanged))
		{
			button.pressed = true;

			if (mouse.primaryChanged && interact.ptr)
				interact.ptr->updateValue(ButtonEvent::Down);
		}

		if (!mouse.primary && mouse.primaryChanged && interact.ptr && wasCaptureReleased(context.parentPath, button.id))
			interact.ptr->updateValue(
				glm::in_aabb(mouse.pos, button.rect)
					? ButtonEvent::UpAccept
					: ButtonEvent::UpDismiss);

		if (button.pressed != value)
		{
			auto barPos = buttonPos + glm::ivec2(buttonInset);
			auto barSize = buttonSize - glm::uvec2(2 * buttonInset);
			uiRenderer->drawWidget(barPos, barSize, ui::UiElement::Bar);
		}

		auto valPos = context.insertPos;
		valPos.x += (buttonSize.x - valBox.max.x) / 2;
		textRenderer->drawText(valPos, text);
		
		nextLine();

		return button;
	}

	Button addButton(UniqueElementIdentifier id, char const* text, InteractionParam<void> interact) override
	{
		return addButton(id, text, false, [&interact](ButtonEvent::T pressed) { if (pressed == ButtonEvent::UpAccept && interact.ptr) interact.ptr->trigger(); });
	}

	Button addOption(UniqueElementIdentifier id, char const* text, bool value, InteractionParam<bool> interact)
	{
		return addButton(id, text, value, [&interact, value](ButtonEvent::T pressed) { if (pressed == ButtonEvent::UpAccept && interact.ptr) interact.ptr->updateValue(!value); });
	}

	Slider addSlider(UniqueElementIdentifier id, char const* label, float value, float range, InteractionParam<float> interact, float ticks = 0.0f) override
	{
		addLabel(label);

		char numBuf[32];
		sprintf(numBuf, "%f", value);
		auto* num = (numBuf[0] == '0') ? &numBuf[1] : numBuf;
		
		auto valBox = textRenderer->boundText(num);
		
		unsigned sliderPadding = 6;
		unsigned sliderBarInset = 3;
		unsigned sliderTickLength = 2;

		auto sliderPos = context.insertPos;
		sliderPos.y += valBox.min.y - sliderPadding; 
		auto sliderSize = glm::uvec2(valBox.max - valBox.min) + glm::uvec2(2 * sliderPadding);
		sliderSize.x = std::max((int) sliderSize.x, (int) setup.rect.max.x - context.insertPos.x);
		uiRenderer->drawWidget(sliderPos, sliderSize, ui::UiElement::Frame);
		
		auto barPos = sliderPos + glm::ivec2(sliderBarInset);
		auto fullBarSize = sliderSize - glm::uvec2(2 * sliderBarInset);
		auto barEnd = barPos + glm::ivec2(fullBarSize);
		float relativeValue = value / range;
		float relativeValueBase = floor(relativeValue);
		auto barSize = fullBarSize;
		barSize.x = unsigned((relativeValue - relativeValueBase) * (float) barSize.x);
		uiRenderer->drawWidget(barPos, barSize, ui::UiElement::Bar);

		if (ticks > 0.0f)
		{
			auto tickPos = glm::ivec2(barPos.x, barEnd.y - sliderTickLength / 2);
			auto tickSize = glm::uvec2(fullBarSize.x, sliderTickLength);

			float tickDelta = ticks / range * (float) fullBarSize.x;
			uiRenderer->drawWidget(tickPos, tickSize, ui::UiElement::Ticks, stdx::as_<unsigned>(tickDelta));
		}

		auto valPos = context.insertPos;
		valPos.x += (sliderSize.x - valBox.max.x) / 2;
		valBox = textRenderer->drawText(valPos, num);
		maybeDrawCursor(valPos, num);
		
		auto& mouse = state.mouse;
		if ((mouse.primary || mouse.secondary) && in_aabb(mouse.pos, valBox))
		{
			size_t newCol;
			textRenderer->selectChar(mouse.pos, newCol, valPos, num);
			if (newCol != ~0)
			{
				// todo: delay, might double input otherwise
				state.cursor.row = hiddenCtx.insertLine;
				state.cursor.column = (int) newCol;
			}
		}

		if (interact.ptr)
			maybeEditText(id, num, [&](char const* newText)
			{
				float newVal = value;
				if (sscanf(newText, "%f", &newVal) == 1)
					interact.ptr->updateValue(newVal);
			});

		nextLine();

		Slider slider = { id, { barPos, barEnd }, value, range, relativeValueBase * range };
		
		if (interact.ptr)
		{
			if (mouse.primary && capturedOrAcquired(context.parentPath, slider.id, mouse.primaryChanged && glm::in_aabb(mouse.pos, slider.rect)))
			{
				struct EditContext
				{
					float valueBase;
				};
				auto& editCtx = genericEditContext<EditContext>(id, [&slider]() -> EditContext { EditContext c = { slider.valueBase }; return c; } );
				editCtx.touch();

				interact.ptr->updateValue(
					  editCtx.valueBase
					+ float(mouse.pos.x - slider.rect.min.x) / float(slider.rect.max.x - slider.rect.min.x) * slider.range
					);
			}
		}
		
		return slider;
	}
};

} // namespace
