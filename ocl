#pragma once

#include "oglbase"
#include "oclbase"

#define CL_MEM_WRITE_ACCESS_FLAG_MASK (CL_MEM_READ_WRITE | CL_MEM_WRITE_ONLY | CL_MEM_READ_ONLY)
#define GL_SHARING_EXTENSION "cl_khr_gl_sharing"

#include "stdx"
#include "filex"

#include <algorithm>
#include <iostream>
#include <string>

namespace ocl
{

struct Context : cl_delete<cl_context, clReleaseContext>::handle_type
{
	MOVE_BASE(Context, unique_handle)

	cl_platform_id platform;
	cl_device_id device;

	explicit Context(cl_device_type deviceType = CL_DEVICE_TYPE_GPU, bool enableGLSharing = true)
	{
		{
			cl_platform_id platformIDs[16];
			cl_uint numPlatformIDs = 0;
			THROW_OPENCL_ERROR( clGetPlatformIDs(arraylen(platformIDs), platformIDs, &numPlatformIDs), "Failed to get CL platform IDs" );

			cl_int err = CL_DEVICE_NOT_FOUND;
			for (cl_uint i = 0; i < numPlatformIDs; ++i)
			{
				err = clGetDeviceIDs(platformIDs[i], deviceType, 1, &device, nullptr);
				if (err == CL_SUCCESS)
				{
					platform = platformIDs[i];
					break;
				}
			}
			THROW_OPENCL_ERROR(err, "No matching device found.");
		}

		char deviceName[2048];
		THROW_OPENCL_ERROR( clGetDeviceInfo(device, CL_DEVICE_NAME, arraylen(deviceName), &deviceName, nullptr), "Unable to query device name.");
		std::cout << "OpenCL Device: " << deviceName << std::endl;

		if (enableGLSharing)
		{
			size_t extensionSize;
			THROW_OPENCL_ERROR( clGetDeviceInfo(device, CL_DEVICE_EXTENSIONS, 0, nullptr, &extensionSize), "Failed to get OpenCL extensions");
			std::string extensions(extensionSize, '\0');
			THROW_OPENCL_ERROR( clGetDeviceInfo(device, CL_DEVICE_EXTENSIONS, extensions.size(), &extensions[0], &extensionSize), "Failed to get OpenCL extensions");

			bool sharingSupported = false;

			for (auto extBegin = extensions.c_str(), extEnd = extBegin + extensions.size(); extBegin < extEnd; )
			{
				auto extDelim = std::find(extBegin, extEnd, ' ');

				if (std::search(extBegin, extDelim, GL_SHARING_EXTENSION, stdx::strend(GL_SHARING_EXTENSION)) != extDelim)
				{
					sharingSupported = true;
					break;
				}

				extBegin = extDelim + 1;
			}

			if(!sharingSupported)
				throwx( ocl_error("OpenCL sharing unsupported") );

			cl_context_properties const props[] = 
			{
				CL_GL_CONTEXT_KHR, (cl_context_properties) wglGetCurrentContext(), 
				CL_WGL_HDC_KHR, (cl_context_properties) wglGetCurrentDC(), 
				CL_CONTEXT_PLATFORM, (cl_context_properties) platform, 
				0
			};
			cl_int error;
			reset( clCreateContext(props, 1, &device, nullptr, nullptr, &error) );
			THROW_OPENCL_ERROR( error, "Failed to create OpenCL context");
		}
		else
		{
			cl_context_properties const props[] = 
			{
				CL_CONTEXT_PLATFORM, (cl_context_properties) platform, 
				0
			};
			cl_int error;
			reset( clCreateContext(props, 1, &device, nullptr, nullptr, &error) );
			THROW_OPENCL_ERROR( error, "Failed to create OpenCL context");
		}
	}
};

struct CommandStream : cl_delete<cl_command_queue, clReleaseCommandQueue>::handle_type
{
	MOVE_BASE(CommandStream, unique_handle)

	CommandStream(cl_context context, cl_device_id device, bool profiling = true)
	{
		cl_command_queue_properties const props = (profiling) ? CL_QUEUE_PROFILING_ENABLE : 0;

		cl_int error;
		reset( clCreateCommandQueue(context, device, props, &error) );
		THROW_OPENCL_ERROR(error, "Failed to create the command queue in the OpenCL context");
	}
};

struct Program : cl_delete<cl_program, clReleaseProgram>::handle_type
{
	MOVE_BASE(Program, unique_handle)

	Program(nullptr_t) { }
	Program(cl_context context, cl_device_id device, char const* source, char const* preamble = "")
	{
		char const* sources[] = { preamble, source };

		cl_int error;
		reset( clCreateProgramWithSource(context, 2, sources, nullptr, &error) );
		THROW_OPENCL_ERROR(error, "Failed to create OpenCL program");

		error = clBuildProgram(*this, 1, &device, nullptr, nullptr, nullptr);
		if(error != CL_SUCCESS)
		{
			printBuildLog(*this, device);
			THROW_OPENCL_ERROR(error, "Failed to build OpenCL program");
		}
	}

	static void printBuildLog(cl_program program, cl_device_id device)
	{
		cl_build_status buildStatus;
		THROW_OPENCL_ERROR(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_STATUS, sizeof(cl_build_status), &buildStatus, nullptr), "Failed to retrieve OpenCL build status");
		if (buildStatus == CL_SUCCESS)
			return;

		size_t logSize;
		THROW_OPENCL_ERROR(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, nullptr, &logSize), "Failed to retrieve OpenCL build log");
		std::string log(logSize, 0);
		THROW_OPENCL_ERROR(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log.size(), &log[0], nullptr), "Failed to retrieve OpenCL build log");

		std::cout << "There were build errors:" << std::endl;
		std::cout << log << std::endl;
	}

	static Program fromFile(cl_context context, cl_device_id device, char const* file, char const* preamble = "")
	{
		return ocl::Program(context, device, stdx::load_file(file).c_str(), preamble);
	}
};

struct Kernel : cl_delete<cl_kernel, clReleaseKernel>::handle_type
{
	MOVE_BASE(Kernel, unique_handle)

	Kernel(nullptr_t) { }
	Kernel(cl_program program, char const* name)
	{
		cl_int error;
		reset( clCreateKernel(program, name, &error) );
		THROW_OPENCL_ERROR(error, "Failed to create OpenCL kernel");
	}

	static Kernel fromSource(cl_context context, cl_device_id device, char const* source, char const* name)
	{
		return ocl::Kernel(ocl::Program(context, device, source), name);
	}
	static Kernel fromFile(cl_context context, cl_device_id device, char const* file, char const* name)
	{
		return ocl::Kernel(ocl::Program::fromFile(context, device, file), name);
	}

	template <class T>
	static T ceil_div(T x, T d)
	{
		return (x + d - 1) / d;
	}
	template <class T>
	static T ceil_mul(T x, T d)
	{
		auto r = x % d;
		return (r == 0) ? x : x + d - r;
	}

	template <class T>
	Kernel& allocate(unsigned idx, size_t N = 1)
	{
		THROW_OPENCL_ERROR( clSetKernelArg(*this, idx, sizeof(T) * N, nullptr), "Failed to allocate OpenCl kernel argument");
		return *this;
	}
	
	struct memory_arg { size_t bytes; memory_arg(size_t bytes) : bytes(bytes) { } };
	static memory_arg memoryBytes(size_t bytes) { return memory_arg(bytes); }
	template <class T>
	static memory_arg memory(size_t count) { return memory_arg(sizeof(T) * count); }
	template <class T>
	Kernel& set(unsigned idx, T const& arg)
	{
		THROW_OPENCL_ERROR( clSetKernelArg(*this, idx, sizeof(T), &arg), "Failed to set OpenCl kernel argument");
		return *this;
	}
	// trigger implicit cl_mem casts
	Kernel& set(unsigned idx, cl_mem arg)
	{
		set<cl_mem>(idx, arg);
		return *this;
	}
	Kernel& set(unsigned idx, memory_arg const& arg)
	{
		allocate<char>(idx, arg.bytes);
		return *this;
	}
	
	struct arg_stream
	{
		Kernel *const k;
		unsigned idx;

		template <class T>
		arg_stream operator <<(T const& arg)
		{
			auto result(*this);
			k->set(result.idx++, arg);
			return result;
		}
	};
	arg_stream args(unsigned startIdx = 0) { arg_stream r = { this, startIdx }; return r; }
	
	void launch(cl_command_queue stream, size_t globalX, size_t localX) const
	{
		size_t globalSize[] = { ceil_mul(globalX, localX) };
		size_t localSize[] = { localX };
		THROW_OPENCL_ERROR(
			clEnqueueNDRangeKernel(stream, *this, arraylen(globalSize), nullptr, &globalX, &localX, 0, nullptr, nullptr),
			"Failed to launch OpenCl kernel");
	}
	void launch(cl_command_queue stream, size_t globalX, size_t globalY, size_t localX, size_t localY) const
	{
		size_t globalSize[] = { ceil_mul(globalX, localX), ceil_mul(globalY, localY) };
		size_t localSize[] = { localX, localY };
		THROW_OPENCL_ERROR(
			clEnqueueNDRangeKernel(stream, *this, arraylen(globalSize), nullptr, globalSize, localSize, 0, nullptr, nullptr),
			"Failed to launch OpenCl kernel");
	}
	void launch(cl_command_queue stream, size_t globalX, size_t globalY, size_t globalZ, size_t localX, size_t localY, size_t localZ) const
	{
		size_t globalSize[] = { ceil_mul(globalX, localX), ceil_mul(globalY, localY), ceil_mul(globalZ, localZ) };
		size_t localSize[] = { localX, localY, localZ };
		THROW_OPENCL_ERROR(
			clEnqueueNDRangeKernel(stream, *this, arraylen(globalSize), nullptr, globalSize, localSize, 0, nullptr, nullptr),
			"Failed to launch OpenCl kernel");
	}
};

struct Event : cl_delete<cl_event, clReleaseEvent>::handle_type
{
	MOVE_BASE(Event, unique_handle)

	Event(nullptr_t) { }
	explicit Event(cl_event event)
		: unique_handle(event) { }
	explicit Event(cl_command_queue stream)
	{
		THROW_OPENCL_ERROR(clEnqueueMarker(stream, rebind()), "Failed to enqueue OpenCL event");
	}

	cl_ulong timeNS()
	{
		cl_ulong time;

		cl_int error = clGetEventProfilingInfo(*this, CL_PROFILING_COMMAND_START, sizeof(cl_ulong), &time, NULL);
		if (error == CL_PROFILING_INFO_NOT_AVAILABLE)
		{
			error = clWaitForEvents(1, &get());
			if (error == CL_SUCCESS)
				error = clGetEventProfilingInfo(*this, CL_PROFILING_COMMAND_START, sizeof(cl_ulong), &time, NULL);
		}
		THROW_OPENCL_ERROR(error,  "clGetEventProfilingInfo");

		return time;
	}
};

cl_ulong diffNS(Event &startEvent, Event &endEvent)
{
	auto end = endEvent.timeNS();
	auto start = startEvent.timeNS();
	return end - start;
}

double diffMS(Event &startEvent, Event &endEvent)
{
	return diffNS(startEvent, endEvent) / 1000000.0;
}

struct Buffer : cl_delete<cl_mem, clReleaseMemObject>::handle_type
{
	MOVE_BASE(Buffer, unique_handle)

	Buffer(nullptr_t) { }
	Buffer(cl_context context, void const* data, size_t size, cl_mem_flags flags = CL_MEM_READ_WRITE)
	{
		cl_int error;
		if (data && !(flags & CL_MEM_USE_HOST_PTR)) flags |= CL_MEM_COPY_HOST_PTR;
		reset( clCreateBuffer(context, flags, size, (void*) data, &error) );
		THROW_OPENCL_ERROR(error, "Failed to create OpenCL buffer object");
	}

	void writeBytes(cl_command_queue stream, void const* data, size_t size)
	{
		THROW_OPENCL_ERROR( clEnqueueWriteBuffer(stream, *this, CL_FALSE, 0, size, data, 0, nullptr, nullptr), "clEnqueueWriteBuffer" );
	}
	void readBytes(cl_command_queue stream, void* data, size_t size, cl_bool blocking = CL_TRUE)
	{
		THROW_OPENCL_ERROR( clEnqueueReadBuffer(stream, *this, blocking, 0, size, data, 0, nullptr, nullptr), "clEnqueueReadBuffer" );
	}

	template <class T>
	void write(cl_command_queue stream, T const* data, size_t count)
	{
		writeBytes(stream, data, sizeof(T) * count);
	}
	template <class T>
	void read(cl_command_queue stream, T* data, size_t count)
	{
		readBytes(stream, data, sizeof(T) * count);
	}

	template <class T>
	Buffer create(cl_context context, T* data, size_t count, cl_mem_flags flags = CL_MEM_READ_WRITE)
	{
		return Buffer(context, data, sizeof(T) * count, flags);
	}

	template <class Range>
	Buffer create(cl_context context, Range const& range, cl_mem_flags flags = CL_MEM_READ_WRITE)
	{
		return Buffer(context, range.data(), sizeof(*range.data()) * range.size(), flags);
	}
};

struct Image : cl_delete<cl_mem, clReleaseMemObject>::handle_type
{
	MOVE_BASE(Image, unique_handle)

	Image(nullptr_t) { }
	Image(cl_context context, cl_channel_order channelOrder, cl_channel_type channelType, size_t w, size_t h, void const* data, cl_mem_flags flags = CL_MEM_READ_WRITE)
	{
		cl_int error;
		cl_image_format format = { channelOrder, channelType };
		if (data && !(flags & CL_MEM_USE_HOST_PTR)) flags |= CL_MEM_COPY_HOST_PTR;
		reset( clCreateImage2D (context, flags, &format, w, h, 0, (void*) data, &error) );
		THROW_OPENCL_ERROR(error, "Failed to create OpenCL image object");
	}
};

struct Volume : cl_delete<cl_mem, clReleaseMemObject>::handle_type
{
	MOVE_BASE(Volume, unique_handle)

	Volume(nullptr_t) { }
	Volume(cl_context context, cl_channel_order channelOrder, cl_channel_type channelType, size_t w, size_t h, size_t d, void const* data, cl_mem_flags flags = CL_MEM_READ_WRITE)
	{
		cl_int error;
		cl_image_format format = { channelOrder, channelType };
		if (data && !(flags & CL_MEM_USE_HOST_PTR)) flags |= CL_MEM_COPY_HOST_PTR;
		reset( clCreateImage3D (context, flags, &format, w, h, d, 0, 0, (void*) data, &error) );
		THROW_OPENCL_ERROR(error, "Failed to create OpenCL volume object");
	}
};

inline size_t imageSizeInfo(cl_mem image, cl_image_info paramName)
{
	size_t result;
	THROW_OPENCL_ERROR( clGetImageInfo(image, paramName, sizeof(result), &result, nullptr), "clGetImageInfo" );
	return result;
}
inline size_t imageWidth(cl_mem image) { return imageSizeInfo(image, CL_IMAGE_WIDTH); }
inline size_t imageHeight(cl_mem image) { return imageSizeInfo(image, CL_IMAGE_HEIGHT); }
inline size_t imageDepth(cl_mem image) { return imageSizeInfo(image, CL_IMAGE_DEPTH); }
inline size_t imageElementSize(cl_mem image) { return imageSizeInfo(image, CL_IMAGE_ELEMENT_SIZE); }

inline void bufferToImage(cl_command_queue stream, cl_mem buffer, cl_mem image,
						  size_t offsetX = 0, size_t sizeX = -1,
						  size_t offsetY = 0, size_t sizeY = -1,
						  size_t offsetZ = 0, size_t sizeZ = -1)
{
	if (sizeX == -1) sizeX = imageWidth(image);
	if (sizeY == -1) sizeY = imageHeight(image);
	if (sizeZ == -1) { sizeZ = imageDepth(image); if (sizeZ == 0) sizeZ = 1; }

	size_t offset[3] = { offsetX, offsetY, offsetZ };
	size_t region[3] = { sizeX, sizeY, sizeZ };
	THROW_OPENCL_ERROR( clEnqueueCopyBufferToImage(stream, buffer, image, 0, offset, region, 0, nullptr, nullptr), "clEnqueueCopyBufferToImage" );
}

struct BufferedVolume
{
	ocl::Volume volume;
	ocl::Buffer buffer;

	MOVE_2_MEMBERS(BufferedVolume, volume, buffer);

	BufferedVolume(nullptr_t)
		: volume(nullptr)
		, buffer(nullptr) { }
	BufferedVolume(cl_context context, cl_channel_order channelOrder, cl_channel_type channelType, size_t w, size_t h, size_t d, void const* data, cl_mem_flags flags = 0)
		: volume(context, channelOrder, channelType, w, h, d, data, (flags & CL_MEM_WRITE_ACCESS_FLAG_MASK) ? flags : flags | CL_MEM_READ_ONLY)
		, buffer(context, nullptr, w * h * d * ocl::imageElementSize(volume), (flags & CL_MEM_WRITE_ACCESS_FLAG_MASK) ? flags : flags | CL_MEM_WRITE_ONLY)
	{
	}

	void copyToVolume(cl_command_queue stream) { ocl::bufferToImage(stream, buffer, volume); }
};

struct GlTexture : cl_delete<cl_mem, clReleaseMemObject>::handle_type
{
	MOVE_BASE(GlTexture, unique_handle)

	GlTexture(nullptr_t) { }
	GlTexture(cl_context context, GLenum glTextureType, GLuint glTexture, cl_mem_flags flags = CL_MEM_READ_WRITE, size_t mipLevel = 0)
	{
		cl_int error;
		reset( clCreateFromGLTexture2D(context, flags, glTextureType, (GLint) mipLevel, glTexture, &error) );
		THROW_OPENCL_ERROR(error, "Failed to create OpenCL texture object");
	}

	void bind(cl_command_queue stream)
	{
		THROW_OPENCL_ERROR( clEnqueueAcquireGLObjects(stream, 1, &get(), 0, nullptr, nullptr), "clEnqueueAcquireGLObjects()" );
	}

	void unbind(cl_command_queue stream)
	{
		THROW_OPENCL_ERROR( clEnqueueReleaseGLObjects(stream, 1, &get(), 0, nullptr, nullptr), "clEnqueueReleaseGLObjects()" );
	}
};

struct GlGuard : stdx::noncopyable
{
	cl_command_queue stream;

	GlGuard(cl_command_queue stream)
		: stream(stream)
	{
		glFinish();
		THROW_OPENGL_LASTERROR("glFinish()");
	}

	~GlGuard()
	{
		THROW_OPENCL_ERROR( clFinish(stream), "clFinish()" );
	}
};

template <class T>
struct BindGuard
{
	cl_command_queue stream;
	stdx::unique_handle<T*> bound;
	MOVE_2_MEMBERS(BindGuard, stream, bound)

	BindGuard(cl_command_queue stream, T &bound)
		: stream(stream),
		bound(&bound)
	{
		bound.bind(stream);
	}
	~BindGuard()
	{
		if (bound)
			bound.get()->unbind(stream);
	}

	void disarm() { bound = nullptr; }
};

template <class T>
inline BindGuard<T> bind_guarded(cl_command_queue stream, T &bound) { return BindGuard<T>(stream, bound); }

} // namespace
